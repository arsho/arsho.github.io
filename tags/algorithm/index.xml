<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on Ahmedur Rahman Shovon</title><link>https://arshovon.com/tags/algorithm/</link><description>Recent content in Algorithm on Ahmedur Rahman Shovon</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 15 Sep 2025 16:56:26 -0500</lastBuildDate><atom:link href="https://arshovon.com/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Get the majority element from a given list</title><link>https://arshovon.com/blog/majority-element/</link><pubDate>Tue, 24 Aug 2021 09:23:37 -0500</pubDate><guid>https://arshovon.com/blog/majority-element/</guid><description>&lt;p&gt;Given an array numbers of size &lt;code&gt;n&lt;/code&gt;, return the majority element.&lt;/p&gt;
&lt;h1 id="description"&gt;Description&lt;/h1&gt;
&lt;p&gt;The majority element is the element that appears more than &lt;code&gt;⌊n / 2⌋&lt;/code&gt; times. You may assume that the majority element always exists in the array.&lt;/p&gt;
&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;
&lt;h3 id="example-1"&gt;Example 1:&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Input: nums = [1, 2, 2]
Output: 2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="example-2"&gt;Example 2:&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Input: nums = [1, 2, 2, 2, 2, 1, 1]
Output: 2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id="solution"&gt;Solution&lt;/h1&gt;
&lt;h2 id="approach-1---hash-table"&gt;Approach 1 - Hash Table&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We can use a hash table to store the number of occurrences of each number.&lt;/li&gt;
&lt;li&gt;When the number of occurrences for a number is more than &lt;code&gt;⌊n / 2⌋&lt;/code&gt;, return it.&lt;/li&gt;
&lt;li&gt;Time complexity: &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Space complexity: &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution-in-java"&gt;Solution in Java:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Solution&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;majorityElement&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;[]&lt;/span&gt; nums) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; n &lt;span style="color:#f92672"&gt;=&lt;/span&gt; nums.&lt;span style="color:#a6e22e"&gt;length&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; nums&lt;span style="color:#f92672"&gt;[&lt;/span&gt;0&lt;span style="color:#f92672"&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; HashMap&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;Integer, Integer&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; occurrences &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;new&lt;/span&gt; HashMap&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;Integer, Integer&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; i: nums) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; numberOfOccurrences;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt;(occurrences.&lt;span style="color:#a6e22e"&gt;get&lt;/span&gt;(i) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; numberOfOccurrences &lt;span style="color:#f92672"&gt;=&lt;/span&gt; occurrences.&lt;span style="color:#a6e22e"&gt;get&lt;/span&gt;(i) &lt;span style="color:#f92672"&gt;+&lt;/span&gt; 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; numberOfOccurrences &lt;span style="color:#f92672"&gt;=&lt;/span&gt; 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occurrences.&lt;span style="color:#a6e22e"&gt;put&lt;/span&gt;(i, numberOfOccurrences);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt;(numberOfOccurrences &lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; n&lt;span style="color:#f92672"&gt;/&lt;/span&gt;2) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; major;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="solution-in-c"&gt;Solution in C++:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Solution&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;public&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; majorityElement(vector&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&amp;amp;&lt;/span&gt; nums) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; n &lt;span style="color:#f92672"&gt;=&lt;/span&gt; nums.size();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; nums[&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; map&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; occurrences;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;auto&lt;/span&gt; i: nums) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt;(occurrences.find(i) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; occurrences.end()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occurrences[i] &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occurrences[i]&lt;span style="color:#f92672"&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt;(occurrences[i] &lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; n&lt;span style="color:#f92672"&gt;/&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; major;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="solution-in-python-3"&gt;Solution in Python 3:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;from&lt;/span&gt; typing &lt;span style="color:#f92672"&gt;import&lt;/span&gt; List
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Solution&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;def&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;majorityElement&lt;/span&gt;(self, nums: List[int]) &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; int:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occurrences &lt;span style="color:#f92672"&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; nums[&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; i &lt;span style="color:#f92672"&gt;in&lt;/span&gt; nums:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occurrences[i] &lt;span style="color:#f92672"&gt;=&lt;/span&gt; occurrences&lt;span style="color:#f92672"&gt;.&lt;/span&gt;get(i, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;) &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; occurrences[i] &lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; len(nums) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; i
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; major
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="approach-2-boyer-moore-voting-algorithm"&gt;Approach 2: Boyer-Moore Voting Algorithm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We can use a counter with initial value to &lt;code&gt;0&lt;/code&gt; and set the first value as major element.&lt;/li&gt;
&lt;li&gt;Iterate through the given values.&lt;/li&gt;
&lt;li&gt;In each iteration, check the value of the counter. If it is &lt;code&gt;0&lt;/code&gt;, sets the current value as major element. Again, if the current value is same to the major element, increase the counter value by one. Otherwise, decrease the counter value by one.&lt;/li&gt;
&lt;li&gt;Time complexity: &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Space complexity: &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="solution-in-java-1"&gt;Solution in Java:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Solution&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;public&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;majorityElement&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;[]&lt;/span&gt; nums) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; nums&lt;span style="color:#f92672"&gt;[&lt;/span&gt;0&lt;span style="color:#f92672"&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; count &lt;span style="color:#f92672"&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; i: nums) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt;(count &lt;span style="color:#f92672"&gt;==&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; major &lt;span style="color:#f92672"&gt;=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt;(i &lt;span style="color:#f92672"&gt;==&lt;/span&gt; major)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; count&lt;span style="color:#f92672"&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; count&lt;span style="color:#f92672"&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; major;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="reference"&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/majority-element/"&gt;Leetcode challenge: Majority Element&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/"&gt;Boyer-Moore Voting Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Merge Sort</title><link>https://arshovon.com/blog/merge-sort/</link><pubDate>Thu, 29 Apr 2021 01:00:15 +0600</pubDate><guid>https://arshovon.com/blog/merge-sort/</guid><description>&lt;h2 id="divide-and-conquer-strategy-and-merge-sort"&gt;Divide and conquer strategy and merge sort&lt;/h2&gt;
&lt;p&gt;In a divide and conquer strategy, a problem is divided into multiple subproblems.
These subproblems are similar to the original problem but smaller in size.
The divide and conquer strategy solves these subproblems recursively.
Then it combines the solutions of the subproblems to develop a final solution for the original problem.
Thus, the divide and conquer strategy has two parts: divide and conquer.&lt;/p&gt;</description></item><item><title>Bubble Sort</title><link>https://arshovon.com/blog/bubble-sort/</link><pubDate>Wed, 28 Apr 2021 03:03:14 +0600</pubDate><guid>https://arshovon.com/blog/bubble-sort/</guid><description>&lt;p&gt;In the bubble sort algorithm, each pair of consecutive elements are swapped if they are not in the correct order. In each iteration, it places an element at its right place. Thus in &lt;code&gt;n&lt;/code&gt; iterations, all &lt;code&gt;n&lt;/code&gt; elements are sorted accordingly.&lt;/p&gt;
&lt;h2 id="bubble-sort-characteristics"&gt;Bubble sort characteristics&lt;/h2&gt;
&lt;h3 id="impractical"&gt;Impractical&lt;/h3&gt;
&lt;p&gt;Bubble sort is one of the fundamental sorting algorithms to learn how sorting works. It is not a practical sorting algorithm for its poor performance. Though bubble sort has the same time complexity as insertion sort, insertion sort is more efficient than bubble sort.&lt;/p&gt;</description></item><item><title>Understanding Time Complexity</title><link>https://arshovon.com/blog/understanding-time-complexity/</link><pubDate>Wed, 14 Apr 2021 00:01:36 +0600</pubDate><guid>https://arshovon.com/blog/understanding-time-complexity/</guid><description>&lt;h2 id="algorithm-efficiency"&gt;Algorithm efficiency&lt;/h2&gt;
&lt;p&gt;The efficiency of an algorithm is mainly measured by time complexity and space complexity. Time complexity describes the computational time required to run an algorithm for a set of input elements. It is generally expressed as a function of the size of the input.&lt;/p&gt;
&lt;h3 id="asymptotic-notations"&gt;Asymptotic notations&lt;/h3&gt;
&lt;p&gt;Three types of asymptotic notations are used to express both the time complexity and space complexity of an algorithm. We will compare these notations by three different scenarios of the same algorithm, the linear search algorithm. Suppose we have a list of &lt;code&gt;n&lt;/code&gt; integer values, and we need to find the index of the first occurrence of &lt;code&gt;x&lt;/code&gt; in this list. If &lt;code&gt;x&lt;/code&gt; is not found, then we need to return -1. Now we are going to describe the three types of asymptotic notations for this linear search algorithm.&lt;/p&gt;</description></item><item><title>Sorting Algorithm Comparisons</title><link>https://arshovon.com/blog/sorting-algorithm-comparisons/</link><pubDate>Sat, 15 Aug 2020 02:06:33 +0600</pubDate><guid>https://arshovon.com/blog/sorting-algorithm-comparisons/</guid><description>&lt;h3 id="sorting-algorithm-comparisons-table"&gt;Sorting Algorithm Comparisons Table&lt;/h3&gt;
&lt;p&gt;{.table .table-bordered .table-striped .table-hover .table-responsive}&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Criteria&lt;/th&gt;
 &lt;th&gt;&lt;a href="https://arshovon.com/blog/bubble-sort/"&gt;Bubble&lt;/a&gt;&lt;/th&gt;
 &lt;th&gt;Selection&lt;/th&gt;
 &lt;th&gt;&lt;a href="https://arshovon.com/blog/insertion-sort/"&gt;Insertion&lt;/a&gt;&lt;/th&gt;
 &lt;th&gt;&lt;a href="https://arshovon.com/blog/merge-sort/"&gt;Merge&lt;/a&gt;&lt;/th&gt;
 &lt;th&gt;Quick&lt;/th&gt;
 &lt;th&gt;&lt;a href="https://arshovon.com/blog/counting-sort/"&gt;Counting&lt;/a&gt;&lt;/th&gt;
 &lt;th&gt;Timsort&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Technique&lt;/td&gt;
 &lt;td&gt;Brute force&lt;/td&gt;
 &lt;td&gt;Brute force&lt;/td&gt;
 &lt;td&gt;Brute force&lt;/td&gt;
 &lt;td&gt;Divide-and-conquer&lt;/td&gt;
 &lt;td&gt;Divide-and-conquer&lt;/td&gt;
 &lt;td&gt;Non comparison&lt;/td&gt;
 &lt;td&gt;Hybrid&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Worst Time&lt;/td&gt;
 &lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;O(nlgn)&lt;/td&gt;
 &lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;O(k+n)&lt;/td&gt;
 &lt;td&gt;O(nlgn)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Average Time&lt;/td&gt;
 &lt;td&gt;Θ(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;Θ(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;Θ(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;Θ(nlgn)&lt;/td&gt;
 &lt;td&gt;Θ(nlgn)&lt;/td&gt;
 &lt;td&gt;Θ(k+n)&lt;/td&gt;
 &lt;td&gt;Θ(nlgn)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Best Time&lt;/td&gt;
 &lt;td&gt;Ω(n)&lt;/td&gt;
 &lt;td&gt;Ω(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
 &lt;td&gt;Ω(n)&lt;/td&gt;
 &lt;td&gt;Ω(nlgn)&lt;/td&gt;
 &lt;td&gt;Ω(nlgn)&lt;/td&gt;
 &lt;td&gt;Ω(k+n)&lt;/td&gt;
 &lt;td&gt;Ω(n)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Space&lt;/td&gt;
 &lt;td&gt;O(1)&lt;/td&gt;
 &lt;td&gt;O(1)&lt;/td&gt;
 &lt;td&gt;O(1)&lt;/td&gt;
 &lt;td&gt;O(n)&lt;/td&gt;
 &lt;td&gt;O(n)&lt;/td&gt;
 &lt;td&gt;O(k+n)&lt;/td&gt;
 &lt;td&gt;O(n)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Stable&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;In-place&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Online&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Adaptive&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;td&gt;No&lt;/td&gt;
 &lt;td&gt;Yes&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Suitable for&lt;/td&gt;
 &lt;td&gt;Sorted list&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;td&gt;Almost sorted list&lt;/td&gt;
 &lt;td&gt;List with unknown order&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;td&gt;0&amp;lt;=A[i]&amp;lt;=k&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="criteria-explanation"&gt;Criteria Explanation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Technique&lt;/strong&gt;: Methodology of the sorting algorithm.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Worst Time&lt;/strong&gt;: Worst time complexity (Big-O) of the algorithm.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Average Time&lt;/strong&gt;: Average time complexity (Big-Theta) of the algorithm.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Best Time&lt;/strong&gt;: Best time complexity (Big-Omega) of the algorithm.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Space&lt;/strong&gt;: Space complexity of the algorithm.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stable&lt;/strong&gt;: Stable algorithm maintains the relative order of input elements with equal values.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In-place&lt;/strong&gt;: In-place algorithm does not use auxiliary data structure to transform the input elements.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Online&lt;/strong&gt;: Online algorithm does not require the entire input available from the start.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adaptive&lt;/strong&gt;: Adaptive algorithm takes the advantages of presorted array elements.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition"&gt;Introduction to algorithms by Cormen, Thomas H and Leiserson, Charles E and Rivest, Ronald L and Stein, Clifford&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://arshovon.com/blog/bubble-sort/"&gt;Bubble sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://arshovon.com/blog/insertion-sort/"&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://arshovon.com/blog/merge-sort/"&gt;Merge sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://arshovon.com/blog/counting-sort/"&gt;Counting sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Sorting_algorithm"&gt;Sorting Algorithm - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Timsort"&gt;Timsort - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.c2.com/?TimSort"&gt;Timsort - C2 article&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.geeksforgeeks.org/analysis-of-different-sorting-techniques/"&gt;Analysis of different sorting techniques - Geeksforgeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Insertion Sort</title><link>https://arshovon.com/blog/insertion-sort/</link><pubDate>Tue, 11 Aug 2020 02:06:33 +0600</pubDate><guid>https://arshovon.com/blog/insertion-sort/</guid><description>&lt;h2 id="characteristics"&gt;Characteristics&lt;/h2&gt;
&lt;h3 id="simple-implementation"&gt;Simple implementation&lt;/h3&gt;
&lt;p&gt;Insertion sort can be implemented easily with less lines of code. It is quite efficient for small data sets. Though it has same complexity than other quadratic sorting algorithms like selection sort or bubble sort, insertion sort is more efficient.&lt;/p&gt;
&lt;h3 id="adaptive"&gt;Adaptive&lt;/h3&gt;
&lt;p&gt;Insertion sort is adaptive. If the input data set is already sorted, the number of steps are reduced.&lt;/p&gt;
&lt;h3 id="online"&gt;Online&lt;/h3&gt;
&lt;p&gt;Insertion sort works on the data as it receives it. The dataset is always sorted in each step of the insertion sort. A practical example of insertion sort is sorting a hand of playing cards. Assume, at the beginning of a card game, we have no cards in the left hand. Then we take a face down card from the table and search for it&amp;rsquo;s position in the left hand. To find the correct position for a card we compare the newly drawn card with each of the cards in the left hand from left to right. Then when we find the suitable spot, we insert the card into it&amp;rsquo;s correct position. At any times, the cards in the left hand are sorted.&lt;/p&gt;</description></item><item><title>Counting Sort</title><link>https://arshovon.com/blog/counting-sort/</link><pubDate>Sun, 09 Aug 2020 11:07:32 +0600</pubDate><guid>https://arshovon.com/blog/counting-sort/</guid><description>&lt;h2 id="characteristics"&gt;Characteristics&lt;/h2&gt;
&lt;h3 id="non-negative-integers-with-a-known-maximum-value"&gt;Non negative integers with a known maximum value&lt;/h3&gt;
&lt;p&gt;Counting sort can be applied if the input numbers are in the set &lt;code&gt;{0, 1, .. ,k}&lt;/code&gt;, a set of non negative integers with a maximum value &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="no-comparisons-between-elements"&gt;No comparisons between elements&lt;/h3&gt;
&lt;p&gt;There are no comparisons between input elements that take place in counting sort. It uses array indexing to determine the relative order of the input numbers. It identifies the relative positions of each input element. For each element &lt;code&gt;x&lt;/code&gt;, counting sort counts number of elements less than &lt;code&gt;x&lt;/code&gt;. Then it uses this information to place element &lt;code&gt;x&lt;/code&gt; directly into its correct position.&lt;/p&gt;</description></item></channel></rss>