<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
		<style type="text/css">

		body{
			background: aliceblue;
		}
		.txtarea{
		margin: 2px auto;
		width: 80%;
		padding: 10px;
		vertical-align: top;
		text-align: left;
		height: 62%;
		overflow: hidden;
		line-height: 30px;
		font-family: Verdana;
		font-size: 24px;
		color: black;
		border: 3px solid rgb(1, 1, 10);
		border-radius: 7px;
		background: white;
		}
		.txtarea div{
					display: inline;
		}
		.highlight{
			background: rgb(231, 223, 221);
			color: rgb(20, 133, 162);
			padding: 3px 6px;
			border: 2px solid rgb(185, 164, 168);
			border-radius: 5px;
		}
		.ac
		{
			color: green;
		}
		.wa{
			color: red;
		}
		.in{
		margin: 10px auto;
		width: 40%;
		}
		input[type="text"]{

		font-family: Verdana;
			text-align: left;
		font-size: 26px;
		color: black;
		border: 3px solid rgb(1, 1, 10);
		border-radius: 7px;
		background: white;
		padding: 10px;
		width: 100%;
		outline: 0;
		}
		input[type="text"]:focus{
		border: 3px solid #0d6db6;
		color:#333;
		border-radius: 7px;
		}
		#res{
			display: none;
			padding: 20px;
			position: fixed;
			left:34%;
			top:35%;
			border-radius: 7px;
			line-height: 40px;
		font-family: Verdana;
		font-size: 28px;
		color: black;
		border: 3px solid rgb(1, 1, 10);
		border-radius: 7px;
		background: white;
		}
		#res h3{
			display: inline;
			margin: 0;
		}
		#res p{
			margin: 2px;
		}
		#count{
			line-height: 30px;
		font-family: Verdana;
		font-size: 24px;
		color: black;
		border: 3px solid rgb(1, 1, 10);
		border-radius: 7px;
		background: rgb(129, 206, 190);
		width: 40%;
		margin: 10px auto;
		text-align: center;
		padding: 5px;
		}
		#count p{
			margin: 0px;
		}
		#reset {
		display:block;
		margin: 0px auto;
		padding:5px;
		text-decoration:none;
		width:20%;
		color:rgb(20, 133, 162);
		background: #587898;
		cursor: pointer;
		font-family: Verdana;
		font-size: 24px;
		color: black;
		border: 3px solid rgb(1, 1, 10);
		border-radius: 7px;
		text-align: center;
		}
		#reset:hover{
		color:#fff;
		background: #3279BB;
		cursor: pointer;
		border: 4px solid #0d6db6;
		}
		.ribbon-outer
		{
		width:105px;
		height:108px;
		overflow:hidden;
		position:absolute;
		top: 0px;
		right: 0px;
		}
		.ribbon-inner
		{
		font: bold 18px Sans-Serif;
		background: rgb(255,175,75); /* Old browsers */
		background: -moz-linear-gradient(top, rgba(255,175,75,1) 0%, rgba(255,146,10,1) 100%); /* FF3.6+ */
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(255,175,75,1)), color-stop(100%,rgba(255,146,10,1))); /* Chrome,Safari4+ */
		background: -webkit-linear-gradient(top, rgba(255,175,75,1) 0%,rgba(255,146,10,1) 100%); /* Chrome10+,Safari5.1+ */
		background: -o-linear-gradient(top, rgba(255,175,75,1) 0%,rgba(255,146,10,1) 100%); /* Opera 11.10+ */
		background: -ms-linear-gradient(top, rgba(255,175,75,1) 0%,rgba(255,146,10,1) 100%); /* IE10+ */
		background: linear-gradient(to bottom, rgba(255,175,75,1) 0%,rgba(255,146,10,1) 100%); /* W3C */
		filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffaf4b', endColorstr='#ff920a',GradientType=0 ); /* IE6-9 */
		text-align:center;
		color:#FFFFFF;
		text-align:center;
		padding:5px;
		top:25px;
		right:19px;
		width:150px;
		position:relative;
		-webkit-transform: rotate(45deg);
		transform: rotate(45deg);
		-moz-transform: rotate(45deg);
		-webkit-transition: all .5s ease-in-out;
		-moz-transition: all .5s ease-in-out;
		-ms-transition: all .5s ease-in-out;
		-o-transition: all .5s ease-in-out;
		transition: all .5s ease-in-out;
		}
		.ribbon-inner:hover{
			cursor: pointer;
		background: rgb(167,207,223);
		background: -moz-linear-gradient(top, rgba(167,207,223,1) 0%, rgba(35,83,138,1) 100%);
		background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(167,207,223,1)), color-stop(100%,rgba(35,83,138,1)));
		background: -webkit-linear-gradient(top, rgba(167,207,223,1) 0%,rgba(35,83,138,1) 100%);
		background: -o-linear-gradient(top, rgba(167,207,223,1) 0%,rgba(35,83,138,1) 100%);
		background: -ms-linear-gradient(top, rgba(167,207,223,1) 0%,rgba(35,83,138,1) 100%);
		background: linear-gradient(top, rgba(167,207,223,1) 0%,rgba(35,83,138,1) 100%);
		filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#a7cfdf', endColorstr='#23538a',GradientType=0 );
		color: #fff;
		}
		.ribbon-inner:before, .ribbon-inner:after {
		content: "";
		border-top:   3px solid #CC7A29;
		border-left:  3px solid transparent;
		border-right: 3px solid transparent;
		position:absolute;
		bottom: -3px;
		}
		.ribbon-inner:before {
		left: 0;
		}
		.ribbon-inner:after {
		right: 0;
			}
		a
		{
			text-decoration: none;
		}
		.custom-menu {
    z-index:1000;
    position: absolute;
    background-color:#C0C0C0;
    border: 1px solid black;
    padding: 2px;
}
		</style>
	<script src="./typespeed_files/all.js" async="" crossorigin="anonymous"></script><script id="facebook-jssdk" async="" src="./typespeed_files/all(1).js"></script><style type="text/css">.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_dialog_advanced{border-radius:8px;padding:10px}.fb_dialog_content{background:#fff;color:#373737}.fb_dialog_close_icon{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{left:5px;right:auto;top:5px}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent}.fb_dialog_close_icon:active{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #365899;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{height:100%;left:0;margin:0;overflow:visible;position:absolute;top:-10000px;transform:none;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{background:none;height:auto;min-height:initial;min-width:initial;width:auto}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{clear:both;color:#fff;display:block;font-size:18px;padding-top:20px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .4);bottom:0;left:0;min-height:100%;position:absolute;right:0;top:0;width:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_mobile .fb_dialog_iframe{position:sticky;top:0}.fb_dialog_content .dialog_header{background:linear-gradient(from(#738aba), to(#2c4987));border-bottom:1px solid;border-color:#043b87;box-shadow:white 0 1px 1px -1px inset;color:#fff;font:bold 14px Helvetica, sans-serif;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:linear-gradient(from(#4267B2), to(#2a4887));background-clip:padding-box;border:1px solid #29487d;border-radius:3px;display:inline-block;line-height:18px;margin-top:3px;max-width:85px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{background:none;border:none;color:#fff;font:bold 12px Helvetica, sans-serif;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #4a4a4a;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f5f6f7;border:1px solid #4a4a4a;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://static.xx.fbcdn.net/rsrc.php/v3/yD/r/t-wz8gw1xG1.png);background-position:50% 50%;background-repeat:no-repeat;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}</style></head>
	<body>
<div id="fb-root" class=" fb_reset"><div style="position: absolute; top: -10000px; width: 0px; height: 0px;"><div></div></div></div>
<script>
var achecksho=5;
window.fbAsyncInit = function() {
// init the Facebook JavaScript SDK
    FB.init({
        appId       : '338029989624891',
        channelUrl  : null,
        status      : true,
        cookie      : false,
        xfbml       : false
    });

    FB.Event.subscribe('auth.authResponseChange', function(response)
    {
        if (response.status === 'connected')
          {
          	achecksho=1;
          }
        else
          {
          	  achecksho=2;
          }
    });
    };
</script>
<script>
      (function(d){
         var js, id = 'facebook-jssdk'; if (d.getElementById(id)) {return;}
         js = d.createElement('script'); js.id = id; js.async = true;
         js.src = "//connect.facebook.net/es_LA/all.js";
         d.getElementsByTagName('head')[0].appendChild(js);
       }(document));
</script>
		<div class="txtarea" id="words"><div class="highlight" id="0">if</div> <div id="1">all</div> <div id="2">about</div> <div id="3">as</div> <div id="4">time</div> <div id="5">so</div> <div id="6">which</div> <div id="7">me</div> <div id="8">out</div> <div id="9">see</div> <div id="10">come</div> <div id="11">than</div> <div id="12">how</div> <div id="13">our</div> <div id="14">these</div> <div id="15">look</div> <div id="16">new</div> <div id="17">more</div> <div id="18">man</div> <div id="19">thing</div> <div id="20">well</div> <div id="21">tell</div> <div id="22">her</div> <div id="23">any</div> <div id="24">through</div> <div id="25">child</div> <div id="26">down</div> <div id="27">should</div> <div id="28">over</div> <div id="29">try</div> <div id="30">last</div> <div id="31">too</div> <div id="32">when</div> <div id="33">become</div> <div id="34">really</div> <div id="35">another</div> <div id="36">own</div> <div id="37">put</div> <div id="38">mean</div> <div id="39">student</div> <div id="40">great</div> <div id="41">group</div> <div id="42">country</div> <div id="43">where</div> <div id="44">every</div> <div id="45">might</div> <div id="46">part</div> <div id="47">place</div> <div id="48">again</div> <div id="49">most</div> <div id="50">where</div> <div id="51">right</div> <div id="52">so</div> <div id="53">work</div> <div id="54">run</div> <div id="55">off</div> <div id="56">like</div> <div id="57">Mr</div> <div id="58">hold</div> <div id="59">happen</div> <div id="60">before</div> <div id="61">million</div> <div id="62">under</div> <div id="63">write</div> <div id="64">national</div> <div id="65">young</div> <div id="66">different</div> <div id="67">study</div> <div id="68">job</div> <div id="69">business</div> <div id="70">kind</div> <div id="71">far</div> <div id="72">both</div> <div id="73">yes</div> <div id="74">long</div> <div id="75">around</div> <div id="76">father</div> <div id="77">until</div> <div id="78">game</div> <div id="79">line</div> <div id="80">among</div> <div id="81">bad</div> <div id="82">member</div> <div id="83">meet</div> <div id="84">almost</div> <div id="85">set</div> <div id="86">much</div> <div id="87">once</div> <div id="88">president</div> <div id="89">change</div> <div id="90">best</div> <div id="91">kid</div> <div id="92">nothing</div> <div id="93">lead</div> <div id="94">whether</div> <div id="95">together</div> <div id="96">parent</div> <div id="97">face</div> <div id="98">public</div> <div id="99">others</div> <div id="100">allow</div> <div id="101">spend</div> <div id="102">person</div> <div id="103">such</div> <div id="104">party</div> <div id="105">result</div> <div id="106">morning</div> <div id="107">low</div> <div id="108">girl</div> <div id="109">food</div> <div id="110">himself</div> <div id="111">force</div> <div id="112">both</div> <div id="113">although</div> <div id="114">second</div> <div id="115">toward</div> <div id="116">off</div> <div id="117">love</div> <div id="118">including</div> <div id="119">actually</div> <div id="120">human</div> <div id="121">market</div> <div id="122">expect</div> <div id="123">build</div> <div id="124">oh</div> <div id="125">cut</div> <div id="126">death</div> <div id="127">experience</div> <div id="128">local</div> <div id="129">remain</div> <div id="130">yeah</div> <div id="131">control</div> <div id="132">perhaps</div> <div id="133">hard</div> <div id="134">pass</div> <div id="135">major</div> <div id="136">along</div> <div id="137">report</div> <div id="138">economic</div> <div id="139">decide</div> <div id="140">possible</div> <div id="141">show</div> <div id="142">voice</div> <div id="143">police</div> <div id="144">pull</div> <div id="145">military</div> <div id="146">less</div> <div id="147">explain</div> <div id="148">even</div> <div id="149">relationship</div> <div id="150">road</div> <div id="151">true</div> <div id="152">better</div> <div id="153">receive</div> <div id="154">building</div> <div id="155">model</div> <div id="156">society</div> <div id="157">director</div> <div id="158">player</div> <div id="159">record</div> <div id="160">paper</div> <div id="161">ground</div> <div id="162">event</div> <div id="163">matter</div> <div id="164">couple</div> <div id="165">project</div> <div id="166">activity</div> <div id="167">need</div> <div id="168">eat</div> <div id="169">oil</div> <div id="170">easy</div> <div id="171">figure</div> <div id="172">image</div> <div id="173">either</div> <div id="174">quite</div> <div id="175">practice</div> <div id="176">recent</div> <div id="177">doctor</div> <div id="178">worker</div> <div id="179">movie</div> <div id="180">love</div> <div id="181">support</div> <div id="182">technology</div> <div id="183">baby</div> <div id="184">attention</div> <div id="185">Republican</div> <div id="186">red</div> <div id="187">choose</div> <div id="188">look</div> <div id="189">evidence</div> <div id="190">listen</div> <div id="191">billion</div> <div id="192">energy</div> <div id="193">summer</div> <div id="194">hundred</div> <div id="195">likely</div> <div id="196">short</div> <div id="197">choice</div> <div id="198">rule</div> <div id="199">south</div> <div id="200">floor</div> <div id="201">population</div> <div id="202">economy</div> <div id="203">church</div> <div id="204">risk</div> <div id="205">future</div> <div id="206">defense</div> <div id="207">security</div> <div id="208">certainly</div> <div id="209">board</div> <div id="210">subject</div> <div id="211">rest</div> <div id="212">performance</div> <div id="213">top</div> <div id="214">goal</div> <div id="215">order</div> <div id="216">represent</div> <div id="217">drop</div> <div id="218">upon</div> <div id="219">nature</div> <div id="220">recently</div> <div id="221">sound</div> <div id="222">before</div> <div id="223">page</div> <div id="224">than</div> <div id="225">other</div> <div id="226">concern</div> <div id="227">similar</div> <div id="228">each</div> <div id="229">dead</div> <div id="230">factor</div> <div id="231">shoot</div> <div id="232">seven</div> <div id="233">scene</div> <div id="234">despite</div> <div id="235">thus</div> <div id="236">happy</div> <div id="237">approach</div> <div id="238">dog</div> <div id="239">occur</div> <div id="240">sign</div> <div id="241">individual</div> <div id="242">pressure</div> <div id="243">hard</div> <div id="244">left</div> <div id="245">prepare</div> <div id="246">success</div> <div id="247">particularly</div> <div id="248">staff</div> <div id="249">character</div> <div id="250">degree</div> <div id="251">herself</div> <div id="252">box</div> <div id="253">pretty</div> <div id="254">election</div> <div id="255">lay</div> <div id="256">standard</div> <div id="257">fail</div> <div id="258">analysis</div> <div id="259">sex</div> <div id="260">present</div> <div id="261">glass</div> <div id="262">sister</div> <div id="263">operation</div> <div id="264">stage</div> <div id="265">authority</div> <div id="266">sort</div> <div id="267">ten</div> <div id="268">station</div> <div id="269">strategy</div> <div id="270">discuss</div> <div id="271">truth</div> <div id="272">democratic</div> <div id="273">leg</div> <div id="274">various</div> <div id="275">guess</div> <div id="276">study</div> <div id="277">entire</div> <div id="278">enough</div> <div id="279">claim</div> <div id="280">manager</div> <div id="281">sound</div> <div id="282">legal</div> <div id="283">form</div> <div id="284">science</div> <div id="285">card</div> <div id="286">cell</div> <div id="287">trial</div> <div id="288">spring</div> <div id="289">radio</div> <div id="290">care</div> <div id="291">tonight</div> <div id="292">no</div> <div id="293">yourself</div> <div id="294">impact</div> <div id="295">maintain</div> <div id="296">traditional</div> <div id="297">direction</div> <div id="298">cultural</div> <div id="299">head</div> <div id="300">pain</div> <div id="301">measure</div> <div id="302">fly</div> <div id="303">chair</div> <div id="304">camera</div> <div id="305">perform</div> <div id="306">suddenly</div> <div id="307">top</div> <div id="308">trip</div> <div id="309">inside</div> <div id="310">best</div> <div id="311">worry</div> <div id="312">rather</div> <div id="313">past</div> <div id="314">specific</div> <div id="315">necessary</div> <div id="316">fear</div> <div id="317">middle</div> <div id="318">bar</div> <div id="319">instead</div> <div id="320">detail</div> </div>
		<div id="count">Time remaining <span id="counter"> 60</span> seconds</div>
		<div class="in" id="inp">
			<input type="text" id="ans" placeholder="Click here to start">
		</div>
		<div id="reset">Reset</div>
		<div id="res" style="display: none;"><p></p><h3>Words per minute: </h3>0<p></p><p></p><h3>Accuracy: </h3>0%<p></p> <h3>Keystrokes: </h3>0<p></p></div>

		<a href="https://www.facebook.com/ars.shovon" target="_blank"><div id="rib" class="ribbon-outer" title="Click to visit my profile">
			<div id="ribtext" class="ribbon-inner">Shovon</div>
		</div>
		</a>

		<script type="text/javascript">
		/*!
		* jQuery JavaScript Library v1.8.3
		* http://jquery.com/
		*
		* Includes Sizzle.js
		* http://sizzlejs.com/
		*
		* Copyright 2012 jQuery Foundation and other contributors
		* Released under the MIT license
		* http://jquery.org/license
		*
		* Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
		*/
		(function( window, undefined ) {
		var
		// A central reference to the root jQuery(document)
		rootjQuery,
		// The deferred used on DOM ready
		readyList,
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,
		location = window.location,
		navigator = window.navigator,
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
		// Map over the $ in case of overwrite
		_$ = window.$,
		// Save a reference to some core methods
		core_push = Array.prototype.push,
		core_slice = Array.prototype.slice,
		core_indexOf = Array.prototype.indexOf,
		core_toString = Object.prototype.toString,
		core_hasOwn = Object.prototype.hasOwnProperty,
		core_trim = String.prototype.trim,
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
		},
		// Used for matching numbers
		core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,
		// Used for detecting and trimming whitespace
		core_rnotwhite = /\S/,
		core_rspace = /\s+/,
		// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
		// Match a standalone tag
		rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
		// JSON RegExp
		rvalidchars = /^[\],:{}\s]*$/,
		rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
		rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
		rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
		},
		// The ready event handler and self cleanup method
		DOMContentLoaded = function() {
		if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
		} else if ( document.readyState === "complete" ) {
		// we're here because readyState === "complete" in oldIE
		// which is good enough for us to call the dom ready!
		document.detachEvent( "onreadystatechange", DOMContentLoaded );
		jQuery.ready();
		}
		},
		// [[Class]] -> type pairs
		class2type = {};
		jQuery.fn = jQuery.prototype = {
		constructor: jQuery,
		init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;
		// Handle $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
		return this;
		}
		// Handle $(DOMElement)
		if ( selector.nodeType ) {
		this.context = this[0] = selector;
		this.length = 1;
		return this;
		}
		// Handle HTML strings
		if ( typeof selector === "string" ) {
		if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
		// Assume that strings that start and end with <> are HTML and skip the regex check
		match = [ null, selector, null ];
		} else {
		match = rquickExpr.exec( selector );
		}
		// Match html or make sure no context is specified for #id
		if ( match && (match[1] || !context) ) {
		// HANDLE: $(html) -> $(array)
		if ( match[1] ) {
		context = context instanceof jQuery ? context[0] : context;
		doc = ( context && context.nodeType ? context.ownerDocument || context : document );
		// scripts is true for back-compat
		selector = jQuery.parseHTML( match[1], doc, true );
		if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
		this.attr.call( selector, context, true );
		}
		return jQuery.merge( this, selector );
		// HANDLE: $(#id)
		} else {
		elem = document.getElementById( match[2] );
		// Check parentNode to catch when Blackberry 4.6 returns
		// nodes that are no longer in the document #6963
		if ( elem && elem.parentNode ) {
		// Handle the case where IE and Opera return items
		// by name instead of ID
		if ( elem.id !== match[2] ) {
		return rootjQuery.find( selector );
		}
		// Otherwise, we inject the element directly into the jQuery object
		this.length = 1;
		this[0] = elem;
		}
		this.context = document;
		this.selector = selector;
		return this;
		}
		// HANDLE: $(expr, $(...))
		} else if ( !context || context.jquery ) {
		return ( context || rootjQuery ).find( selector );
		// HANDLE: $(expr, context)
		// (which is just equivalent to: $(context).find(expr)
		} else {
		return this.constructor( context ).find( selector );
		}
		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
		return rootjQuery.ready( selector );
		}
		if ( selector.selector !== undefined ) {
		this.selector = selector.selector;
		this.context = selector.context;
		}
		return jQuery.makeArray( selector, this );
		},
		// Start with an empty selector
		selector: "",
		// The current version of jQuery being used
		jquery: "1.8.3",
		// The default length of a jQuery object is 0
		length: 0,
		// The number of elements contained in the matched element set
		size: function() {
		return this.length;
		},
		toArray: function() {
		return core_slice.call( this );
		},
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
		return num == null ?
		// Return a 'clean' array
		this.toArray() :
		// Return just the object
		( num < 0 ? this[ this.length + num ] : this[ num ] );
		},
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );
		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;
		if ( name === "find" ) {
		ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
		ret.selector = this.selector + "." + name + "(" + selector + ")";
		}
		// Return the newly-formed element set
		return ret;
		},
		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
		return jQuery.each( this, callback, args );
		},
		ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );
		return this;
		},
		eq: function( i ) {
		i = +i;
		return i === -1 ?
		this.slice( i ) :
		this.slice( i, i + 1 );
		},
		first: function() {
		return this.eq( 0 );
		},
		last: function() {
		return this.eq( -1 );
		},
		slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ),
		"slice", core_slice.call(arguments).join(",") );
		},
		map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
		return callback.call( elem, i, elem );
		}));
		},
		end: function() {
		return this.prevObject || this.constructor(null);
		},
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: core_push,
		sort: [].sort,
		splice: [].splice
		};
		// Give the init function the jQuery prototype for later instantiation
		jQuery.fn.init.prototype = jQuery.fn;
		jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
		}
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
		}
		// extend jQuery itself if only one argument is passed
		if ( length === i ) {
		target = this;
		--i;
		}
		for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
		// Extend the base object
		for ( name in options ) {
		src = target[ name ];
		copy = options[ name ];
		// Prevent never-ending loop
		if ( target === copy ) {
		continue;
		}
		// Recurse if we're merging plain objects or arrays
		if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
		if ( copyIsArray ) {
		copyIsArray = false;
		clone = src && jQuery.isArray(src) ? src : [];
		} else {
		clone = src && jQuery.isPlainObject(src) ? src : {};
		}
		// Never move original objects, clone them
		target[ name ] = jQuery.extend( deep, clone, copy );
		// Don't bring in undefined values
		} else if ( copy !== undefined ) {
		target[ name ] = copy;
		}
		}
		}
		}
		// Return the modified object
		return target;
		};
		jQuery.extend({
		noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
		window.$ = _$;
		}
		if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
		}
		return jQuery;
		},
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
		// Hold (or release) the ready event
		holdReady: function( hold ) {
		if ( hold ) {
		jQuery.readyWait++;
		} else {
		jQuery.ready( true );
		}
		},
		// Handle when the DOM is ready
		ready: function( wait ) {
		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
		return;
		}
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
		return setTimeout( jQuery.ready, 1 );
		}
		// Remember that the DOM is ready
		jQuery.isReady = true;
		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
		return;
		}
		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
		jQuery( document ).trigger("ready").off("ready");
		}
		},
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
		},
		isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
		},
		isWindow: function( obj ) {
		return obj != null && obj == obj.window;
		},
		isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
		},
		type: function( obj ) {
		return obj == null ?
		String( obj ) :
		class2type[ core_toString.call(obj) ] || "object";
		},
		isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
		return false;
		}
		try {
		// Not own constructor property must be Object
		if ( obj.constructor &&
		!core_hasOwn.call(obj, "constructor") &&
		!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
		return false;
		}
		} catch ( e ) {
		// IE8,9 Will throw exceptions on certain host objects #9897
		return false;
		}
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for ( key in obj ) {}
		return key === undefined || core_hasOwn.call( obj, key );
		},
		isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
		return false;
		}
		return true;
		},
		error: function( msg ) {
		throw new Error( msg );
		},
		// data: string of html
		// context (optional): If specified, the fragment will be created in this context, defaults to document
		// scripts (optional): If true, will include scripts passed in the html string
		parseHTML: function( data, context, scripts ) {
		var parsed;
		if ( !data || typeof data !== "string" ) {
		return null;
		}
		if ( typeof context === "boolean" ) {
		scripts = context;
		context = 0;
		}
		context = context || document;
		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
		return [ context.createElement( parsed[1] ) ];
		}
		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
		(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
		},
		parseJSON: function( data ) {
		if ( !data || typeof data !== "string") {
		return null;
		}
		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );
		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
		return window.JSON.parse( data );
		}
		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
		.replace( rvalidtokens, "]" )
		.replace( rvalidbraces, "")) ) {
		return ( new Function( "return " + data ) )();
		}
		jQuery.error( "Invalid JSON: " + data );
		},
		// Cross-browser xml parsing
		parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
		return null;
		}
		try {
		if ( window.DOMParser ) { // Standard
		tmp = new DOMParser();
		xml = tmp.parseFromString( data , "text/xml" );
		} else { // IE
		xml = new ActiveXObject( "Microsoft.XMLDOM" );
		xml.async = "false";
		xml.loadXML( data );
		}
		} catch( e ) {
		xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
		}
		return xml;
		},
		noop: function() {},
		// Evaluates a script in a global context
		// Workarounds based on findings by Jim Driscoll
		// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
		globalEval: function( data ) {
		if ( data && core_rnotwhite.test( data ) ) {
		// We use execScript on Internet Explorer
		// We use an anonymous function so that context is window
		// rather than jQuery in Firefox
		( window.execScript || function( data ) {
		window[ "eval" ].call( window, data );
		} )( data );
		}
		},
		// Convert dashed to camelCase; used by the css and data modules
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
		nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
		// args is for internal usage only
		each: function( obj, callback, args ) {
		var name,
		i = 0,
		length = obj.length,
		isObj = length === undefined || jQuery.isFunction( obj );
		if ( args ) {
		if ( isObj ) {
		for ( name in obj ) {
		if ( callback.apply( obj[ name ], args ) === false ) {
		break;
		}
		}
		} else {
		for ( ; i < length; ) {
		if ( callback.apply( obj[ i++ ], args ) === false ) {
		break;
		}
		}
		}
		// A special, fast, case for the most common use of each
		} else {
		if ( isObj ) {
		for ( name in obj ) {
		if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
		break;
		}
		}
		} else {
		for ( ; i < length; ) {
		if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
		break;
		}
		}
		}
		}
		return obj;
		},
		// Use native String.trim function wherever possible
		trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
		return text == null ?
		"" :
		core_trim.call( text );
		} :
		// Otherwise use our own trimming functionality
		function( text ) {
		return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
		},
		// results is for internal usage only
		makeArray: function( arr, results ) {
		var type,
		ret = results || [];
		if ( arr != null ) {
		// The window, strings (and functions) also have 'length'
		// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
		type = jQuery.type( arr );
		if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
		core_push.call( ret, arr );
		} else {
		jQuery.merge( ret, arr );
		}
		}
		return ret;
		},
		inArray: function( elem, arr, i ) {
		var len;
		if ( arr ) {
		if ( core_indexOf ) {
		return core_indexOf.call( arr, elem, i );
		}
		len = arr.length;
		i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;
		for ( ; i < len; i++ ) {
		// Skip accessing in sparse arrays
		if ( i in arr && arr[ i ] === elem ) {
		return i;
		}
		}
		}
		return -1;
		},
		merge: function( first, second ) {
		var l = second.length,
		i = first.length,
		j = 0;
		if ( typeof l === "number" ) {
		for ( ; j < l; j++ ) {
		first[ i++ ] = second[ j ];
		}
		} else {
		while ( second[j] !== undefined ) {
		first[ i++ ] = second[ j++ ];
		}
		}
		first.length = i;
		return first;
		},
		grep: function( elems, callback, inv ) {
		var retVal,
		ret = [],
		i = 0,
		length = elems.length;
		inv = !!inv;
		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
		retVal = !!callback( elems[ i ], i );
		if ( inv !== retVal ) {
		ret.push( elems[ i ] );
		}
		}
		return ret;
		},
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
		var value, key,
		ret = [],
		i = 0,
		length = elems.length,
		// jquery objects are treated as arrays
		isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
		// Go through the array, translating each of the items to their
		if ( isArray ) {
		for ( ; i < length; i++ ) {
		value = callback( elems[ i ], i, arg );
		if ( value != null ) {
		ret[ ret.length ] = value;
		}
		}
		// Go through every key on the object,
		} else {
		for ( key in elems ) {
		value = callback( elems[ key ], key, arg );
		if ( value != null ) {
		ret[ ret.length ] = value;
		}
		}
		}
		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
		},
		// A global GUID counter for objects
		guid: 1,
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
		var tmp, args, proxy;
		if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
		}
		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
		return undefined;
		}
		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
		return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
		};
		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
		return proxy;
		},
		// Multifunctional method to get and set values of a collection
		// The value/s can optionally be executed if it's a function
		access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
		bulk = key == null,
		i = 0,
		length = elems.length;
		// Sets many values
		if ( key && typeof key === "object" ) {
		for ( i in key ) {
		jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
		}
		chainable = 1;
		// Sets one value
		} else if ( value !== undefined ) {
		// Optionally, function values get executed if exec is true
		exec = pass === undefined && jQuery.isFunction( value );
		if ( bulk ) {
		// Bulk operations only iterate when executing function values
		if ( exec ) {
		exec = fn;
		fn = function( elem, key, value ) {
		return exec.call( jQuery( elem ), value );
		};
		// Otherwise they run against the entire set
		} else {
		fn.call( elems, value );
		fn = null;
		}
		}
		if ( fn ) {
		for (; i < length; i++ ) {
		fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
		}
		}
		chainable = 1;
		}
		return chainable ?
		elems :
		// Gets
		bulk ?
		fn.call( elems ) :
		length ? fn( elems[0], key ) : emptyGet;
		},
		now: function() {
		return ( new Date() ).getTime();
		}
		});
		jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
		readyList = jQuery.Deferred();
		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		setTimeout( jQuery.ready, 1 );
		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", jQuery.ready, false );
		// If IE event model is used
		} else {
		// Ensure firing before onload, maybe late but safe also for iframes
		document.attachEvent( "onreadystatechange", DOMContentLoaded );
		// A fallback to window.onload, that will always work
		window.attachEvent( "onload", jQuery.ready );
		// If IE and not a frame
		// continually check to see if the document is ready
		var top = false;
		try {
		top = window.frameElement == null && document.documentElement;
		} catch(e) {}
		if ( top && top.doScroll ) {
		(function doScrollCheck() {
		if ( !jQuery.isReady ) {
		try {
		// Use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		top.doScroll("left");
		} catch(e) {
		return setTimeout( doScrollCheck, 50 );
		}
		// and execute any waiting functions
		jQuery.ready();
		}
		})();
		}
		}
		}
		return readyList.promise( obj );
		};
		// Populate the class2type map
		jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
		});
		// All jQuery objects should point back to these
		rootjQuery = jQuery(document);
		// String to Object options format cache
		var optionsCache = {};
		// Convert String-formatted options into Object-formatted ones and store in cache
		function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
		});
		return object;
		}
		/*
		* Create a callback list using the following parameters:
		*
		*	options: an optional list of space-separated options that will change how
		*			the callback list behaves or a more traditional option object
		*
		* By default a callback list will act like an event callback list and can be
		* "fired" multiple times.
		*
		* Possible options:
		*
		*	once:			will ensure the callback list can only be fired once (like a Deferred)
		*
		*	memory:			will keep track of previous values and will call any callback added
		*					after the list has been fired right away with the latest "memorized"
		*					values (like a Deferred)
		*
		*	unique:			will ensure a callback can only be added once (no duplicate in the list)
		*
		*	stopOnFalse:	interrupt callings when a callback returns false
		*
		*/
		jQuery.Callbacks = function( options ) {
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );
		var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
		memory = options.memory && data;
		fired = true;
		firingIndex = firingStart || 0;
		firingStart = 0;
		firingLength = list.length;
		firing = true;
		for ( ; list && firingIndex < firingLength; firingIndex++ ) {
		if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
		memory = false; // To prevent further calls using add
		break;
		}
		}
		firing = false;
		if ( list ) {
		if ( stack ) {
		if ( stack.length ) {
		fire( stack.shift() );
		}
		} else if ( memory ) {
		list = [];
		} else {
		self.disable();
		}
		}
		},
		// Actual Callbacks object
		self = {
		// Add a callback or a collection of callbacks to the list
		add: function() {
		if ( list ) {
		// First, we save the current length
		var start = list.length;
		(function add( args ) {
		jQuery.each( args, function( _, arg ) {
		var type = jQuery.type( arg );
		if ( type === "function" ) {
		if ( !options.unique || !self.has( arg ) ) {
		list.push( arg );
		}
		} else if ( arg && arg.length && type !== "string" ) {
		// Inspect recursively
		add( arg );
		}
		});
		})( arguments );
		// Do we need to add the callbacks to the
		// current firing batch?
		if ( firing ) {
		firingLength = list.length;
		// With memory, if we're not firing then
		// we should call right away
		} else if ( memory ) {
		firingStart = start;
		fire( memory );
		}
		}
		return this;
		},
		// Remove a callback from the list
		remove: function() {
		if ( list ) {
		jQuery.each( arguments, function( _, arg ) {
		var index;
		while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
		list.splice( index, 1 );
		// Handle firing indexes
		if ( firing ) {
		if ( index <= firingLength ) {
		firingLength--;
		}
		if ( index <= firingIndex ) {
		firingIndex--;
		}
		}
		}
		});
		}
		return this;
		},
		// Control if a given callback is in the list
		has: function( fn ) {
		return jQuery.inArray( fn, list ) > -1;
		},
		// Remove all callbacks from the list
		empty: function() {
		list = [];
		return this;
		},
		// Have the list do nothing anymore
		disable: function() {
		list = stack = memory = undefined;
		return this;
		},
		// Is it disabled?
		disabled: function() {
		return !list;
		},
		// Lock the list in its current state
		lock: function() {
		stack = undefined;
		if ( !memory ) {
		self.disable();
		}
		return this;
		},
		// Is it locked?
		locked: function() {
		return !stack;
		},
		// Call all callbacks with the given context and arguments
		fireWith: function( context, args ) {
		args = args || [];
		args = [ context, args.slice ? args.slice() : args ];
		if ( list && ( !fired || stack ) ) {
		if ( firing ) {
		stack.push( args );
		} else {
		fire( args );
		}
		}
		return this;
		},
		// Call all the callbacks with the given arguments
		fire: function() {
		self.fireWith( this, arguments );
		return this;
		},
		// To know if the callbacks have already been called at least once
		fired: function() {
		return !!fired;
		}
		};
		return self;
		};
		jQuery.extend({
		Deferred: function( func ) {
		var tuples = [
		// action, add listener, listener list, final state
		[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
		[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
		[ "notify", "progress", jQuery.Callbacks("memory") ]
		],
		state = "pending",
		promise = {
		state: function() {
		return state;
		},
		always: function() {
		deferred.done( arguments ).fail( arguments );
		return this;
		},
		then: function( /* fnDone, fnFail, fnProgress */ ) {
		var fns = arguments;
		return jQuery.Deferred(function( newDefer ) {
		jQuery.each( tuples, function( i, tuple ) {
		var action = tuple[ 0 ],
		fn = fns[ i ];
		// deferred[ done | fail | progress ] for forwarding actions to newDefer
		deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
		function() {
		var returned = fn.apply( this, arguments );
		if ( returned && jQuery.isFunction( returned.promise ) ) {
		returned.promise()
		.done( newDefer.resolve )
		.fail( newDefer.reject )
		.progress( newDefer.notify );
		} else {
		newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
		}
		} :
		newDefer[ action ]
		);
		});
		fns = null;
		}).promise();
		},
		// Get a promise for this deferred
		// If obj is provided, the promise aspect is added to the object
		promise: function( obj ) {
		return obj != null ? jQuery.extend( obj, promise ) : promise;
		}
		},
		deferred = {};
		// Keep pipe for back-compat
		promise.pipe = promise.then;
		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
		var list = tuple[ 2 ],
		stateString = tuple[ 3 ];
		// promise[ done | fail | progress ] = list.add
		promise[ tuple[1] ] = list.add;
		// Handle state
		if ( stateString ) {
		list.add(function() {
		// state = [ resolved | rejected ]
		state = stateString;
		// [ reject_list | resolve_list ].disable; progress_list.lock
		}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
		}
		// deferred[ resolve | reject | notify ] = list.fire
		deferred[ tuple[0] ] = list.fire;
		deferred[ tuple[0] + "With" ] = list.fireWith;
		});
		// Make the deferred a promise
		promise.promise( deferred );
		// Call given func if any
		if ( func ) {
		func.call( deferred, deferred );
		}
		// All done!
		return deferred;
		},
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
		resolveValues = core_slice.call( arguments ),
		length = resolveValues.length,
		// the count of uncompleted subordinates
		remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
		// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
		deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
		// Update function for both resolve and progress values
		updateFunc = function( i, contexts, values ) {
		return function( value ) {
		contexts[ i ] = this;
		values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
		if( values === progressValues ) {
		deferred.notifyWith( contexts, values );
		} else if ( !( --remaining ) ) {
		deferred.resolveWith( contexts, values );
		}
		};
		},
		progressValues, progressContexts, resolveContexts;
		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
		progressValues = new Array( length );
		progressContexts = new Array( length );
		resolveContexts = new Array( length );
		for ( ; i < length; i++ ) {
		if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
		resolveValues[ i ].promise()
		.done( updateFunc( i, resolveContexts, resolveValues ) )
		.fail( deferred.reject )
		.progress( updateFunc( i, progressContexts, progressValues ) );
		} else {
		--remaining;
		}
		}
		}
		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
		deferred.resolveWith( resolveContexts, resolveValues );
		}
		return deferred.promise();
		}
		});
		jQuery.support = (function() {
		var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement("div");
		// Setup
		div.setAttribute( "className", "t" );
		div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
		// Support tests won't run in some limited or non-browser environments
		all = div.getElementsByTagName("*");
		a = div.getElementsByTagName("a")[ 0 ];
		if ( !all || !a || !all.length ) {
		return {};
		}
		// First batch of tests
		select = document.createElement("select");
		opt = select.appendChild( document.createElement("option") );
		input = div.getElementsByTagName("input")[ 0 ];
		a.style.cssText = "top:1px;float:left;opacity:.5";
		support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),
		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,
		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,
		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),
		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),
		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),
		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,
		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),
		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,
		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",
		// Tests for enctype support on a form (#6743)
		enctype: !!document.createElement("form").enctype,
		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: ( document.compatMode === "CSS1Compat" ),
		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
		};
		// Make sure checked status is properly cloned
		input.checked = true;
		support.noCloneChecked = input.cloneNode( true ).checked;
		// Make sure that the options inside disabled selects aren't marked as disabled
		// (WebKit marks them as disabled)
		select.disabled = true;
		support.optDisabled = !opt.disabled;
		// Test to see if it's possible to delete an expando from an element
		// Fails in Internet Explorer
		try {
		delete div.test;
		} catch( e ) {
		support.deleteExpando = false;
		}
		if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", clickFn = function() {
		// Cloning a node shouldn't copy over any
		// bound event handlers (IE does this)
		support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent("onclick");
		div.detachEvent( "onclick", clickFn );
		}
		// Check if a radio maintains its value
		// after being appended to the DOM
		input = document.createElement("input");
		input.value = "t";
		input.setAttribute( "type", "radio" );
		support.radioValue = input.value === "t";
		input.setAttribute( "checked", "checked" );
		// #11217 - WebKit loses check when the name is after the checked attribute
		input.setAttribute( "name", "t" );
		div.appendChild( input );
		fragment = document.createDocumentFragment();
		fragment.appendChild( div.lastChild );
		// WebKit doesn't clone checked state correctly in fragments
		support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
		// Check if a disconnected checkbox will retain its checked
		// value of true after appended to the DOM (IE6/7)
		support.appendChecked = input.checked;
		fragment.removeChild( input );
		fragment.appendChild( div );
		// Technique from Juriy Zaytsev
		// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
		// We only care about the case where non-standard event systems
		// are used, namely in IE. Short-circuiting here helps us to
		// avoid an eval call (in setAttribute) which can cause CSP
		// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
		if ( div.attachEvent ) {
		for ( i in {
		submit: true,
		change: true,
		focusin: true
		}) {
		eventName = "on" + i;
		isSupported = ( eventName in div );
		if ( !isSupported ) {
		div.setAttribute( eventName, "return;" );
		isSupported = ( typeof div[ eventName ] === "function" );
		}
		support[ i + "Bubbles" ] = isSupported;
		}
		}
		// Run tests that need a body at doc ready
		jQuery(function() {
		var container, div, tds, marginDiv,
		divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
		body = document.getElementsByTagName("body")[0];
		if ( !body ) {
		// Return for frameset docs that don't have a body
		return;
		}
		container = document.createElement("div");
		container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
		body.insertBefore( container, body.firstChild );
		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );
		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";
		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );
		// NOTE: To any future maintainer, we've window.getComputedStyle
		// because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
		support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
		support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
		// Check if div with explicit width and no margin-right incorrectly
		// gets computed margin-right based on width of container. For more
		// info see bug #3333
		// Fails in WebKit before Feb 2011 nightlies
		// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
		marginDiv = document.createElement("div");
		marginDiv.style.cssText = div.style.cssText = divReset;
		marginDiv.style.marginRight = marginDiv.style.width = "0";
		div.style.width = "1px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
		!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}
		if ( typeof div.style.zoom !== "undefined" ) {
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		// (IE < 8 does this)
		div.innerHTML = "";
		div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
		support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );
		// Check if elements with layout shrink-wrap their children
		// (IE 6 does this)
		div.style.display = "block";
		div.style.overflow = "visible";
		div.innerHTML = "<div></div>";
		div.firstChild.style.width = "5px";
		support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
		container.style.zoom = 1;
		}
		// Null elements to avoid leaks in IE
		body.removeChild( container );
		container = div = tds = marginDiv = null;
		});
		// Null elements to avoid leaks in IE
		fragment.removeChild( div );
		all = a = select = opt = input = fragment = div = null;
		return support;
		})();
		var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
		rmultiDash = /([A-Z])/g;
		jQuery.extend({
		cache: {},
		deletedIds: [],
		// Remove at next major release (1.9/2.0)
		uuid: 0,
		// Unique for each copy of jQuery on the page
		// Non-digits removed to match rinlinejQuery
		expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
		// The following elements throw uncatchable exceptions if you
		// attempt to add expando properties to them.
		noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
		},
		hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
		},
		data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
		return;
		}
		var thisCache, ret,
		internalKey = jQuery.expando,
		getByName = typeof name === "string",
		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,
		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,
		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;
		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
		return;
		}
		if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
		elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
		} else {
		id = internalKey;
		}
		}
		if ( !cache[ id ] ) {
		cache[ id ] = {};
		// Avoids exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		if ( !isNode ) {
		cache[ id ].toJSON = jQuery.noop;
		}
		}
		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
		cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
		cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
		}
		thisCache = cache[ id ];
		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
		if ( !thisCache.data ) {
		thisCache.data = {};
		}
		thisCache = thisCache.data;
		}
		if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
		}
		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {
		// First Try to find as-is property data
		ret = thisCache[ name ];
		// Test for null|undefined property data
		if ( ret == null ) {
		// Try to find the camelCased property
		ret = thisCache[ jQuery.camelCase( name ) ];
		}
		} else {
		ret = thisCache;
		}
		return ret;
		},
		removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
		return;
		}
		var thisCache, i, l,
		isNode = elem.nodeType,
		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
		return;
		}
		if ( name ) {
		thisCache = pvt ? cache[ id ] : cache[ id ].data;
		if ( thisCache ) {
		// Support array or space separated string names for data keys
		if ( !jQuery.isArray( name ) ) {
		// try the string as a key before any manipulation
		if ( name in thisCache ) {
		name = [ name ];
		} else {
		// split the camel cased version by spaces unless a key with the spaces exists
		name = jQuery.camelCase( name );
		if ( name in thisCache ) {
		name = [ name ];
		} else {
		name = name.split(" ");
		}
		}
		}
		for ( i = 0, l = name.length; i < l; i++ ) {
		delete thisCache[ name[i] ];
		}
		// If there is no data left in the cache, we want to continue
		// and let the cache object itself get destroyed
		if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
		return;
		}
		}
		}
		// See jQuery.data for more information
		if ( !pvt ) {
		delete cache[ id ].data;
		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
		return;
		}
		}
		// Destroy the cache
		if ( isNode ) {
		jQuery.cleanData( [ elem ], true );
		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
		delete cache[ id ];
		// When all else fails, null
		} else {
		cache[ id ] = null;
		}
		},
		// For internal use only.
		_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
		},
		// A method for determining if a DOM node can handle the data expando
		acceptData: function( elem ) {
		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];
		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
		}
		});
		jQuery.fn.extend({
		data: function( key, value ) {
		var parts, part, attr, name, l,
		elem = this[0],
		i = 0,
		data = null;
		// Gets all values
		if ( key === undefined ) {
		if ( this.length ) {
		data = jQuery.data( elem );
		if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
		attr = elem.attributes;
		for ( l = attr.length; i < l; i++ ) {
		name = attr[i].name;
		if ( !name.indexOf( "data-" ) ) {
		name = jQuery.camelCase( name.substring(5) );
		dataAttr( elem, name, data[ name ] );
		}
		}
		jQuery._data( elem, "parsedAttrs", true );
		}
		}
		return data;
		}
		// Sets multiple values
		if ( typeof key === "object" ) {
		return this.each(function() {
		jQuery.data( this, key );
		});
		}
		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";
		return jQuery.access( this, function( value ) {
		if ( value === undefined ) {
		data = this.triggerHandler( "getData" + part, [ parts[0] ] );
		// Try to fetch any internally stored data first
		if ( data === undefined && elem ) {
		data = jQuery.data( elem, key );
		data = dataAttr( elem, key, data );
		}
		return data === undefined && parts[1] ?
		this.data( parts[0] ) :
		data;
		}
		parts[1] = value;
		this.each(function() {
		var self = jQuery( this );
		self.triggerHandler( "setData" + part, parts );
		jQuery.data( this, key, value );
		self.triggerHandler( "changeData" + part, parts );
		});
		}, null, value, arguments.length > 1, null, false );
		},
		removeData: function( key ) {
		return this.each(function() {
		jQuery.removeData( this, key );
		});
		}
		});
		function dataAttr( elem, key, data ) {
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );
		if ( typeof data === "string" ) {
		try {
		data = data === "true" ? true :
		data === "false" ? false :
		data === "null" ? null :
		// Only convert to a number if it doesn't change the string
		+data + "" === data ? +data :
		rbrace.test( data ) ? jQuery.parseJSON( data ) :
		data;
		} catch( e ) {}
		// Make sure we set the data so it isn't changed later
		jQuery.data( elem, key, data );
		} else {
		data = undefined;
		}
		}
		return data;
		}
		// checks a cache object for emptiness
		function isEmptyDataObject( obj ) {
		var name;
		for ( name in obj ) {
		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
		continue;
		}
		if ( name !== "toJSON" ) {
		return false;
		}
		}
		return true;
		}
		jQuery.extend({
		queue: function( elem, type, data ) {
		var queue;
		if ( elem ) {
		type = ( type || "fx" ) + "queue";
		queue = jQuery._data( elem, type );
		// Speed up dequeue by getting out quickly if this is just a lookup
		if ( data ) {
		if ( !queue || jQuery.isArray(data) ) {
		queue = jQuery._data( elem, type, jQuery.makeArray(data) );
		} else {
		queue.push( data );
		}
		}
		return queue || [];
		}
		},
		dequeue: function( elem, type ) {
		type = type || "fx";
		var queue = jQuery.queue( elem, type ),
		startLength = queue.length,
		fn = queue.shift(),
		hooks = jQuery._queueHooks( elem, type ),
		next = function() {
		jQuery.dequeue( elem, type );
		};
		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
		fn = queue.shift();
		startLength--;
		}
		if ( fn ) {
		// Add a progress sentinel to prevent the fx queue from being
		// automatically dequeued
		if ( type === "fx" ) {
		queue.unshift( "inprogress" );
		}
		// clear up the last queue stop function
		delete hooks.stop;
		fn.call( elem, next, hooks );
		}
		if ( !startLength && hooks ) {
		hooks.empty.fire();
		}
		},
		// not intended for public consumption - generates a queueHooks object, or returns the current one
		_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
		empty: jQuery.Callbacks("once memory").add(function() {
		jQuery.removeData( elem, type + "queue", true );
		jQuery.removeData( elem, key, true );
		})
		});
		}
		});
		jQuery.fn.extend({
		queue: function( type, data ) {
		var setter = 2;
		if ( typeof type !== "string" ) {
		data = type;
		type = "fx";
		setter--;
		}
		if ( arguments.length < setter ) {
		return jQuery.queue( this[0], type );
		}
		return data === undefined ?
		this :
		this.each(function() {
		var queue = jQuery.queue( this, type, data );
		// ensure a hooks for this queue
		jQuery._queueHooks( this, type );
		if ( type === "fx" && queue[0] !== "inprogress" ) {
		jQuery.dequeue( this, type );
		}
		});
		},
		dequeue: function( type ) {
		return this.each(function() {
		jQuery.dequeue( this, type );
		});
		},
		// Based off of the plugin by Clint Helfers, with permission.
		// http://blindsignals.com/index.php/2009/07/jquery-delay/
		delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
		return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
		clearTimeout( timeout );
		};
		});
		},
		clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
		var tmp,
		count = 1,
		defer = jQuery.Deferred(),
		elements = this,
		i = this.length,
		resolve = function() {
		if ( !( --count ) ) {
		defer.resolveWith( elements, [ elements ] );
		}
		};
		if ( typeof type !== "string" ) {
		obj = type;
		type = undefined;
		}
		type = type || "fx";
		while( i-- ) {
		tmp = jQuery._data( elements[ i ], type + "queueHooks" );
		if ( tmp && tmp.empty ) {
		count++;
		tmp.empty.add( resolve );
		}
		}
		resolve();
		return defer.promise( obj );
		}
		});
		var nodeHook, boolHook, fixSpecified,
		rclass = /[\t\r\n]/g,
		rreturn = /\r/g,
		rtype = /^(?:button|input)$/i,
		rfocusable = /^(?:button|input|object|select|textarea)$/i,
		rclickable = /^a(?:rea|)$/i,
		rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
		getSetAttribute = jQuery.support.getSetAttribute;
		jQuery.fn.extend({
		attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
		removeAttr: function( name ) {
		return this.each(function() {
		jQuery.removeAttr( this, name );
		});
		},
		prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
		removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
		// try/catch handles cases where IE balks (such as removing a property on window)
		try {
		this[ name ] = undefined;
		delete this[ name ];
		} catch( e ) {}
		});
		},
		addClass: function( value ) {
		var classNames, i, l, elem,
		setClass, c, cl;
		if ( jQuery.isFunction( value ) ) {
		return this.each(function( j ) {
		jQuery( this ).addClass( value.call(this, j, this.className) );
		});
		}
		if ( value && typeof value === "string" ) {
		classNames = value.split( core_rspace );
		for ( i = 0, l = this.length; i < l; i++ ) {
		elem = this[ i ];
		if ( elem.nodeType === 1 ) {
		if ( !elem.className && classNames.length === 1 ) {
		elem.className = value;
		} else {
		setClass = " " + elem.className + " ";
		for ( c = 0, cl = classNames.length; c < cl; c++ ) {
		if ( setClass.indexOf( " " + classNames[ c ] + " " ) < 0 ) {
		setClass += classNames[ c ] + " ";
		}
		}
		elem.className = jQuery.trim( setClass );
		}
		}
		}
		}
		return this;
		},
		removeClass: function( value ) {
		var removes, className, elem, c, cl, i, l;
		if ( jQuery.isFunction( value ) ) {
		return this.each(function( j ) {
		jQuery( this ).removeClass( value.call(this, j, this.className) );
		});
		}
		if ( (value && typeof value === "string") || value === undefined ) {
		removes = ( value || "" ).split( core_rspace );
		for ( i = 0, l = this.length; i < l; i++ ) {
		elem = this[ i ];
		if ( elem.nodeType === 1 && elem.className ) {
		className = (" " + elem.className + " ").replace( rclass, " " );
		// loop over each item in the removal list
		for ( c = 0, cl = removes.length; c < cl; c++ ) {
		// Remove until there is nothing to remove,
		while ( className.indexOf(" " + removes[ c ] + " ") >= 0 ) {
		className = className.replace( " " + removes[ c ] + " " , " " );
		}
		}
		elem.className = value ? jQuery.trim( className ) : "";
		}
		}
		}
		return this;
		},
		toggleClass: function( value, stateVal ) {
		var type = typeof value,
		isBool = typeof stateVal === "boolean";
		if ( jQuery.isFunction( value ) ) {
		return this.each(function( i ) {
		jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
		});
		}
		return this.each(function() {
		if ( type === "string" ) {
		// toggle individual class names
		var className,
		i = 0,
		self = jQuery( this ),
		state = stateVal,
		classNames = value.split( core_rspace );
		while ( (className = classNames[ i++ ]) ) {
		// check each className given, space separated list
		state = isBool ? state : !self.hasClass( className );
		self[ state ? "addClass" : "removeClass" ]( className );
		}
		} else if ( type === "undefined" || type === "boolean" ) {
		if ( this.className ) {
		// store className if set
		jQuery._data( this, "__className__", this.className );
		}
		// toggle whole className
		this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
		}
		});
		},
		hasClass: function( selector ) {
		var className = " " + selector + " ",
		i = 0,
		l = this.length;
		for ( ; i < l; i++ ) {
		if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
		return true;
		}
		}
		return false;
		},
		val: function( value ) {
		var hooks, ret, isFunction,
		elem = this[0];
		if ( !arguments.length ) {
		if ( elem ) {
		hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
		return ret;
		}
		ret = elem.value;
		return typeof ret === "string" ?
		// handle most common string cases
		ret.replace(rreturn, "") :
		// handle cases where value is null/undef or number
		ret == null ? "" : ret;
		}
		return;
		}
		isFunction = jQuery.isFunction( value );
		return this.each(function( i ) {
		var val,
		self = jQuery(this);
		if ( this.nodeType !== 1 ) {
		return;
		}
		if ( isFunction ) {
		val = value.call( this, i, self.val() );
		} else {
		val = value;
		}
		// Treat null/undefined as ""; convert numbers to string
		if ( val == null ) {
		val = "";
		} else if ( typeof val === "number" ) {
		val += "";
		} else if ( jQuery.isArray( val ) ) {
		val = jQuery.map(val, function ( value ) {
		return value == null ? "" : value + "";
		});
		}
		hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
		// If set returns undefined, fall back to normal setting
		if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
		this.value = val;
		}
		});
		}
		});
		jQuery.extend({
		valHooks: {
		option: {
		get: function( elem ) {
		// attributes.value is undefined in Blackberry 4.7 but
		// uses .value. See #6932
		var val = elem.attributes.value;
		return !val || val.specified ? elem.value : elem.text;
		}
		},
		select: {
		get: function( elem ) {
		var value, option,
		options = elem.options,
		index = elem.selectedIndex,
		one = elem.type === "select-one" || index < 0,
		values = one ? null : [],
		max = one ? index + 1 : options.length,
		i = index < 0 ?
		max :
		one ? index : 0;
		// Loop through all the selected options
		for ( ; i < max; i++ ) {
		option = options[ i ];
		// oldIE doesn't update selected after form reset (#2551)
		if ( ( option.selected || i === index ) &&
		// Don't return options that are disabled or in a disabled optgroup
		( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
		( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
		// Get the specific value for the option
		value = jQuery( option ).val();
		// We don't need an array for one selects
		if ( one ) {
		return value;
		}
		// Multi-Selects return an array
		values.push( value );
		}
		}
		return values;
		},
		set: function( elem, value ) {
		var values = jQuery.makeArray( value );
		jQuery(elem).find("option").each(function() {
		this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
		});
		if ( !values.length ) {
		elem.selectedIndex = -1;
		}
		return values;
		}
		}
		},
		// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
		attrFn: {},
		attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
		nType = elem.nodeType;
		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
		return;
		}
		if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
		return jQuery( elem )[ name ]( value );
		}
		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
		return jQuery.prop( elem, name, value );
		}
		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
		name = name.toLowerCase();
		hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}
		if ( value !== undefined ) {
		if ( value === null ) {
		jQuery.removeAttr( elem, name );
		return;
		} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
		return ret;
		} else {
		elem.setAttribute( name, value + "" );
		return value;
		}
		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
		return ret;
		} else {
		ret = elem.getAttribute( name );
		// Non-existent attributes return null, we normalize to undefined
		return ret === null ?
		undefined :
		ret;
		}
		},
		removeAttr: function( elem, value ) {
		var propName, attrNames, name, isBool,
		i = 0;
		if ( value && elem.nodeType === 1 ) {
		attrNames = value.split( core_rspace );
		for ( ; i < attrNames.length; i++ ) {
		name = attrNames[ i ];
		if ( name ) {
		propName = jQuery.propFix[ name ] || name;
		isBool = rboolean.test( name );
		// See #9699 for explanation of this approach (setting first, then removal)
		// Do not do this for boolean attributes (see #10870)
		if ( !isBool ) {
		jQuery.attr( elem, name, "" );
		}
		elem.removeAttribute( getSetAttribute ? name : propName );
		// Set corresponding property to false for boolean attributes
		if ( isBool && propName in elem ) {
		elem[ propName ] = false;
		}
		}
		}
		}
		},
		attrHooks: {
		type: {
		set: function( elem, value ) {
		// We can't allow the type property to be changed (since it causes problems in IE)
		if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
		jQuery.error( "type property can't be changed" );
		} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
		// Setting the type on a radio button after the value resets the value in IE6-9
		// Reset value to it's default in case type is set after value
		// This is for element creation
		var val = elem.value;
		elem.setAttribute( "type", value );
		if ( val ) {
		elem.value = val;
		}
		return value;
		}
		}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
		get: function( elem, name ) {
		if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
		return nodeHook.get( elem, name );
		}
		return name in elem ?
		elem.value :
		null;
		},
		set: function( elem, value, name ) {
		if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
		return nodeHook.set( elem, value, name );
		}
		// Does not return so that setAttribute is also used
		elem.value = value;
		}
		}
		},
		propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
		},
		prop: function( elem, name, value ) {
		var ret, hooks, notxml,
		nType = elem.nodeType;
		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
		return;
		}
		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
		if ( notxml ) {
		// Fix name and attach hooks
		name = jQuery.propFix[ name ] || name;
		hooks = jQuery.propHooks[ name ];
		}
		if ( value !== undefined ) {
		if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
		return ret;
		} else {
		return ( elem[ name ] = value );
		}
		} else {
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
		return ret;
		} else {
		return elem[ name ];
		}
		}
		},
		propHooks: {
		tabIndex: {
		get: function( elem ) {
		// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
		// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
		var attributeNode = elem.getAttributeNode("tabindex");
		return attributeNode && attributeNode.specified ?
		parseInt( attributeNode.value, 10 ) :
		rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
		0 :
		undefined;
		}
		}
		}
		});
		// Hook for boolean attributes
		boolHook = {
		get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
		property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
		name.toLowerCase() :
		undefined;
		},
		set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
		// Remove boolean attributes when set to false
		jQuery.removeAttr( elem, name );
		} else {
		// value is true since we know at this point it's type boolean and not false
		// Set boolean attributes to the same name and set the DOM property
		propName = jQuery.propFix[ name ] || name;
		if ( propName in elem ) {
		// Only set the IDL specifically if it already exists on the element
		elem[ propName ] = true;
		}
		elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
		}
		};
		// IE6/7 do not support getting/setting some attributes with get/setAttribute
		if ( !getSetAttribute ) {
		fixSpecified = {
		name: true,
		id: true,
		coords: true
		};
		// Use this for any attribute in IE6/7
		// This fixes almost every IE6/7 issue
		nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
		var ret;
		ret = elem.getAttributeNode( name );
		return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
		ret.value :
		undefined;
		},
		set: function( elem, value, name ) {
		// Set the existing or create a new attribute node
		var ret = elem.getAttributeNode( name );
		if ( !ret ) {
		ret = document.createAttribute( name );
		elem.setAttributeNode( ret );
		}
		return ( ret.value = value + "" );
		}
		};
		// Set width and height to auto instead of 0 on empty string( Bug #8150 )
		// This is for removals
		jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
		set: function( elem, value ) {
		if ( value === "" ) {
		elem.setAttribute( name, "auto" );
		return value;
		}
		}
		});
		});
		// Set contenteditable to false on removals(#10429)
		// Setting to empty string throws an error as an invalid value
		jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
		if ( value === "" ) {
		value = "false";
		}
		nodeHook.set( elem, value, name );
		}
		};
		}
		// Some attributes require a special call on IE
		if ( !jQuery.support.hrefNormalized ) {
		jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
		get: function( elem ) {
		var ret = elem.getAttribute( name, 2 );
		return ret === null ? undefined : ret;
		}
		});
		});
		}
		if ( !jQuery.support.style ) {
		jQuery.attrHooks.style = {
		get: function( elem ) {
		// Return undefined in the case of empty string
		// Normalize to lowercase since IE uppercases css property names
		return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
		return ( elem.style.cssText = value + "" );
		}
		};
		}
		// Safari mis-reports the default selected property of an option
		// Accessing the parent's selectedIndex property fixes it
		if ( !jQuery.support.optSelected ) {
		jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
		var parent = elem.parentNode;
		if ( parent ) {
		parent.selectedIndex;
		// Make sure that it also works with optgroups, see #5701
		if ( parent.parentNode ) {
		parent.parentNode.selectedIndex;
		}
		}
		return null;
		}
		});
		}
		// IE6/7 call enctype encoding
		if ( !jQuery.support.enctype ) {
		jQuery.propFix.enctype = "encoding";
		}
		// Radios and checkboxes getter/setter
		if ( !jQuery.support.checkOn ) {
		jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
		get: function( elem ) {
		// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
		return elem.getAttribute("value") === null ? "on" : elem.value;
		}
		};
		});
		}
		jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
		if ( jQuery.isArray( value ) ) {
		return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
		}
		}
		});
		});
		var rformElems = /^(?:textarea|input|select)$/i,
		rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
		rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
		};
		/*
		* Helper functions for managing events -- not part of the public interface.
		* Props to Dean Edwards' addEvent library for many of the ideas.
		*/
		jQuery.event = {
		add: function( elem, types, handler, data, selector ) {
		var elemData, eventHandle, events,
		t, tns, type, namespaces, handleObj,
		handleObjIn, handlers, special;
		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
		return;
		}
		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
		handleObjIn = handler;
		handler = handleObjIn.handler;
		selector = handleObjIn.selector;
		}
		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
		handler.guid = jQuery.guid++;
		}
		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
		elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
		elemData.handle = eventHandle = function( e ) {
		// Discard the second event of a jQuery.event.trigger() and
		// when an event is called after a page has unloaded
		return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
		jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
		undefined;
		};
		// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
		eventHandle.elem = elem;
		}
		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {
		tns = rtypenamespace.exec( types[t] ) || [];
		type = tns[1];
		namespaces = ( tns[2] || "" ).split( "." ).sort();
		// If event changes its type, use the special event handlers for the changed type
		special = jQuery.event.special[ type ] || {};
		// If selector defined, determine special event api type, otherwise given type
		type = ( selector ? special.delegateType : special.bindType ) || type;
		// Update special based on newly reset type
		special = jQuery.event.special[ type ] || {};
		// handleObj is passed to all event handlers
		handleObj = jQuery.extend({
		type: type,
		origType: tns[1],
		data: data,
		handler: handler,
		guid: handler.guid,
		selector: selector,
		needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
		namespace: namespaces.join(".")
		}, handleObjIn );
		// Init the event handler queue if we're the first
		handlers = events[ type ];
		if ( !handlers ) {
		handlers = events[ type ] = [];
		handlers.delegateCount = 0;
		// Only use addEventListener/attachEvent if the special events handler returns false
		if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
		// Bind the global event handler to the element
		if ( elem.addEventListener ) {
		elem.addEventListener( type, eventHandle, false );
		} else if ( elem.attachEvent ) {
		elem.attachEvent( "on" + type, eventHandle );
		}
		}
		}
		if ( special.add ) {
		special.add.call( elem, handleObj );
		if ( !handleObj.handler.guid ) {
		handleObj.handler.guid = handler.guid;
		}
		}
		// Add to the element's handler list, delegates in front
		if ( selector ) {
		handlers.splice( handlers.delegateCount++, 0, handleObj );
		} else {
		handlers.push( handleObj );
		}
		// Keep track of which events have ever been used, for event optimization
		jQuery.event.global[ type ] = true;
		}
		// Nullify elem to prevent memory leaks in IE
		elem = null;
		},
		global: {},
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
		var t, tns, type, origType, namespaces, origCount,
		j, events, special, eventType, handleObj,
		elemData = jQuery.hasData( elem ) && jQuery._data( elem );
		if ( !elemData || !(events = elemData.events) ) {
		return;
		}
		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
		tns = rtypenamespace.exec( types[t] ) || [];
		type = origType = tns[1];
		namespaces = tns[2];
		// Unbind all events (on this namespace, if provided) for the element
		if ( !type ) {
		for ( type in events ) {
		jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
		}
		continue;
		}
		special = jQuery.event.special[ type ] || {};
		type = ( selector? special.delegateType : special.bindType ) || type;
		eventType = events[ type ] || [];
		origCount = eventType.length;
		namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
		// Remove matching events
		for ( j = 0; j < eventType.length; j++ ) {
		handleObj = eventType[ j ];
		if ( ( mappedTypes || origType === handleObj.origType ) &&
		( !handler || handler.guid === handleObj.guid ) &&
		( !namespaces || namespaces.test( handleObj.namespace ) ) &&
		( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
		eventType.splice( j--, 1 );
		if ( handleObj.selector ) {
		eventType.delegateCount--;
		}
		if ( special.remove ) {
		special.remove.call( elem, handleObj );
		}
		}
		}
		// Remove generic event handler if we removed something and no more handlers exist
		// (avoids potential for endless recursion during removal of special event handlers)
		if ( eventType.length === 0 && origCount !== eventType.length ) {
		if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
		jQuery.removeEvent( elem, type, elemData.handle );
		}
		delete events[ type ];
		}
		}
		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
		delete elemData.handle;
		// removeData also checks for emptiness and clears the expando if empty
		// so use it instead of delete
		jQuery.removeData( elem, "events", true );
		}
		},
		// Events that are safe to short-circuit if no handlers are attached.
		// Native DOM events should not be added, they may have inline handlers.
		customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
		},
		trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
		return;
		}
		// Event object or event type
		var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
		type = event.type || event,
		namespaces = [];
		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
		return;
		}
		if ( type.indexOf( "!" ) >= 0 ) {
		// Exclusive events trigger only for the exact event (no namespaces)
		type = type.slice(0, -1);
		exclusive = true;
		}
		if ( type.indexOf( "." ) >= 0 ) {
		// Namespaced trigger; create a regexp to match event type in handle()
		namespaces = type.split(".");
		type = namespaces.shift();
		namespaces.sort();
		}
		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
		// No jQuery handlers for this event type, and it can't have inline handlers
		return;
		}
		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
		// jQuery.Event object
		event[ jQuery.expando ] ? event :
		// Object literal
		new jQuery.Event( type, event ) :
		// Just the event type (string)
		new jQuery.Event( type );
		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";
		// Handle a global trigger
		if ( !elem ) {
		// TODO: Stop taunting the data cache; remove global events and always attach to document
		cache = jQuery.cache;
		for ( i in cache ) {
		if ( cache[ i ].events && cache[ i ].events[ type ] ) {
		jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
		}
		}
		return;
		}
		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
		event.target = elem;
		}
		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );
		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
		return;
		}
		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
		bubbleType = special.delegateType || type;
		cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
		for ( old = elem; cur; cur = cur.parentNode ) {
		eventPath.push([ cur, bubbleType ]);
		old = cur;
		}
		// Only add window if we got to document (e.g., not plain obj or detached DOM)
		if ( old === (elem.ownerDocument || document) ) {
		eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
		}
		}
		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {
		cur = eventPath[i][0];
		event.type = eventPath[i][1];
		handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
		if ( handle ) {
		handle.apply( cur, data );
		}
		// Note that this is a bare JS function and not a jQuery handler
		handle = ontype && cur[ ontype ];
		if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
		event.preventDefault();
		}
		}
		event.type = type;
		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
		if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
		!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
		// Call a native DOM method on the target with the same name name as the event.
		// Can't use an .isFunction() check here because IE6/7 fails that test.
		// Don't do default actions on window, that's where global variables be (#6170)
		// IE<9 dies on focus/blur to hidden element (#1486)
		if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {
		// Don't re-trigger an onFOO event when we call its FOO() method
		old = elem[ ontype ];
		if ( old ) {
		elem[ ontype ] = null;
		}
		// Prevent re-triggering of the same event, since we already bubbled it above
		jQuery.event.triggered = type;
		elem[ type ]();
		jQuery.event.triggered = undefined;
		if ( old ) {
		elem[ ontype ] = old;
		}
		}
		}
		}
		return event.result;
		},
		dispatch: function( event ) {
		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );
		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
		handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
		delegateCount = handlers.delegateCount,
		args = core_slice.call( arguments ),
		run_all = !event.exclusive && !event.namespace,
		special = jQuery.event.special[ event.type ] || {},
		handlerQueue = [];
		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;
		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
		return;
		}
		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {
		for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
		// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
		if ( cur.disabled !== true || event.type !== "click" ) {
		selMatch = {};
		matches = [];
		for ( i = 0; i < delegateCount; i++ ) {
		handleObj = handlers[ i ];
		sel = handleObj.selector;
		if ( selMatch[ sel ] === undefined ) {
		selMatch[ sel ] = handleObj.needsContext ?
		jQuery( sel, this ).index( cur ) >= 0 :
		jQuery.find( sel, this, null, [ cur ] ).length;
		}
		if ( selMatch[ sel ] ) {
		matches.push( handleObj );
		}
		}
		if ( matches.length ) {
		handlerQueue.push({ elem: cur, matches: matches });
		}
		}
		}
		}
		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
		handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}
		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
		matched = handlerQueue[ i ];
		event.currentTarget = matched.elem;
		for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
		handleObj = matched.matches[ j ];
		// Triggered event must either 1) be non-exclusive and have no namespace, or
		// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
		if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {
		event.data = handleObj.data;
		event.handleObj = handleObj;
		ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
		.apply( matched.elem, args );
		if ( ret !== undefined ) {
		event.result = ret;
		if ( ret === false ) {
		event.preventDefault();
		event.stopPropagation();
		}
		}
		}
		}
		}
		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
		special.postDispatch.call( this, event );
		}
		return event.result;
		},
		// Includes some event props shared by KeyEvent and MouseEvent
		// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
		props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
		fixHooks: {},
		keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {
		// Add which for key events
		if ( event.which == null ) {
		event.which = original.charCode != null ? original.charCode : original.keyCode;
		}
		return event;
		}
		},
		mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
		var eventDoc, doc, body,
		button = original.button,
		fromElement = original.fromElement;
		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && original.clientX != null ) {
		eventDoc = event.target.ownerDocument || document;
		doc = eventDoc.documentElement;
		body = eventDoc.body;
		event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
		event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
		}
		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && fromElement ) {
		event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
		}
		// Add which for click: 1 === left; 2 === middle; 3 === right
		// Note: button is not normalized, so don't use it
		if ( !event.which && button !== undefined ) {
		event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
		}
		return event;
		}
		},
		fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
		return event;
		}
		// Create a writable copy of the event object and normalize some properties
		var i, prop,
		originalEvent = event,
		fixHook = jQuery.event.fixHooks[ event.type ] || {},
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
		event = jQuery.Event( originalEvent );
		for ( i = copy.length; i; ) {
		prop = copy[ --i ];
		event[ prop ] = originalEvent[ prop ];
		}
		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
		event.target = originalEvent.srcElement || document;
		}
		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
		event.target = event.target.parentNode;
		}
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
		event.metaKey = !!event.metaKey;
		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
		},
		special: {
		load: {
		// Prevent triggered image.load events from bubbling to window.load
		noBubble: true
		},
		focus: {
		delegateType: "focusin"
		},
		blur: {
		delegateType: "focusout"
		},
		beforeunload: {
		setup: function( data, namespaces, eventHandle ) {
		// We only want to do this special case on windows
		if ( jQuery.isWindow( this ) ) {
		this.onbeforeunload = eventHandle;
		}
		},
		teardown: function( namespaces, eventHandle ) {
		if ( this.onbeforeunload === eventHandle ) {
		this.onbeforeunload = null;
		}
		}
		}
		},
		simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
		new jQuery.Event(),
		event,
		{ type: type,
		isSimulated: true,
		originalEvent: {}
		}
		);
		if ( bubble ) {
		jQuery.event.trigger( e, null, elem );
		} else {
		jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
		event.preventDefault();
		}
		}
		};
		// Some plugins are using, but it's undocumented/deprecated and will be removed.
		// The 1.7 special event interface should provide all the hooks needed now.
		jQuery.event.handle = jQuery.event.dispatch;
		jQuery.removeEvent = document.removeEventListener ?
		function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
		}
		} :
		function( elem, type, handle ) {
		var name = "on" + type;
		if ( elem.detachEvent ) {
		// #8545, #7054, preventing memory leaks for custom events in IE6-8
		// detachEvent needed property on element, by name of that event, to properly expose it to GC
		if ( typeof elem[ name ] === "undefined" ) {
		elem[ name ] = null;
		}
		elem.detachEvent( name, handle );
		}
		};
		jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
		}
		// Event object
		if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;
		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
		src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;
		// Event type
		} else {
		this.type = src;
		}
		// Put explicitly provided properties onto the event object
		if ( props ) {
		jQuery.extend( this, props );
		}
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
		// Mark it as fixed
		this[ jQuery.expando ] = true;
		};
		function returnFalse() {
		return false;
		}
		function returnTrue() {
		return true;
		}
		// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
		// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
		jQuery.Event.prototype = {
		preventDefault: function() {
		this.isDefaultPrevented = returnTrue;
		var e = this.originalEvent;
		if ( !e ) {
		return;
		}
		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
		e.preventDefault();
		// otherwise set the returnValue property of the original event to false (IE)
		} else {
		e.returnValue = false;
		}
		},
		stopPropagation: function() {
		this.isPropagationStopped = returnTrue;
		var e = this.originalEvent;
		if ( !e ) {
		return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
		e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
		},
		stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
		},
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse
		};
		// Create mouseenter/leave events using mouseover/out and event-time checks
		jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout"
		}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,
		handle: function( event ) {
		var ret,
		target = this,
		related = event.relatedTarget,
		handleObj = event.handleObj,
		selector = handleObj.selector;
		// For mousenter/leave call the handler if related is outside the target.
		// NB: No relatedTarget if the mouse left/entered the browser window
		if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
		event.type = handleObj.origType;
		ret = handleObj.handler.apply( this, arguments );
		event.type = fix;
		}
		return ret;
		}
		};
		});
		// IE submit delegation
		if ( !jQuery.support.submitBubbles ) {
		jQuery.event.special.submit = {
		setup: function() {
		// Only need this for delegated form submit events
		if ( jQuery.nodeName( this, "form" ) ) {
		return false;
		}
		// Lazy-add a submit handler when a descendant form may potentially be submitted
		jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
		// Node name check avoids a VML-related crash in IE (#9807)
		var elem = e.target,
		form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
		if ( form && !jQuery._data( form, "_submit_attached" ) ) {
		jQuery.event.add( form, "submit._submit", function( event ) {
		event._submit_bubble = true;
		});
		jQuery._data( form, "_submit_attached", true );
		}
		});
		// return undefined since we don't need an event listener
		},
		postDispatch: function( event ) {
		// If form was submitted by the user, bubble the event up the tree
		if ( event._submit_bubble ) {
		delete event._submit_bubble;
		if ( this.parentNode && !event.isTrigger ) {
		jQuery.event.simulate( "submit", this.parentNode, event, true );
		}
		}
		},
		teardown: function() {
		// Only need this for delegated form submit events
		if ( jQuery.nodeName( this, "form" ) ) {
		return false;
		}
		// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
		jQuery.event.remove( this, "._submit" );
		}
		};
		}
		// IE change delegation and checkbox/radio fix
		if ( !jQuery.support.changeBubbles ) {
		jQuery.event.special.change = {
		setup: function() {
		if ( rformElems.test( this.nodeName ) ) {
		// IE doesn't fire change on a check/radio until blur; trigger it on click
		// after a propertychange. Eat the blur-change in special.change.handle.
		// This still fires onchange a second time for check/radio after blur.
		if ( this.type === "checkbox" || this.type === "radio" ) {
		jQuery.event.add( this, "propertychange._change", function( event ) {
		if ( event.originalEvent.propertyName === "checked" ) {
		this._just_changed = true;
		}
		});
		jQuery.event.add( this, "click._change", function( event ) {
		if ( this._just_changed && !event.isTrigger ) {
		this._just_changed = false;
		}
		// Allow triggered, simulated change events (#11500)
		jQuery.event.simulate( "change", this, event, true );
		});
		}
		return false;
		}
		// Delegated event; lazy-add a change handler on descendant inputs
		jQuery.event.add( this, "beforeactivate._change", function( e ) {
		var elem = e.target;
		if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
		jQuery.event.add( elem, "change._change", function( event ) {
		if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
		jQuery.event.simulate( "change", this.parentNode, event, true );
		}
		});
		jQuery._data( elem, "_change_attached", true );
		}
		});
		},
		handle: function( event ) {
		var elem = event.target;
		// Swallow native change events from checkbox/radio, we already triggered them above
		if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
		return event.handleObj.handler.apply( this, arguments );
		}
		},
		teardown: function() {
		jQuery.event.remove( this, "._change" );
		return !rformElems.test( this.nodeName );
		}
		};
		}
		// Create "bubbling" focus and blur events
		if ( !jQuery.support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
		handler = function( event ) {
		jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
		};
		jQuery.event.special[ fix ] = {
		setup: function() {
		if ( attaches++ === 0 ) {
		document.addEventListener( orig, handler, true );
		}
		},
		teardown: function() {
		if ( --attaches === 0 ) {
		document.removeEventListener( orig, handler, true );
		}
		}
		};
		});
		}
		jQuery.fn.extend({
		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) { // && selector != null
		// ( types-Object, data )
		data = data || selector;
		selector = undefined;
		}
		for ( type in types ) {
		this.on( type, selector, data, types[ type ], one );
		}
		return this;
		}
		if ( data == null && fn == null ) {
		// ( types, fn )
		fn = selector;
		data = selector = undefined;
		} else if ( fn == null ) {
		if ( typeof selector === "string" ) {
		// ( types, selector, fn )
		fn = data;
		data = undefined;
		} else {
		// ( types, data, fn )
		fn = data;
		data = selector;
		selector = undefined;
		}
		}
		if ( fn === false ) {
		fn = returnFalse;
		} else if ( !fn ) {
		return this;
		}
		if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {
		// Can use an empty set, since event contains the info
		jQuery().off( event );
		return origFn.apply( this, arguments );
		};
		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
		});
		},
		one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
		// ( event )  dispatched jQuery.Event
		handleObj = types.handleObj;
		jQuery( types.delegateTarget ).off(
		handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
		handleObj.selector,
		handleObj.handler
		);
		return this;
		}
		if ( typeof types === "object" ) {
		// ( types-object [, selector] )
		for ( type in types ) {
		this.off( type, selector, types[ type ] );
		}
		return this;
		}
		if ( selector === false || typeof selector === "function" ) {
		// ( types [, fn] )
		fn = selector;
		selector = undefined;
		}
		if ( fn === false ) {
		fn = returnFalse;
		}
		return this.each(function() {
		jQuery.event.remove( this, types, fn, selector );
		});
		},
		bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
		return this.off( types, null, fn );
		},
		live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
		},
		die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
		},
		delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		},
		trigger: function( type, data ) {
		return this.each(function() {
		jQuery.event.trigger( type, data, this );
		});
		},
		triggerHandler: function( type, data ) {
		if ( this[0] ) {
		return jQuery.event.trigger( type, data, this[0], true );
		}
		},
		toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
		guid = fn.guid || jQuery.guid++,
		i = 0,
		toggler = function( event ) {
		// Figure out which function to execute
		var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
		jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
		// Make sure that clicks stop
		event.preventDefault();
		// and execute the function
		return args[ lastToggle ].apply( this, arguments ) || false;
		};
		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
		args[ i++ ].guid = guid;
		}
		return this.click( toggler );
		},
		hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
		});
		jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
		fn = data;
		data = null;
		}
		return arguments.length > 0 ?
		this.on( name, null, data, fn ) :
		this.trigger( name );
		};
		if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
		}
		if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
		}
		});
		/*!
		* Sizzle CSS Selector Engine
		* Copyright 2012 jQuery Foundation and other contributors
		* Released under the MIT license
		* http://sizzlejs.com/
		*/
		(function( window, undefined ) {
		var cachedruns,
		assertGetIdNotName,
		Expr,
		getText,
		isXML,
		contains,
		compile,
		sortOrder,
		hasDuplicate,
		outermostContext,
		baseHasDuplicate = true,
		strundefined = "undefined",
		expando = ( "sizcache" + Math.random() ).replace( ".", "" ),
		Token = String,
		document = window.document,
		docElem = document.documentElement,
		dirruns = 0,
		done = 0,
		pop = [].pop,
		push = [].push,
		slice = [].slice,
		// Use a stripped-down indexOf if a native one is unavailable
		indexOf = [].indexOf || function( elem ) {
		var i = 0,
		len = this.length;
		for ( ; i < len; i++ ) {
		if ( this[i] === elem ) {
		return i;
		}
		}
		return -1;
		},
		// Augment a function for special use by Sizzle
		markFunction = function( fn, value ) {
		fn[ expando ] = value == null || value;
		return fn;
		},
		createCache = function() {
		var cache = {},
		keys = [];
		return markFunction(function( key, value ) {
		// Only keep the most recent entries
		if ( keys.push( key ) > Expr.cacheLength ) {
		delete cache[ keys.shift() ];
		}
		// Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
		return (cache[ key + " " ] = value);
		}, cache );
		},
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		// Regex
		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",
		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),
		// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
		operators = "([*^$|!~]?=)",
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
		// Prefer arguments not in parens/brackets,
		//   then attribute selectors and non-pseudos (denoted by :),
		//   then anything else
		// These preferences are here to reduce the number of selectors
		//   needing tokenize in the PSEUDO preFilter
		pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",
		// For matchExpr.POS and matchExpr.needsContext
		pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
		"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
		rpseudo = new RegExp( pseudos ),
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,
		rnot = /^:not/,
		rsibling = /[\x20\t\r\n\f]*[+~]/,
		rendsWithNot = /:not\($/,
		rheader = /h\d/i,
		rinputs = /input|select|textarea|button/i,
		rbackslash = /\\(?!\\)/g,
		matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"POS": new RegExp( pos, "i" ),
		"CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
		"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
		"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		// For use in libraries implementing .is()
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
		},
		// Support
		// Used for testing something on an element
		assert = function( fn ) {
		var div = document.createElement("div");
		try {
		return fn( div );
		} catch (e) {
		return false;
		} finally {
		// release memory in IE
		div = null;
		}
		},
		// Check if getElementsByTagName("*") returns only elements
		assertTagNameNoComments = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
		}),
		// Check if getAttribute returns normalized href attributes
		assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
		div.firstChild.getAttribute("href") === "#";
		}),
		// Check if attributes should be retrieved by attribute nodes
		assertAttributes = assert(function( div ) {
	div.innerHTML = "<select></select>";
	var type = typeof div.lastChild.getAttribute("multiple");
	// IE8 returns a string for some attributes even when not present
	return type !== "boolean" && type !== "string";
	}),
	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
	// Opera can't find a second classname (in 9.6)
	div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
	if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
	return false;
	}
	// Safari 3.2 caches class attributes and doesn't catch changes
	div.lastChild.className = "e";
	return div.getElementsByClassName("e").length === 2;
	}),
	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
	// Inject content
	div.id = expando + 0;
	div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
	docElem.insertBefore( div, docElem.firstChild );
	// Test
	var pass = document.getElementsByName &&
	// buggy browsers will return fewer than the correct 2
	document.getElementsByName( expando ).length === 2 +
	// buggy browsers will return more than the correct 0
	document.getElementsByName( expando + 0 ).length;
	assertGetIdNotName = !document.getElementById( expando );
	// Cleanup
	docElem.removeChild( div );
	return pass;
	});
	// If slice is not available, provide a backup
	try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
	} catch ( e ) {
	slice = function( i ) {
	var elem,
	results = [];
	for ( ; (elem = this[i]); i++ ) {
	results.push( elem );
	}
	return results;
	};
	}
	function Sizzle( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var match, elem, xml, m,
	nodeType = context.nodeType;
	if ( !selector || typeof selector !== "string" ) {
	return results;
	}
	if ( nodeType !== 1 && nodeType !== 9 ) {
	return [];
	}
	xml = isXML( context );
	if ( !xml && !seed ) {
	if ( (match = rquickExpr.exec( selector )) ) {
	// Speed-up: Sizzle("#ID")
	if ( (m = match[1]) ) {
	if ( nodeType === 9 ) {
	elem = context.getElementById( m );
	// Check parentNode to catch when Blackberry 4.6 returns
	// nodes that are no longer in the document #6963
	if ( elem && elem.parentNode ) {
	// Handle the case where IE, Opera, and Webkit return items
	// by name instead of ID
	if ( elem.id === m ) {
	results.push( elem );
	return results;
	}
	} else {
	return results;
	}
	} else {
	// Context is not a document
	if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
	contains( context, elem ) && elem.id === m ) {
	results.push( elem );
	return results;
	}
	}
	// Speed-up: Sizzle("TAG")
	} else if ( match[2] ) {
	push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
	return results;
	// Speed-up: Sizzle(".CLASS")
	} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
	push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
	return results;
	}
	}
	}
	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed, xml );
	}
	Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
	};
	Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
	};
	// Returns a function to use in pseudos for input types
	function createInputPseudo( type ) {
	return function( elem ) {
	var name = elem.nodeName.toLowerCase();
	return name === "input" && elem.type === type;
	};
	}
	// Returns a function to use in pseudos for buttons
	function createButtonPseudo( type ) {
	return function( elem ) {
	var name = elem.nodeName.toLowerCase();
	return (name === "input" || name === "button") && elem.type === type;
	};
	}
	// Returns a function to use in pseudos for positionals
	function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
	argument = +argument;
	return markFunction(function( seed, matches ) {
	var j,
	matchIndexes = fn( [], seed.length, argument ),
	i = matchIndexes.length;
	// Match elements found at the specified indexes
	while ( i-- ) {
	if ( seed[ (j = matchIndexes[i]) ] ) {
	seed[j] = !(matches[j] = seed[j]);
	}
	}
	});
	});
	}
	/**
	* Utility function for retrieving the text value of an array of DOM nodes
	* @param {Array|Element} elem
	*/
	getText = Sizzle.getText = function( elem ) {
	var node,
	ret = "",
	i = 0,
	nodeType = elem.nodeType;
	if ( nodeType ) {
	if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
	// Use textContent for elements
	// innerText usage removed for consistency of new lines (see #11153)
	if ( typeof elem.textContent === "string" ) {
	return elem.textContent;
	} else {
	// Traverse its children
	for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
	ret += getText( elem );
	}
	}
	} else if ( nodeType === 3 || nodeType === 4 ) {
	return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes
	} else {
	// If no nodeType, this is expected to be an array
	for ( ; (node = elem[i]); i++ ) {
	// Do not traverse comment nodes
	ret += getText( node );
	}
	}
	return ret;
	};
	isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	// Element contains another
	contains = Sizzle.contains = docElem.contains ?
	function( a, b ) {
	var adown = a.nodeType === 9 ? a.documentElement : a,
	bup = b && b.parentNode;
	return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
	} :
	docElem.compareDocumentPosition ?
	function( a, b ) {
	return b && !!( a.compareDocumentPosition( b ) & 16 );
	} :
	function( a, b ) {
	while ( (b = b.parentNode) ) {
	if ( b === a ) {
	return true;
	}
	}
	return false;
	};
	Sizzle.attr = function( elem, name ) {
	var val,
	xml = isXML( elem );
	if ( !xml ) {
	name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
	return val( elem );
	}
	if ( xml || assertAttributes ) {
	return elem.getAttribute( name );
	}
	val = elem.getAttributeNode( name );
	return val ?
	typeof elem[ name ] === "boolean" ?
	elem[ name ] ? name : null :
	val.specified ? val.value : null :
	null;
	};
	Expr = Sizzle.selectors = {
	// Can be adjusted by the user
	cacheLength: 50,
	createPseudo: markFunction,
	match: matchExpr,
	// IE6/7 return a modified href
	attrHandle: assertHrefNotNormalized ?
	{} :
	{
	"href": function( elem ) {
	return elem.getAttribute( "href", 2 );
	},
	"type": function( elem ) {
	return elem.getAttribute("type");
	}
	},
	find: {
	"ID": assertGetIdNotName ?
	function( id, context, xml ) {
	if ( typeof context.getElementById !== strundefined && !xml ) {
	var m = context.getElementById( id );
	// Check parentNode to catch when Blackberry 4.6 returns
	// nodes that are no longer in the document #6963
	return m && m.parentNode ? [m] : [];
	}
	} :
	function( id, context, xml ) {
	if ( typeof context.getElementById !== strundefined && !xml ) {
	var m = context.getElementById( id );
	return m ?
	m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
	[m] :
	undefined :
	[];
	}
	},
	"TAG": assertTagNameNoComments ?
	function( tag, context ) {
	if ( typeof context.getElementsByTagName !== strundefined ) {
	return context.getElementsByTagName( tag );
	}
	} :
	function( tag, context ) {
	var results = context.getElementsByTagName( tag );
	// Filter out possible comments
	if ( tag === "*" ) {
	var elem,
	tmp = [],
	i = 0;
	for ( ; (elem = results[i]); i++ ) {
	if ( elem.nodeType === 1 ) {
	tmp.push( elem );
	}
	}
	return tmp;
	}
	return results;
	},
	"NAME": assertUsableName && function( tag, context ) {
	if ( typeof context.getElementsByName !== strundefined ) {
	return context.getElementsByName( name );
	}
	},
	"CLASS": assertUsableClassName && function( className, context, xml ) {
	if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
	return context.getElementsByClassName( className );
	}
	}
	},
	relative: {
	">": { dir: "parentNode", first: true },
	" ": { dir: "parentNode" },
	"+": { dir: "previousSibling", first: true },
	"~": { dir: "previousSibling" }
	},
	preFilter: {
	"ATTR": function( match ) {
	match[1] = match[1].replace( rbackslash, "" );
	// Move the given value to match[3] whether quoted or unquoted
	match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );
	if ( match[2] === "~=" ) {
	match[3] = " " + match[3] + " ";
	}
	return match.slice( 0, 4 );
	},
	"CHILD": function( match ) {
	/* matches from matchExpr["CHILD"]
	1 type (only|nth|...)
	2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
	3 xn-component of xn+y argument ([+-]?\d*n|)
	4 sign of xn-component
	5 x of xn-component
	6 sign of y-component
	7 y of y-component
	*/
	match[1] = match[1].toLowerCase();
	if ( match[1] === "nth" ) {
	// nth-child requires argument
	if ( !match[2] ) {
	Sizzle.error( match[0] );
	}
	// numeric x and y parameters for Expr.filter.CHILD
	// remember that false/true cast respectively to 0/1
	match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
	match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );
	// other types prohibit arguments
	} else if ( match[2] ) {
	Sizzle.error( match[0] );
	}
	return match;
	},
	"PSEUDO": function( match ) {
	var unquoted, excess;
	if ( matchExpr["CHILD"].test( match[0] ) ) {
	return null;
	}
	if ( match[3] ) {
	match[2] = match[3];
	} else if ( (unquoted = match[4]) ) {
	// Only check arguments that contain a pseudo
	if ( rpseudo.test(unquoted) &&
	// Get excess from tokenize (recursively)
	(excess = tokenize( unquoted, true )) &&
	// advance to the next closing parenthesis
	(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	// excess is a negative index
	unquoted = unquoted.slice( 0, excess );
	match[0] = match[0].slice( 0, excess );
	}
	match[2] = unquoted;
	}
	// Return only captures needed by the pseudo filter method (type and argument)
	return match.slice( 0, 3 );
	}
	},
	filter: {
	"ID": assertGetIdNotName ?
	function( id ) {
	id = id.replace( rbackslash, "" );
	return function( elem ) {
	return elem.getAttribute("id") === id;
	};
	} :
	function( id ) {
	id = id.replace( rbackslash, "" );
	return function( elem ) {
	var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
	return node && node.value === id;
	};
	},
	"TAG": function( nodeName ) {
	if ( nodeName === "*" ) {
	return function() { return true; };
	}
	nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();
	return function( elem ) {
	return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
	};
	},
	"CLASS": function( className ) {
	var pattern = classCache[ expando ][ className + " " ];
	return pattern ||
	(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
	classCache( className, function( elem ) {
	return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
	});
	},
	"ATTR": function( name, operator, check ) {
	return function( elem, context ) {
	var result = Sizzle.attr( elem, name );
	if ( result == null ) {
	return operator === "!=";
	}
	if ( !operator ) {
	return true;
	}
	result += "";
	return operator === "=" ? result === check :
	operator === "!=" ? result !== check :
	operator === "^=" ? check && result.indexOf( check ) === 0 :
	operator === "*=" ? check && result.indexOf( check ) > -1 :
	operator === "$=" ? check && result.substr( result.length - check.length ) === check :
	operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
	operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
	false;
	};
	},
	"CHILD": function( type, argument, first, last ) {
	if ( type === "nth" ) {
	return function( elem ) {
	var node, diff,
	parent = elem.parentNode;
	if ( first === 1 && last === 0 ) {
	return true;
	}
	if ( parent ) {
	diff = 0;
	for ( node = parent.firstChild; node; node = node.nextSibling ) {
	if ( node.nodeType === 1 ) {
	diff++;
	if ( elem === node ) {
	break;
	}
	}
	}
	}
	// Incorporate the offset (or cast to NaN), then check against cycle size
	diff -= last;
	return diff === first || ( diff % first === 0 && diff / first >= 0 );
	};
	}
	return function( elem ) {
	var node = elem;
	switch ( type ) {
	case "only":
	case "first":
	while ( (node = node.previousSibling) ) {
	if ( node.nodeType === 1 ) {
	return false;
	}
	}
	if ( type === "first" ) {
	return true;
	}
	node = elem;
	/* falls through */
	case "last":
	while ( (node = node.nextSibling) ) {
	if ( node.nodeType === 1 ) {
	return false;
	}
	}
	return true;
	}
	};
	},
	"PSEUDO": function( pseudo, argument ) {
	// pseudo-class names are case-insensitive
	// http://www.w3.org/TR/selectors/#pseudo-classes
	// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
	// Remember that setFilters inherits from pseudos
	var args,
	fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
	Sizzle.error( "unsupported pseudo: " + pseudo );
	// The user may use createPseudo to indicate that
	// arguments are needed to create the filter function
	// just as Sizzle does
	if ( fn[ expando ] ) {
	return fn( argument );
	}
	// But maintain support for old signatures
	if ( fn.length > 1 ) {
	args = [ pseudo, pseudo, "", argument ];
	return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
	markFunction(function( seed, matches ) {
	var idx,
	matched = fn( seed, argument ),
	i = matched.length;
	while ( i-- ) {
	idx = indexOf.call( seed, matched[i] );
	seed[ idx ] = !( matches[ idx ] = matched[i] );
	}
	}) :
	function( elem ) {
	return fn( elem, 0, args );
	};
	}
	return fn;
	}
	},
	pseudos: {
	"not": markFunction(function( selector ) {
	// Trim the selector passed to compile
	// to avoid treating leading and trailing
	// spaces as combinators
	var input = [],
	results = [],
	matcher = compile( selector.replace( rtrim, "$1" ) );
	return matcher[ expando ] ?
	markFunction(function( seed, matches, context, xml ) {
	var elem,
	unmatched = matcher( seed, null, xml, [] ),
	i = seed.length;
	// Match elements unmatched by `matcher`
	while ( i-- ) {
	if ( (elem = unmatched[i]) ) {
	seed[i] = !(matches[i] = elem);
	}
	}
	}) :
	function( elem, context, xml ) {
	input[0] = elem;
	matcher( input, null, xml, results );
	return !results.pop();
	};
	}),
	"has": markFunction(function( selector ) {
	return function( elem ) {
	return Sizzle( selector, elem ).length > 0;
	};
	}),
	"contains": markFunction(function( text ) {
	return function( elem ) {
	return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
	};
	}),
	"enabled": function( elem ) {
	return elem.disabled === false;
	},
	"disabled": function( elem ) {
	return elem.disabled === true;
	},
	"checked": function( elem ) {
	// In CSS3, :checked should return both checked and selected elements
	// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	var nodeName = elem.nodeName.toLowerCase();
	return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
	},
	"selected": function( elem ) {
	// Accessing this property makes selected-by-default
	// options in Safari work properly
	if ( elem.parentNode ) {
	elem.parentNode.selectedIndex;
	}
	return elem.selected === true;
	},
	"parent": function( elem ) {
	return !Expr.pseudos["empty"]( elem );
	},
	"empty": function( elem ) {
	// http://www.w3.org/TR/selectors/#empty-pseudo
	// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
	//   not comment, processing instructions, or others
	// Thanks to Diego Perini for the nodeName shortcut
	//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
	var nodeType;
	elem = elem.firstChild;
	while ( elem ) {
	if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
	return false;
	}
	elem = elem.nextSibling;
	}
	return true;
	},
	"header": function( elem ) {
	return rheader.test( elem.nodeName );
	},
	"text": function( elem ) {
	var type, attr;
	// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
	// use getAttribute instead to test this case
	return elem.nodeName.toLowerCase() === "input" &&
	(type = elem.type) === "text" &&
	( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
	},
	// Input types
	"radio": createInputPseudo("radio"),
	"checkbox": createInputPseudo("checkbox"),
	"file": createInputPseudo("file"),
	"password": createInputPseudo("password"),
	"image": createInputPseudo("image"),
	"submit": createButtonPseudo("submit"),
	"reset": createButtonPseudo("reset"),
	"button": function( elem ) {
	var name = elem.nodeName.toLowerCase();
	return name === "input" && elem.type === "button" || name === "button";
	},
	"input": function( elem ) {
	return rinputs.test( elem.nodeName );
	},
	"focus": function( elem ) {
	var doc = elem.ownerDocument;
	return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
	},
	"active": function( elem ) {
	return elem === elem.ownerDocument.activeElement;
	},
	// Positional types
	"first": createPositionalPseudo(function() {
	return [ 0 ];
	}),
	"last": createPositionalPseudo(function( matchIndexes, length ) {
	return [ length - 1 ];
	}),
	"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
	return [ argument < 0 ? argument + length : argument ];
	}),
	"even": createPositionalPseudo(function( matchIndexes, length ) {
	for ( var i = 0; i < length; i += 2 ) {
	matchIndexes.push( i );
	}
	return matchIndexes;
	}),
	"odd": createPositionalPseudo(function( matchIndexes, length ) {
	for ( var i = 1; i < length; i += 2 ) {
	matchIndexes.push( i );
	}
	return matchIndexes;
	}),
	"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
	for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
	matchIndexes.push( i );
	}
	return matchIndexes;
	}),
	"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
	for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
	matchIndexes.push( i );
	}
	return matchIndexes;
	})
	}
	};
	function siblingCheck( a, b, ret ) {
	if ( a === b ) {
	return ret;
	}
	var cur = a.nextSibling;
	while ( cur ) {
	if ( cur === b ) {
	return -1;
	}
	cur = cur.nextSibling;
	}
	return 1;
	}
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
	if ( a === b ) {
	hasDuplicate = true;
	return 0;
	}
	return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
	a.compareDocumentPosition :
	a.compareDocumentPosition(b) & 4
	) ? -1 : 1;
	} :
	function( a, b ) {
	// The nodes are identical, we can exit early
	if ( a === b ) {
	hasDuplicate = true;
	return 0;
	// Fallback to using sourceIndex (in IE) if it's available on both nodes
	} else if ( a.sourceIndex && b.sourceIndex ) {
	return a.sourceIndex - b.sourceIndex;
	}
	var al, bl,
	ap = [],
	bp = [],
	aup = a.parentNode,
	bup = b.parentNode,
	cur = aup;
	// If the nodes are siblings (or identical) we can do a quick check
	if ( aup === bup ) {
	return siblingCheck( a, b );
	// If no parents were found then the nodes are disconnected
	} else if ( !aup ) {
	return -1;
	} else if ( !bup ) {
	return 1;
	}
	// Otherwise they're somewhere else in the tree so we need
	// to build up a full list of the parentNodes for comparison
	while ( cur ) {
	ap.unshift( cur );
	cur = cur.parentNode;
	}
	cur = bup;
	while ( cur ) {
	bp.unshift( cur );
	cur = cur.parentNode;
	}
	al = ap.length;
	bl = bp.length;
	// Start walking down the tree looking for a discrepancy
	for ( var i = 0; i < al && i < bl; i++ ) {
	if ( ap[i] !== bp[i] ) {
	return siblingCheck( ap[i], bp[i] );
	}
	}
	// We ended someplace up the tree so do a sibling check
	return i === al ?
	siblingCheck( a, bp[i], -1 ) :
	siblingCheck( ap[i], b, 1 );
	};
	// Always assume the presence of duplicates if sort doesn't
	// pass them to our comparison function (as in Google Chrome).
	[0, 0].sort( sortOrder );
	baseHasDuplicate = !hasDuplicate;
	// Document sorting and removing duplicates
	Sizzle.uniqueSort = function( results ) {
	var elem,
	duplicates = [],
	i = 1,
	j = 0;
	hasDuplicate = baseHasDuplicate;
	results.sort( sortOrder );
	if ( hasDuplicate ) {
	for ( ; (elem = results[i]); i++ ) {
	if ( elem === results[ i - 1 ] ) {
	j = duplicates.push( i );
	}
	}
	while ( j-- ) {
	results.splice( duplicates[ j ], 1 );
	}
	}
	return results;
	};
	Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
	soFar, groups, preFilters,
	cached = tokenCache[ expando ][ selector + " " ];
	if ( cached ) {
	return parseOnly ? 0 : cached.slice( 0 );
	}
	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;
	while ( soFar ) {
	// Comma and first run
	if ( !matched || (match = rcomma.exec( soFar )) ) {
	if ( match ) {
	// Don't consume trailing commas as valid
	soFar = soFar.slice( match[0].length ) || soFar;
	}
	groups.push( tokens = [] );
	}
	matched = false;
	// Combinators
	if ( (match = rcombinators.exec( soFar )) ) {
	tokens.push( matched = new Token( match.shift() ) );
	soFar = soFar.slice( matched.length );
	// Cast descendant combinators to space
	matched.type = match[0].replace( rtrim, " " );
	}
	// Filters
	for ( type in Expr.filter ) {
	if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
	(match = preFilters[ type ]( match ))) ) {
	tokens.push( matched = new Token( match.shift() ) );
	soFar = soFar.slice( matched.length );
	matched.type = type;
	matched.matches = match;
	}
	}
	if ( !matched ) {
	break;
	}
	}
	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
	soFar.length :
	soFar ?
	Sizzle.error( selector ) :
	// Cache the tokens
	tokenCache( selector, groups ).slice( 0 );
	}
	function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
	checkNonElements = base && combinator.dir === "parentNode",
	doneName = done++;
	return combinator.first ?
	// Check against closest ancestor/preceding element
	function( elem, context, xml ) {
	while ( (elem = elem[ dir ]) ) {
	if ( checkNonElements || elem.nodeType === 1  ) {
	return matcher( elem, context, xml );
	}
	}
	} :
	// Check against all ancestor/preceding elements
	function( elem, context, xml ) {
	// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
	if ( !xml ) {
	var cache,
	dirkey = dirruns + " " + doneName + " ",
	cachedkey = dirkey + cachedruns;
	while ( (elem = elem[ dir ]) ) {
	if ( checkNonElements || elem.nodeType === 1 ) {
	if ( (cache = elem[ expando ]) === cachedkey ) {
	return elem.sizset;
	} else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
	if ( elem.sizset ) {
	return elem;
	}
	} else {
	elem[ expando ] = cachedkey;
	if ( matcher( elem, context, xml ) ) {
	elem.sizset = true;
	return elem;
	}
	elem.sizset = false;
	}
	}
	}
	} else {
	while ( (elem = elem[ dir ]) ) {
	if ( checkNonElements || elem.nodeType === 1 ) {
	if ( matcher( elem, context, xml ) ) {
	return elem;
	}
	}
	}
	}
	};
	}
	function elementMatcher( matchers ) {
	return matchers.length > 1 ?
	function( elem, context, xml ) {
	var i = matchers.length;
	while ( i-- ) {
	if ( !matchers[i]( elem, context, xml ) ) {
	return false;
	}
	}
	return true;
	} :
	matchers[0];
	}
	function condense( unmatched, map, filter, context, xml ) {
	var elem,
	newUnmatched = [],
	i = 0,
	len = unmatched.length,
	mapped = map != null;
	for ( ; i < len; i++ ) {
	if ( (elem = unmatched[i]) ) {
	if ( !filter || filter( elem, context, xml ) ) {
	newUnmatched.push( elem );
	if ( mapped ) {
	map.push( i );
	}
	}
	}
	}
	return newUnmatched;
	}
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
	postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
	postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
	var temp, i, elem,
	preMap = [],
	postMap = [],
	preexisting = results.length,
	// Get initial elements from seed or context
	elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	// Prefilter to get matcher input, preserving a map for seed-results synchronization
	matcherIn = preFilter && ( seed || !selector ) ?
	condense( elems, preMap, preFilter, context, xml ) :
	elems,
	matcherOut = matcher ?
	// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
	postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	// ...intermediate processing is necessary
	[] :
	// ...otherwise use results directly
	results :
	matcherIn;
	// Find primary matches
	if ( matcher ) {
	matcher( matcherIn, matcherOut, context, xml );
	}
	// Apply postFilter
	if ( postFilter ) {
	temp = condense( matcherOut, postMap );
	postFilter( temp, [], context, xml );
	// Un-match failing elements by moving them back to matcherIn
	i = temp.length;
	while ( i-- ) {
	if ( (elem = temp[i]) ) {
	matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
	}
	}
	}
	if ( seed ) {
	if ( postFinder || preFilter ) {
	if ( postFinder ) {
	// Get the final matcherOut by condensing this intermediate into postFinder contexts
	temp = [];
	i = matcherOut.length;
	while ( i-- ) {
	if ( (elem = matcherOut[i]) ) {
	// Restore matcherIn since elem is not yet a final match
	temp.push( (matcherIn[i] = elem) );
	}
	}
	postFinder( null, (matcherOut = []), temp, xml );
	}
	// Move matched elements from seed to results to keep them synchronized
	i = matcherOut.length;
	while ( i-- ) {
	if ( (elem = matcherOut[i]) &&
	(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {
	seed[temp] = !(results[temp] = elem);
	}
	}
	}
	// Add elements to results, through postFinder if defined
	} else {
	matcherOut = condense(
	matcherOut === results ?
	matcherOut.splice( preexisting, matcherOut.length ) :
	matcherOut
	);
	if ( postFinder ) {
	postFinder( null, results, matcherOut, xml );
	} else {
	push.apply( results, matcherOut );
	}
	}
	});
	}
	function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
	len = tokens.length,
	leadingRelative = Expr.relative[ tokens[0].type ],
	implicitRelative = leadingRelative || Expr.relative[" "],
	i = leadingRelative ? 1 : 0,
	// The foundational matcher ensures that elements are reachable from top-level context(s)
	matchContext = addCombinator( function( elem ) {
	return elem === checkContext;
	}, implicitRelative, true ),
	matchAnyContext = addCombinator( function( elem ) {
	return indexOf.call( checkContext, elem ) > -1;
	}, implicitRelative, true ),
	matchers = [ function( elem, context, xml ) {
	return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
	(checkContext = context).nodeType ?
	matchContext( elem, context, xml ) :
	matchAnyContext( elem, context, xml ) );
	} ];
	for ( ; i < len; i++ ) {
	if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
	matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
	} else {
	matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	// Return special upon seeing a positional matcher
	if ( matcher[ expando ] ) {
	// Find the next relative operator (if any) for proper handling
	j = ++i;
	for ( ; j < len; j++ ) {
	if ( Expr.relative[ tokens[j].type ] ) {
	break;
	}
	}
	return setMatcher(
	i > 1 && elementMatcher( matchers ),
	i > 1 && tokens.slice( 0, i - 1 ).join("").replace( rtrim, "$1" ),
	matcher,
	i < j && matcherFromTokens( tokens.slice( i, j ) ),
	j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
	j < len && tokens.join("")
	);
	}
	matchers.push( matcher );
	}
	}
	return elementMatcher( matchers );
	}
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
	byElement = elementMatchers.length > 0,
	superMatcher = function( seed, context, xml, results, expandContext ) {
	var elem, j, matcher,
	setMatched = [],
	matchedCount = 0,
	i = "0",
	unmatched = seed && [],
	outermost = expandContext != null,
	contextBackup = outermostContext,
	// We must always have either seed elements or context
	elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
	// Nested matchers should use non-integer dirruns
	dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);
	if ( outermost ) {
	outermostContext = context !== document && context;
	cachedruns = superMatcher.el;
	}
	// Add elements passing elementMatchers directly to results
	for ( ; (elem = elems[i]) != null; i++ ) {
	if ( byElement && elem ) {
	for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
	if ( matcher( elem, context, xml ) ) {
	results.push( elem );
	break;
	}
	}
	if ( outermost ) {
	dirruns = dirrunsUnique;
	cachedruns = ++superMatcher.el;
	}
	}
	// Track unmatched elements for set filters
	if ( bySet ) {
	// They will have gone through all possible matchers
	if ( (elem = !matcher && elem) ) {
	matchedCount--;
	}
	// Lengthen the array for every element, matched or not
	if ( seed ) {
	unmatched.push( elem );
	}
	}
	}
	// Apply set filters to unmatched elements
	matchedCount += i;
	if ( bySet && i !== matchedCount ) {
	for ( j = 0; (matcher = setMatchers[j]); j++ ) {
	matcher( unmatched, setMatched, context, xml );
	}
	if ( seed ) {
	// Reintegrate element matches to eliminate the need for sorting
	if ( matchedCount > 0 ) {
	while ( i-- ) {
	if ( !(unmatched[i] || setMatched[i]) ) {
	setMatched[i] = pop.call( results );
	}
	}
	}
	// Discard index placeholder values to get only actual matches
	setMatched = condense( setMatched );
	}
	// Add matches to results
	push.apply( results, setMatched );
	// Seedless set matches succeeding multiple successful matchers stipulate sorting
	if ( outermost && !seed && setMatched.length > 0 &&
	( matchedCount + setMatchers.length ) > 1 ) {
	Sizzle.uniqueSort( results );
	}
	}
	// Override manipulation of globals by nested matchers
	if ( outermost ) {
	dirruns = dirrunsUnique;
	outermostContext = contextBackup;
	}
	return unmatched;
	};
	superMatcher.el = 0;
	return bySet ?
	markFunction( superMatcher ) :
	superMatcher;
	}
	compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
	setMatchers = [],
	elementMatchers = [],
	cached = compilerCache[ expando ][ selector + " " ];
	if ( !cached ) {
	// Generate a function of recursive functions that can be used to check each element
	if ( !group ) {
	group = tokenize( selector );
	}
	i = group.length;
	while ( i-- ) {
	cached = matcherFromTokens( group[i] );
	if ( cached[ expando ] ) {
	setMatchers.push( cached );
	} else {
	elementMatchers.push( cached );
	}
	}
	// Cache the compiled function
	cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
	};
	function multipleContexts( selector, contexts, results ) {
	var i = 0,
	len = contexts.length;
	for ( ; i < len; i++ ) {
	Sizzle( selector, contexts[i], results );
	}
	return results;
	}
	function select( selector, context, results, seed, xml ) {
	var i, tokens, token, type, find,
	match = tokenize( selector ),
	j = match.length;
	if ( !seed ) {
	// Try to minimize operations if there is only one group
	if ( match.length === 1 ) {
	// Take a shortcut and set the context if the root selector is an ID
	tokens = match[0] = match[0].slice( 0 );
	if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
	context.nodeType === 9 && !xml &&
	Expr.relative[ tokens[1].type ] ) {
	context = Expr.find["ID"]( token.matches[0].replace( rbackslash, "" ), context, xml )[0];
	if ( !context ) {
	return results;
	}
	selector = selector.slice( tokens.shift().length );
	}
	// Fetch a seed set for right-to-left matching
	for ( i = matchExpr["POS"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
	token = tokens[i];
	// Abort if we hit a combinator
	if ( Expr.relative[ (type = token.type) ] ) {
	break;
	}
	if ( (find = Expr.find[ type ]) ) {
	// Search, expanding context for leading sibling combinators
	if ( (seed = find(
	token.matches[0].replace( rbackslash, "" ),
	rsibling.test( tokens[0].type ) && context.parentNode || context,
	xml
	)) ) {
	// If seed is empty or no tokens remain, we can return early
	tokens.splice( i, 1 );
	selector = seed.length && tokens.join("");
	if ( !selector ) {
	push.apply( results, slice.call( seed, 0 ) );
	return results;
	}
	break;
	}
	}
	}
	}
	}
	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
	seed,
	context,
	xml,
	results,
	rsibling.test( selector )
	);
	return results;
	}
	if ( document.querySelectorAll ) {
	(function() {
	var disconnectedMatch,
	oldSelect = select,
	rescape = /'|\\/g,
	rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,
	// qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
	// A support test would require too much code (would include document ready)
	rbuggyQSA = [ ":focus" ],
	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	// A support test would require too much code (would include document ready)
	// just skip matchesSelector for :active
	rbuggyMatches = [ ":active" ],
	matches = docElem.matchesSelector ||
	docElem.mozMatchesSelector ||
	docElem.webkitMatchesSelector ||
	docElem.oMatchesSelector ||
	docElem.msMatchesSelector;
	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert(function( div ) {
	// Select is set to empty string on purpose
	// This is to test IE's treatment of not explictly
	// setting a boolean content attribute,
	// since its presence should be enough
	// http://bugs.jquery.com/ticket/12359
	div.innerHTML = "<select><option selected=''></option></select>";
	// IE8 - Some boolean attributes are not treated correctly
	if ( !div.querySelectorAll("[selected]").length ) {
	rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
	}
	// Webkit/Opera - :checked should return selected option elements
	// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	// IE8 throws error here (do not put tests after this one)
	if ( !div.querySelectorAll(":checked").length ) {
	rbuggyQSA.push(":checked");
	}
	});
	assert(function( div ) {
	// Opera 10-12/IE9 - ^= $= *= and empty values
	// Should not select anything
	div.innerHTML = "<p test=''></p>";
	if ( div.querySelectorAll("[test^='']").length ) {
	rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
	}
	// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
	// IE8 throws error here (do not put tests after this one)
	div.innerHTML = "<input type='hidden'/>";
	if ( !div.querySelectorAll(":enabled").length ) {
	rbuggyQSA.push(":enabled", ":disabled");
	}
	});
	// rbuggyQSA always contains :focus, so no need for a length check
	rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA.join("|") );
	select = function( selector, context, results, seed, xml ) {
	// Only use querySelectorAll when not filtering,
	// when this is not xml,
	// and when no QSA bugs apply
	if ( !seed && !xml && !rbuggyQSA.test( selector ) ) {
	var groups, i,
	old = true,
	nid = expando,
	newContext = context,
	newSelector = context.nodeType === 9 && selector;
	// qSA works strangely on Element-rooted queries
	// We can work around this by specifying an extra ID on the root
	// and working up from there (Thanks to Andrew Dupont for the technique)
	// IE 8 doesn't work on object elements
	if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
	groups = tokenize( selector );
	if ( (old = context.getAttribute("id")) ) {
	nid = old.replace( rescape, "\\$&" );
	} else {
	context.setAttribute( "id", nid );
	}
	nid = "[id='" + nid + "'] ";
	i = groups.length;
	while ( i-- ) {
	groups[i] = nid + groups[i].join("");
	}
	newContext = rsibling.test( selector ) && context.parentNode || context;
	newSelector = groups.join(",");
	}
	if ( newSelector ) {
	try {
	push.apply( results, slice.call( newContext.querySelectorAll(
	newSelector
	), 0 ) );
	return results;
	} catch(qsaError) {
	} finally {
	if ( !old ) {
	context.removeAttribute("id");
	}
	}
	}
	}
	return oldSelect( selector, context, results, seed, xml );
	};
	if ( matches ) {
	assert(function( div ) {
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node (IE 9)
	disconnectedMatch = matches.call( div, "div" );
	// This should fail with an exception
	// Gecko does not error, returns false instead
	try {
	matches.call( div, "[test!='']:sizzle" );
	rbuggyMatches.push( "!=", pseudos );
	} catch ( e ) {}
	});
	// rbuggyMatches always contains :active and :focus, so no need for a length check
	rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );
	Sizzle.matchesSelector = function( elem, expr ) {
	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );
	// rbuggyMatches always contains :active, so no need for an existence check
	if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && !rbuggyQSA.test( expr ) ) {
	try {
	var ret = matches.call( elem, expr );
	// IE 9's matchesSelector returns false on disconnected nodes
	if ( ret || disconnectedMatch ||
	// As well, disconnected nodes are said to be in a document
	// fragment in IE 9
	elem.document && elem.document.nodeType !== 11 ) {
	return ret;
	}
	} catch(e) {}
	}
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
	};
	}
	})();
	}
	// Deprecated
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	// Back-compat
	function setFilters() {}
	Expr.filters = setFilters.prototype = Expr.pseudos;
	Expr.setFilters = new setFilters();
	// Override sizzle attribute retrieval
	Sizzle.attr = jQuery.attr;
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	})( window );
	var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
	children: true,
	contents: true,
	next: true,
	prev: true
	};
	jQuery.fn.extend({
	find: function( selector ) {
	var i, l, length, n, r, ret,
	self = this;
	if ( typeof selector !== "string" ) {
	return jQuery( selector ).filter(function() {
	for ( i = 0, l = self.length; i < l; i++ ) {
	if ( jQuery.contains( self[ i ], this ) ) {
	return true;
	}
	}
	});
	}
	ret = this.pushStack( "", "find", selector );
	for ( i = 0, l = this.length; i < l; i++ ) {
	length = ret.length;
	jQuery.find( selector, this[i], ret );
	if ( i > 0 ) {
	// Make sure that the results are unique
	for ( n = length; n < ret.length; n++ ) {
	for ( r = 0; r < length; r++ ) {
	if ( ret[r] === ret[n] ) {
	ret.splice(n--, 1);
	break;
	}
	}
	}
	}
	}
	return ret;
	},
	has: function( target ) {
	var i,
	targets = jQuery( target, this ),
	len = targets.length;
	return this.filter(function() {
	for ( i = 0; i < len; i++ ) {
	if ( jQuery.contains( this, targets[i] ) ) {
	return true;
	}
	}
	});
	},
	not: function( selector ) {
	return this.pushStack( winnow(this, selector, false), "not", selector);
	},
	filter: function( selector ) {
	return this.pushStack( winnow(this, selector, true), "filter", selector );
	},
	is: function( selector ) {
	return !!selector && (
	typeof selector === "string" ?
	// If this is a positional/relative selector, check membership in the returned set
	// so $("p:first").is("p:last") won't return true for a doc with two "p".
	rneedsContext.test( selector ) ?
	jQuery( selector, this.context ).index( this[0] ) >= 0 :
	jQuery.filter( selector, this ).length > 0 :
	this.filter( selector ).length > 0 );
	},
	closest: function( selectors, context ) {
	var cur,
	i = 0,
	l = this.length,
	ret = [],
	pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
	jQuery( selectors, context || this.context ) :
	0;
	for ( ; i < l; i++ ) {
	cur = this[i];
	while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
	if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
	ret.push( cur );
	break;
	}
	cur = cur.parentNode;
	}
	}
	ret = ret.length > 1 ? jQuery.unique( ret ) : ret;
	return this.pushStack( ret, "closest", selectors );
	},
	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {
	// No argument, return index in parent
	if ( !elem ) {
	return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
	}
	// index in selector
	if ( typeof elem === "string" ) {
	return jQuery.inArray( this[0], jQuery( elem ) );
	}
	// Locate the position of the desired element
	return jQuery.inArray(
	// If it receives a jQuery object, the first element is used
	elem.jquery ? elem[0] : elem, this );
	},
	add: function( selector, context ) {
	var set = typeof selector === "string" ?
	jQuery( selector, context ) :
	jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
	all = jQuery.merge( this.get(), set );
	return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
	all :
	jQuery.unique( all ) );
	},
	addBack: function( selector ) {
	return this.add( selector == null ?
	this.prevObject : this.prevObject.filter(selector)
	);
	}
	});
	jQuery.fn.andSelf = jQuery.fn.addBack;
	// A painfully simple check to see if an element is disconnected
	// from a document (should be improved, where feasible).
	function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
	}
	function sibling( cur, dir ) {
	do {
	cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );
	return cur;
	}
	jQuery.each({
	parent: function( elem ) {
	var parent = elem.parentNode;
	return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
	return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
	return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
	return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
	return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
	return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
	return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
	return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
	return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
	return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
	return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
	return jQuery.nodeName( elem, "iframe" ) ?
	elem.contentDocument || elem.contentWindow.document :
	jQuery.merge( [], elem.childNodes );
	}
	}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
	var ret = jQuery.map( this, fn, until );
	if ( !runtil.test( name ) ) {
	selector = until;
	}
	if ( selector && typeof selector === "string" ) {
	ret = jQuery.filter( selector, ret );
	}
	ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
	if ( this.length > 1 && rparentsprev.test( name ) ) {
	ret = ret.reverse();
	}
	return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
	};
	});
	jQuery.extend({
	filter: function( expr, elems, not ) {
	if ( not ) {
	expr = ":not(" + expr + ")";
	}
	return elems.length === 1 ?
	jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
	jQuery.find.matches(expr, elems);
	},
	dir: function( elem, dir, until ) {
	var matched = [],
	cur = elem[ dir ];
	while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
	if ( cur.nodeType === 1 ) {
	matched.push( cur );
	}
	cur = cur[dir];
	}
	return matched;
	},
	sibling: function( n, elem ) {
	var r = [];
	for ( ; n; n = n.nextSibling ) {
	if ( n.nodeType === 1 && n !== elem ) {
	r.push( n );
	}
	}
	return r;
	}
	});
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, keep ) {
	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;
	if ( jQuery.isFunction( qualifier ) ) {
	return jQuery.grep(elements, function( elem, i ) {
	var retVal = !!qualifier.call( elem, i, elem );
	return retVal === keep;
	});
	} else if ( qualifier.nodeType ) {
	return jQuery.grep(elements, function( elem, i ) {
	return ( elem === qualifier ) === keep;
	});
	} else if ( typeof qualifier === "string" ) {
	var filtered = jQuery.grep(elements, function( elem ) {
	return elem.nodeType === 1;
	});
	if ( isSimple.test( qualifier ) ) {
	return jQuery.filter(qualifier, filtered, !keep);
	} else {
	qualifier = jQuery.filter( qualifier, filtered );
	}
	}
	return jQuery.grep(elements, function( elem, i ) {
	return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
	}
	function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();
	if ( safeFrag.createElement ) {
	while ( list.length ) {
	safeFrag.createElement(
	list.pop()
	);
	}
	}
	return safeFrag;
	}
	var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
	"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		rnocache = /<(?:script|object|embed|option|style)/i,
		rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
		rcheckableType = /^(?:checkbox|radio)$/,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /\/(java|ecma)script/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
		wrapMap = {
	option: [ 1, "<select multiple='multiple'>", "</select>" ],
legend: [ 1, "<fieldset>", "</fieldset>" ],
thead: [ 1, "<table>", "</table>" ],
tr: [ 2, "<table><tbody>", "</tbody></table>" ],
td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
area: [ 1, "<map>", "</map>" ],
_default: [ 0, "", "" ]
},
safeFragment = createSafeFragment( document ),
fragmentDiv = safeFragment.appendChild( document.createElement("div") );
wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;
// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
wrapMap._default = [ 1, "X<div>", "</div>" ];
}
jQuery.fn.extend({
text: function( value ) {
return jQuery.access( this, function( value ) {
return value === undefined ?
jQuery.text( this ) :
this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
}, null, value, arguments.length );
},
wrapAll: function( html ) {
if ( jQuery.isFunction( html ) ) {
return this.each(function(i) {
jQuery(this).wrapAll( html.call(this, i) );
});
}
if ( this[0] ) {
// The elements to wrap the target around
var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
if ( this[0].parentNode ) {
wrap.insertBefore( this[0] );
}
wrap.map(function() {
var elem = this;
while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
elem = elem.firstChild;
}
return elem;
}).append( this );
}
return this;
},
wrapInner: function( html ) {
if ( jQuery.isFunction( html ) ) {
return this.each(function(i) {
jQuery(this).wrapInner( html.call(this, i) );
});
}
return this.each(function() {
var self = jQuery( this ),
contents = self.contents();
if ( contents.length ) {
contents.wrapAll( html );
} else {
self.append( html );
}
});
},
wrap: function( html ) {
var isFunction = jQuery.isFunction( html );
return this.each(function(i) {
jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
});
},
unwrap: function() {
return this.parent().each(function() {
if ( !jQuery.nodeName( this, "body" ) ) {
jQuery( this ).replaceWith( this.childNodes );
}
}).end();
},
append: function() {
return this.domManip(arguments, true, function( elem ) {
if ( this.nodeType === 1 || this.nodeType === 11 ) {
this.appendChild( elem );
}
});
},
prepend: function() {
return this.domManip(arguments, true, function( elem ) {
if ( this.nodeType === 1 || this.nodeType === 11 ) {
this.insertBefore( elem, this.firstChild );
}
});
},
before: function() {
if ( !isDisconnected( this[0] ) ) {
return this.domManip(arguments, false, function( elem ) {
this.parentNode.insertBefore( elem, this );
});
}
if ( arguments.length ) {
var set = jQuery.clean( arguments );
return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
}
},
after: function() {
if ( !isDisconnected( this[0] ) ) {
return this.domManip(arguments, false, function( elem ) {
this.parentNode.insertBefore( elem, this.nextSibling );
});
}
if ( arguments.length ) {
var set = jQuery.clean( arguments );
return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
}
},
// keepData is for internal use only--do not document
remove: function( selector, keepData ) {
var elem,
i = 0;
for ( ; (elem = this[i]) != null; i++ ) {
if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
if ( !keepData && elem.nodeType === 1 ) {
jQuery.cleanData( elem.getElementsByTagName("*") );
jQuery.cleanData( [ elem ] );
}
if ( elem.parentNode ) {
elem.parentNode.removeChild( elem );
}
}
}
return this;
},
empty: function() {
var elem,
i = 0;
for ( ; (elem = this[i]) != null; i++ ) {
// Remove element nodes and prevent memory leaks
if ( elem.nodeType === 1 ) {
jQuery.cleanData( elem.getElementsByTagName("*") );
}
// Remove any remaining nodes
while ( elem.firstChild ) {
elem.removeChild( elem.firstChild );
}
}
return this;
},
clone: function( dataAndEvents, deepDataAndEvents ) {
dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
return this.map( function () {
return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
});
},
html: function( value ) {
return jQuery.access( this, function( value ) {
var elem = this[0] || {},
i = 0,
l = this.length;
if ( value === undefined ) {
return elem.nodeType === 1 ?
elem.innerHTML.replace( rinlinejQuery, "" ) :
undefined;
}
// See if we can take a shortcut and just use innerHTML
if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {
value = value.replace( rxhtmlTag, "<$1></$2>" );
try {
for (; i < l; i++ ) {
// Remove element nodes and prevent memory leaks
elem = this[i] || {};
if ( elem.nodeType === 1 ) {
jQuery.cleanData( elem.getElementsByTagName( "*" ) );
elem.innerHTML = value;
}
}
elem = 0;
// If using innerHTML throws an exception, use the fallback method
} catch(e) {}
}
if ( elem ) {
this.empty().append( value );
}
}, null, value, arguments.length );
},
replaceWith: function( value ) {
if ( !isDisconnected( this[0] ) ) {
// Make sure that the elements are removed from the DOM before they are inserted
// this can help fix replacing a parent with child elements
if ( jQuery.isFunction( value ) ) {
return this.each(function(i) {
var self = jQuery(this), old = self.html();
self.replaceWith( value.call( this, i, old ) );
});
}
if ( typeof value !== "string" ) {
value = jQuery( value ).detach();
}
return this.each(function() {
var next = this.nextSibling,
parent = this.parentNode;
jQuery( this ).remove();
if ( next ) {
jQuery(next).before( value );
} else {
jQuery(parent).append( value );
}
});
}
return this.length ?
this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
this;
},
detach: function( selector ) {
return this.remove( selector, true );
},
domManip: function( args, table, callback ) {
// Flatten any nested arrays
args = [].concat.apply( [], args );
var results, first, fragment, iNoClone,
i = 0,
value = args[0],
scripts = [],
l = this.length;
// We can't cloneNode fragments that contain checked, in WebKit
if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
return this.each(function() {
jQuery(this).domManip( args, table, callback );
});
}
if ( jQuery.isFunction(value) ) {
return this.each(function(i) {
var self = jQuery(this);
args[0] = value.call( this, i, table ? self.html() : undefined );
self.domManip( args, table, callback );
});
}
if ( this[0] ) {
results = jQuery.buildFragment( args, this, scripts );
fragment = results.fragment;
first = fragment.firstChild;
if ( fragment.childNodes.length === 1 ) {
fragment = first;
}
if ( first ) {
table = table && jQuery.nodeName( first, "tr" );
// Use the original fragment for the last item instead of the first because it can end up
// being emptied incorrectly in certain situations (#8070).
// Fragments from the fragment cache must always be cloned and never used in place.
for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
callback.call(
table && jQuery.nodeName( this[i], "table" ) ?
findOrAppend( this[i], "tbody" ) :
this[i],
i === iNoClone ?
fragment :
jQuery.clone( fragment, true, true )
);
}
}
// Fix #11809: Avoid leaking memory
fragment = first = null;
if ( scripts.length ) {
jQuery.each( scripts, function( i, elem ) {
if ( elem.src ) {
if ( jQuery.ajax ) {
jQuery.ajax({
url: elem.src,
type: "GET",
dataType: "script",
async: false,
global: false,
"throws": true
});
} else {
jQuery.error("no ajax");
}
} else {
jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
}
if ( elem.parentNode ) {
elem.parentNode.removeChild( elem );
}
});
}
}
return this;
}
});
function findOrAppend( elem, tag ) {
return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}
function cloneCopyEvent( src, dest ) {
if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
return;
}
var type, i, l,
oldData = jQuery._data( src ),
curData = jQuery._data( dest, oldData ),
events = oldData.events;
if ( events ) {
delete curData.handle;
curData.events = {};
for ( type in events ) {
for ( i = 0, l = events[ type ].length; i < l; i++ ) {
jQuery.event.add( dest, type, events[ type ][ i ] );
}
}
}
// make the cloned public data object a copy from the original
if ( curData.data ) {
curData.data = jQuery.extend( {}, curData.data );
}
}
function cloneFixAttributes( src, dest ) {
var nodeName;
// We do not need to do anything for non-Elements
if ( dest.nodeType !== 1 ) {
return;
}
// clearAttributes removes the attributes, which we don't want,
// but also removes the attachEvent events, which we *do* want
if ( dest.clearAttributes ) {
dest.clearAttributes();
}
// mergeAttributes, in contrast, only merges back on the
// original attributes, not the events
if ( dest.mergeAttributes ) {
dest.mergeAttributes( src );
}
nodeName = dest.nodeName.toLowerCase();
if ( nodeName === "object" ) {
// IE6-10 improperly clones children of object elements using classid.
// IE10 throws NoModificationAllowedError if parent is null, #12132.
if ( dest.parentNode ) {
dest.outerHTML = src.outerHTML;
}
// This path appears unavoidable for IE9. When cloning an object
// element in IE9, the outerHTML strategy above is not sufficient.
// If the src has innerHTML and the destination does not,
// copy the src.innerHTML into the dest.innerHTML. #10324
if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
dest.innerHTML = src.innerHTML;
}
} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
// IE6-8 fails to persist the checked state of a cloned checkbox
// or radio button. Worse, IE6-7 fail to give the cloned element
// a checked appearance if the defaultChecked value isn't also set
dest.defaultChecked = dest.checked = src.checked;
// IE6-7 get confused and end up setting the value of a cloned
// checkbox/radio button to an empty string instead of "on"
if ( dest.value !== src.value ) {
dest.value = src.value;
}
// IE6-8 fails to return the selected option to the default selected
// state when cloning options
} else if ( nodeName === "option" ) {
dest.selected = src.defaultSelected;
// IE6-8 fails to set the defaultValue to the correct value when
// cloning other types of input fields
} else if ( nodeName === "input" || nodeName === "textarea" ) {
dest.defaultValue = src.defaultValue;
// IE blanks contents when cloning scripts
} else if ( nodeName === "script" && dest.text !== src.text ) {
dest.text = src.text;
}
// Event data gets referenced instead of copied if the expando
// gets copied too
dest.removeAttribute( jQuery.expando );
}
jQuery.buildFragment = function( args, context, scripts ) {
var fragment, cacheable, cachehit,
first = args[ 0 ];
// Set context from what may come in as undefined or a jQuery collection or a node
// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
context = context || document;
context = !context.nodeType && context[0] || context;
context = context.ownerDocument || context;
// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
// Cloning options loses the selected state, so don't cache them
// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
first.charAt(0) === "<" && !rnocache.test( first ) &&
(jQuery.support.checkClone || !rchecked.test( first )) &&
(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {
// Mark cacheable and look for a hit
cacheable = true;
fragment = jQuery.fragments[ first ];
cachehit = fragment !== undefined;
}
if ( !fragment ) {
fragment = context.createDocumentFragment();
jQuery.clean( args, context, fragment, scripts );
// Update the cache, but only store false
// unless this is a second parsing of the same content
if ( cacheable ) {
jQuery.fragments[ first ] = cachehit && fragment;
}
}
return { fragment: fragment, cacheable: cacheable };
};
jQuery.fragments = {};
jQuery.each({
appendTo: "append",
prependTo: "prepend",
insertBefore: "before",
insertAfter: "after",
replaceAll: "replaceWith"
}, function( name, original ) {
jQuery.fn[ name ] = function( selector ) {
var elems,
i = 0,
ret = [],
insert = jQuery( selector ),
l = insert.length,
parent = this.length === 1 && this[0].parentNode;
if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
insert[ original ]( this[0] );
return this;
} else {
for ( ; i < l; i++ ) {
elems = ( i > 0 ? this.clone(true) : this ).get();
jQuery( insert[i] )[ original ]( elems );
ret = ret.concat( elems );
}
return this.pushStack( ret, name, insert.selector );
}
};
});
function getAll( elem ) {
if ( typeof elem.getElementsByTagName !== "undefined" ) {
return elem.getElementsByTagName( "*" );
} else if ( typeof elem.querySelectorAll !== "undefined" ) {
return elem.querySelectorAll( "*" );
} else {
return [];
}
}
// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
if ( rcheckableType.test( elem.type ) ) {
elem.defaultChecked = elem.checked;
}
}
jQuery.extend({
clone: function( elem, dataAndEvents, deepDataAndEvents ) {
var srcElements,
destElements,
i,
clone;
if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
clone = elem.cloneNode( true );
// IE<=8 does not properly clone detached, unknown element nodes
} else {
fragmentDiv.innerHTML = elem.outerHTML;
fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
}
if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
// IE copies events bound via attachEvent when using cloneNode.
// Calling detachEvent on the clone will also remove the events
// from the original. In order to get around this, we use some
// proprietary methods to clear the events. Thanks to MooTools
// guys for this hotness.
cloneFixAttributes( elem, clone );
// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
srcElements = getAll( elem );
destElements = getAll( clone );
// Weird iteration because IE will replace the length property
// with an element if you are cloning the body and one of the
// elements on the page has a name or id of "length"
for ( i = 0; srcElements[i]; ++i ) {
// Ensure that the destination node is not null; Fixes #9587
if ( destElements[i] ) {
cloneFixAttributes( srcElements[i], destElements[i] );
}
}
}
// Copy the events from the original to the clone
if ( dataAndEvents ) {
cloneCopyEvent( elem, clone );
if ( deepDataAndEvents ) {
srcElements = getAll( elem );
destElements = getAll( clone );
for ( i = 0; srcElements[i]; ++i ) {
cloneCopyEvent( srcElements[i], destElements[i] );
}
}
}
srcElements = destElements = null;
// Return the cloned set
return clone;
},
clean: function( elems, context, fragment, scripts ) {
var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
safe = context === document && safeFragment,
ret = [];
// Ensure that context is a document
if ( !context || typeof context.createDocumentFragment === "undefined" ) {
context = document;
}
// Use the already-created safe fragment if context permits
for ( i = 0; (elem = elems[i]) != null; i++ ) {
if ( typeof elem === "number" ) {
elem += "";
}
if ( !elem ) {
continue;
}
// Convert html string into DOM nodes
if ( typeof elem === "string" ) {
if ( !rhtml.test( elem ) ) {
elem = context.createTextNode( elem );
} else {
// Ensure a safe container in which to render the html
safe = safe || createSafeFragment( context );
div = context.createElement("div");
safe.appendChild( div );
// Fix "XHTML"-style tags in all browsers
elem = elem.replace(rxhtmlTag, "<$1></$2>");
// Go to html and back, then peel off extra wrappers
tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
wrap = wrapMap[ tag ] || wrapMap._default;
depth = wrap[0];
div.innerHTML = wrap[1] + elem + wrap[2];
// Move to the right depth
while ( depth-- ) {
div = div.lastChild;
}
// Remove IE's autoinserted <tbody> from table fragments
if ( !jQuery.support.tbody ) {
// String was a <table>, *may* have spurious <tbody>
hasBody = rtbody.test(elem);
tbody = tag === "table" && !hasBody ?
div.firstChild && div.firstChild.childNodes :
// String was a bare <thead> or <tfoot>
wrap[1] === "<table>" && !hasBody ?
div.childNodes :
[];
for ( j = tbody.length - 1; j >= 0 ; --j ) {
if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
tbody[ j ].parentNode.removeChild( tbody[ j ] );
}
}
}
// IE completely kills leading whitespace when innerHTML is used
if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
}
elem = div.childNodes;
// Take out of fragment container (we need a fresh div each time)
div.parentNode.removeChild( div );
}
}
if ( elem.nodeType ) {
ret.push( elem );
} else {
jQuery.merge( ret, elem );
}
}
// Fix #11356: Clear elements from safeFragment
if ( div ) {
elem = div = safe = null;
}
// Reset defaultChecked for any radios and checkboxes
// about to be appended to the DOM in IE 6/7 (#8060)
if ( !jQuery.support.appendChecked ) {
for ( i = 0; (elem = ret[i]) != null; i++ ) {
if ( jQuery.nodeName( elem, "input" ) ) {
fixDefaultChecked( elem );
} else if ( typeof elem.getElementsByTagName !== "undefined" ) {
jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
}
}
}
// Append elements to a provided document fragment
if ( fragment ) {
// Special handling of each script element
handleScript = function( elem ) {
// Check if we consider it executable
if ( !elem.type || rscriptType.test( elem.type ) ) {
// Detach the script and store it in the scripts array (if provided) or the fragment
// Return truthy to indicate that it has been handled
return scripts ?
scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
fragment.appendChild( elem );
}
};
for ( i = 0; (elem = ret[i]) != null; i++ ) {
// Check if we're done after handling an executable script
if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
// Append to fragment and handle embedded scripts
fragment.appendChild( elem );
if ( typeof elem.getElementsByTagName !== "undefined" ) {
// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );
// Splice the scripts into ret after their former ancestor and advance our index beyond them
ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
i += jsTags.length;
}
}
}
}
return ret;
},
cleanData: function( elems, /* internal */ acceptData ) {
var data, id, elem, type,
i = 0,
internalKey = jQuery.expando,
cache = jQuery.cache,
deleteExpando = jQuery.support.deleteExpando,
special = jQuery.event.special;
for ( ; (elem = elems[i]) != null; i++ ) {
if ( acceptData || jQuery.acceptData( elem ) ) {
id = elem[ internalKey ];
data = id && cache[ id ];
if ( data ) {
if ( data.events ) {
for ( type in data.events ) {
if ( special[ type ] ) {
jQuery.event.remove( elem, type );
// This is a shortcut to avoid jQuery.event.remove's overhead
} else {
jQuery.removeEvent( elem, type, data.handle );
}
}
}
// Remove cache only if it was not already removed by jQuery.event.remove
if ( cache[ id ] ) {
delete cache[ id ];
// IE does not allow us to delete expando properties from nodes,
// nor does it have a removeAttribute function on Document nodes;
// we must handle all of these cases
if ( deleteExpando ) {
delete elem[ internalKey ];
} else if ( elem.removeAttribute ) {
elem.removeAttribute( internalKey );
} else {
elem[ internalKey ] = null;
}
jQuery.deletedIds.push( id );
}
}
}
}
}
});
// Limit scope pollution from any deprecated API
(function() {
var matched, browser;
// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
ua = ua.toLowerCase();
var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
/(msie) ([\w.]+)/.exec( ua ) ||
ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
[];
return {
browser: match[ 1 ] || "",
version: match[ 2 ] || "0"
};
};
matched = jQuery.uaMatch( navigator.userAgent );
browser = {};
if ( matched.browser ) {
browser[ matched.browser ] = true;
browser.version = matched.version;
}
// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
browser.webkit = true;
} else if ( browser.webkit ) {
browser.safari = true;
}
jQuery.browser = browser;
jQuery.sub = function() {
function jQuerySub( selector, context ) {
return new jQuerySub.fn.init( selector, context );
}
jQuery.extend( true, jQuerySub, this );
jQuerySub.superclass = this;
jQuerySub.fn = jQuerySub.prototype = this();
jQuerySub.fn.constructor = jQuerySub;
jQuerySub.sub = this.sub;
jQuerySub.fn.init = function init( selector, context ) {
if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
context = jQuerySub( context );
}
return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
};
jQuerySub.fn.init.prototype = jQuerySub.fn;
var rootjQuerySub = jQuerySub(document);
return jQuerySub;
};
})();
var curCSS, iframe, iframeDoc,
ralpha = /alpha\([^)]*\)/i,
ropacity = /opacity=([^)]*)/,
rposition = /^(top|right|bottom|left)$/,
// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
rdisplayswap = /^(none|table(?!-c[ea]).+)/,
rmargin = /^margin/,
rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
elemdisplay = { BODY: "block" },
cssShow = { position: "absolute", visibility: "hidden", display: "block" },
cssNormalTransform = {
letterSpacing: 0,
fontWeight: 400
},
cssExpand = [ "Top", "Right", "Bottom", "Left" ],
cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
eventsToggle = jQuery.fn.toggle;
// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {
// shortcut for names that are not vendor prefixed
if ( name in style ) {
return name;
}
// check for vendor prefixed names
var capName = name.charAt(0).toUpperCase() + name.slice(1),
origName = name,
i = cssPrefixes.length;
while ( i-- ) {
name = cssPrefixes[ i ] + capName;
if ( name in style ) {
return name;
}
}
return origName;
}
function isHidden( elem, el ) {
elem = el || elem;
return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}
function showHide( elements, show ) {
var elem, display,
values = [],
index = 0,
length = elements.length;
for ( ; index < length; index++ ) {
elem = elements[ index ];
if ( !elem.style ) {
continue;
}
values[ index ] = jQuery._data( elem, "olddisplay" );
if ( show ) {
// Reset the inline display of this element to learn if it is
// being hidden by cascaded rules or not
if ( !values[ index ] && elem.style.display === "none" ) {
elem.style.display = "";
}
// Set elements which have been overridden with display: none
// in a stylesheet to whatever the default browser style is
// for such an element
if ( elem.style.display === "" && isHidden( elem ) ) {
values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
}
} else {
display = curCSS( elem, "display" );
if ( !values[ index ] && display !== "none" ) {
jQuery._data( elem, "olddisplay", display );
}
}
}
// Set the display of most of the elements in a second loop
// to avoid the constant reflow
for ( index = 0; index < length; index++ ) {
elem = elements[ index ];
if ( !elem.style ) {
continue;
}
if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
elem.style.display = show ? values[ index ] || "" : "none";
}
}
return elements;
}
jQuery.fn.extend({
css: function( name, value ) {
return jQuery.access( this, function( elem, name, value ) {
return value !== undefined ?
jQuery.style( elem, name, value ) :
jQuery.css( elem, name );
}, name, value, arguments.length > 1 );
},
show: function() {
return showHide( this, true );
},
hide: function() {
return showHide( this );
},
toggle: function( state, fn2 ) {
var bool = typeof state === "boolean";
if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
return eventsToggle.apply( this, arguments );
}
return this.each(function() {
if ( bool ? state : isHidden( this ) ) {
jQuery( this ).show();
} else {
jQuery( this ).hide();
}
});
}
});
jQuery.extend({
// Add in style property hooks for overriding the default
// behavior of getting and setting a style property
cssHooks: {
opacity: {
get: function( elem, computed ) {
if ( computed ) {
// We should always get a number back from opacity
var ret = curCSS( elem, "opacity" );
return ret === "" ? "1" : ret;
}
}
}
},
// Exclude the following css properties to add px
cssNumber: {
"fillOpacity": true,
"fontWeight": true,
"lineHeight": true,
"opacity": true,
"orphans": true,
"widows": true,
"zIndex": true,
"zoom": true
},
// Add in properties whose names you wish to fix before
// setting or getting the value
cssProps: {
// normalize float css property
"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
},
// Get and set the style property on a DOM Node
style: function( elem, name, value, extra ) {
// Don't set styles on text and comment nodes
if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
return;
}
// Make sure that we're working with the right name
var ret, type, hooks,
origName = jQuery.camelCase( name ),
style = elem.style;
name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
// gets hook for the prefixed version
// followed by the unprefixed version
hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
// Check if we're setting a value
if ( value !== undefined ) {
type = typeof value;
// convert relative number strings (+= or -=) to relative numbers. #7345
if ( type === "string" && (ret = rrelNum.exec( value )) ) {
value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
// Fixes bug #9237
type = "number";
}
// Make sure that NaN and null values aren't set. See: #7116
if ( value == null || type === "number" && isNaN( value ) ) {
return;
}
// If a number was passed in, add 'px' to the (except for certain CSS properties)
if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
value += "px";
}
// If a hook was provided, use that value, otherwise just set the specified value
if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
// Fixes bug #5509
try {
style[ name ] = value;
} catch(e) {}
}
} else {
// If a hook was provided get the non-computed value from there
if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
return ret;
}
// Otherwise just get the value from the style object
return style[ name ];
}
},
css: function( elem, name, numeric, extra ) {
var val, num, hooks,
origName = jQuery.camelCase( name );
// Make sure that we're working with the right name
name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
// gets hook for the prefixed version
// followed by the unprefixed version
hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
// If a hook was provided get the computed value from there
if ( hooks && "get" in hooks ) {
val = hooks.get( elem, true, extra );
}
// Otherwise, if a way to get the computed value exists, use that
if ( val === undefined ) {
val = curCSS( elem, name );
}
//convert "normal" to computed value
if ( val === "normal" && name in cssNormalTransform ) {
val = cssNormalTransform[ name ];
}
// Return, converting to number if forced or a qualifier was provided and val looks numeric
if ( numeric || extra !== undefined ) {
num = parseFloat( val );
return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
}
return val;
},
// A method for quickly swapping in/out CSS properties to get correct calculations
swap: function( elem, options, callback ) {
var ret, name,
old = {};
// Remember the old values, and insert the new ones
for ( name in options ) {
old[ name ] = elem.style[ name ];
elem.style[ name ] = options[ name ];
}
ret = callback.call( elem );
// Revert the old values
for ( name in options ) {
elem.style[ name ] = old[ name ];
}
return ret;
}
});
// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
curCSS = function( elem, name ) {
var ret, width, minWidth, maxWidth,
computed = window.getComputedStyle( elem, null ),
style = elem.style;
if ( computed ) {
// getPropertyValue is only needed for .css('filter') in IE9, see #12537
ret = computed.getPropertyValue( name ) || computed[ name ];
if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
ret = jQuery.style( elem, name );
}
// A tribute to the "awesome hack by Dean Edwards"
// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
width = style.width;
minWidth = style.minWidth;
maxWidth = style.maxWidth;
style.minWidth = style.maxWidth = style.width = ret;
ret = computed.width;
style.width = width;
style.minWidth = minWidth;
style.maxWidth = maxWidth;
}
}
return ret;
};
} else if ( document.documentElement.currentStyle ) {
curCSS = function( elem, name ) {
var left, rsLeft,
ret = elem.currentStyle && elem.currentStyle[ name ],
style = elem.style;
// Avoid setting ret to empty string here
// so we don't default to auto
if ( ret == null && style && style[ name ] ) {
ret = style[ name ];
}
// From the awesome hack by Dean Edwards
// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
// If we're not dealing with a regular pixel number
// but a number that has a weird ending, we need to convert it to pixels
// but not position css attributes, as those are proportional to the parent element instead
// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {
// Remember the original values
left = style.left;
rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
// Put in the new values to get a computed value out
if ( rsLeft ) {
elem.runtimeStyle.left = elem.currentStyle.left;
}
style.left = name === "fontSize" ? "1em" : ret;
ret = style.pixelLeft + "px";
// Revert the changed values
style.left = left;
if ( rsLeft ) {
elem.runtimeStyle.left = rsLeft;
}
}
return ret === "" ? "auto" : ret;
};
}
function setPositiveNumber( elem, value, subtract ) {
var matches = rnumsplit.exec( value );
return matches ?
Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
value;
}
function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
var i = extra === ( isBorderBox ? "border" : "content" ) ?
// If we already have the right measurement, avoid augmentation
4 :
// Otherwise initialize for horizontal or vertical properties
name === "width" ? 1 : 0,
val = 0;
for ( ; i < 4; i += 2 ) {
// both box models exclude margin, so add it if we want it
if ( extra === "margin" ) {
// we use jQuery.css instead of curCSS here
// because of the reliableMarginRight CSS hook!
val += jQuery.css( elem, extra + cssExpand[ i ], true );
}
// From this point on we use curCSS for maximum performance (relevant in animations)
if ( isBorderBox ) {
// border-box includes padding, so remove it if we want content
if ( extra === "content" ) {
val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
}
// at this point, extra isn't border nor margin, so remove border
if ( extra !== "margin" ) {
val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
}
} else {
// at this point, extra isn't content, so add padding
val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
// at this point, extra isn't content nor padding, so add border
if ( extra !== "padding" ) {
val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
}
}
}
return val;
}
function getWidthOrHeight( elem, name, extra ) {
// Start with offset property, which is equivalent to the border-box value
var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
valueIsBorderBox = true,
isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";
// some non-html elements return undefined for offsetWidth, so check for null/undefined
// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
if ( val <= 0 || val == null ) {
// Fall back to computed then uncomputed css if necessary
val = curCSS( elem, name );
if ( val < 0 || val == null ) {
val = elem.style[ name ];
}
// Computed unit is not pixels. Stop here and return.
if ( rnumnonpx.test(val) ) {
return val;
}
// we need the check for style in case a browser which returns unreliable values
// for getComputedStyle silently falls back to the reliable elem.style
valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );
// Normalize "", auto, and prepare for extra
val = parseFloat( val ) || 0;
}
// use the active box-sizing model to add/subtract irrelevant styles
return ( val +
augmentWidthOrHeight(
elem,
name,
extra || ( isBorderBox ? "border" : "content" ),
valueIsBorderBox
)
) + "px";
}
// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
if ( elemdisplay[ nodeName ] ) {
return elemdisplay[ nodeName ];
}
var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
display = elem.css("display");
elem.remove();
// If the simple way fails,
// get element's real default display by attaching it to a temp iframe
if ( display === "none" || display === "" ) {
// Use the already-created iframe if possible
iframe = document.body.appendChild(
iframe || jQuery.extend( document.createElement("iframe"), {
frameBorder: 0,
width: 0,
height: 0
})
);
// Create a cacheable copy of the iframe document on first call.
// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
// document to it; WebKit & Firefox won't allow reusing the iframe document.
if ( !iframeDoc || !iframe.createElement ) {
iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
iframeDoc.write("<!doctype html><html><body>");
	iframeDoc.close();
	}
	elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );
	display = curCSS( elem, "display" );
	document.body.removeChild( iframe );
	}
	// Store the correct default display
	elemdisplay[ nodeName ] = display;
	return display;
	}
	jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
	get: function( elem, computed, extra ) {
	if ( computed ) {
	// certain elements can have dimension info if we invisibly show them
	// however, it must have a current display style that would benefit from this
	if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
	return jQuery.swap( elem, cssShow, function() {
	return getWidthOrHeight( elem, name, extra );
	});
	} else {
	return getWidthOrHeight( elem, name, extra );
	}
	}
	},
	set: function( elem, value, extra ) {
	return setPositiveNumber( elem, value, extra ?
	augmentWidthOrHeight(
	elem,
	name,
	extra,
	jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
	) : 0
	);
	}
	};
	});
	if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
	get: function( elem, computed ) {
	// IE uses filters for opacity
	return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
	( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
	computed ? "1" : "";
	},
	set: function( elem, value ) {
	var style = elem.style,
	currentStyle = elem.currentStyle,
	opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
	filter = currentStyle && currentStyle.filter || style.filter || "";
	// IE has trouble with opacity if it does not have layout
	// Force it by setting the zoom level
	style.zoom = 1;
	// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
	if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
	style.removeAttribute ) {
	// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
	// if "filter:" is present at all, clearType is disabled, we want to avoid this
	// style.removeAttribute is IE Only, but so apparently is this code path...
	style.removeAttribute( "filter" );
	// if there there is no filter style applied in a css rule, we are done
	if ( currentStyle && !currentStyle.filter ) {
	return;
	}
	}
	// otherwise, set new filter values
	style.filter = ralpha.test( filter ) ?
	filter.replace( ralpha, opacity ) :
	filter + " " + opacity;
	}
	};
	}
	// These hooks cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
	jQuery.cssHooks.marginRight = {
	get: function( elem, computed ) {
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	// Work around by temporarily setting element display to inline-block
	return jQuery.swap( elem, { "display": "inline-block" }, function() {
	if ( computed ) {
	return curCSS( elem, "marginRight" );
	}
	});
	}
	};
	}
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
	jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = {
	get: function( elem, computed ) {
	if ( computed ) {
	var ret = curCSS( elem, prop );
	// if curCSS returns percentage, fallback to offset
	return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
	}
	}
	};
	});
	}
	});
	if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
	return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
	};
	jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
	};
	}
	// These hooks are used by animate to expand properties
	jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
	}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
	expand: function( value ) {
	var i,
	// assumes a single number if not a string
	parts = typeof value === "string" ? value.split(" ") : [ value ],
	expanded = {};
	for ( i = 0; i < 4; i++ ) {
	expanded[ prefix + cssExpand[ i ] + suffix ] =
	parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
	}
	return expanded;
	}
	};
	if ( !rmargin.test( prefix ) ) {
	jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
	});
	var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;
	jQuery.fn.extend({
	serialize: function() {
	return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
	return this.map(function(){
	return this.elements ? jQuery.makeArray( this.elements ) : this;
	})
	.filter(function(){
	return this.name && !this.disabled &&
	( this.checked || rselectTextarea.test( this.nodeName ) ||
	rinput.test( this.type ) );
	})
	.map(function( i, elem ){
	var val = jQuery( this ).val();
	return val == null ?
	null :
	jQuery.isArray( val ) ?
	jQuery.map( val, function( val, i ){
	return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
	}) :
	{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
	}).get();
	}
	});
	//Serialize an array of form elements or a set of
	//key/values into a query string
	jQuery.param = function( a, traditional ) {
	var prefix,
	s = [],
	add = function( key, value ) {
	// If value is a function, invoke it and return its value
	value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
	s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
	};
	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
	traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}
	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	// Serialize the form elements
	jQuery.each( a, function() {
	add( this.name, this.value );
	});
	} else {
	// If traditional, encode the "old" way (the way 1.3.2 or older
	// did it), otherwise encode params recursively.
	for ( prefix in a ) {
	buildParams( prefix, a[ prefix ], traditional, add );
	}
	}
	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
	};
	function buildParams( prefix, obj, traditional, add ) {
	var name;
	if ( jQuery.isArray( obj ) ) {
	// Serialize array item.
	jQuery.each( obj, function( i, v ) {
	if ( traditional || rbracket.test( prefix ) ) {
	// Treat each array item as a scalar.
	add( prefix, v );
	} else {
	// If array item is non-scalar (array or object), encode its
	// numeric index to resolve deserialization ambiguity issues.
	// Note that rack (as of 1.0.0) can't currently deserialize
	// nested arrays properly, and attempting to do so may cause
	// a server error. Possible fixes are to modify rack's
	// deserialization algorithm or to provide an option or flag
	// to force array serialization to be shallow.
	buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
	}
	});
	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
	// Serialize object item.
	for ( name in obj ) {
	buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
	}
	} else {
	// Serialize scalar item.
	add( prefix, obj );
	}
	}
	var
	// Document location
	ajaxLocParts,
	ajaxLocation,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
	// Keep a copy of the old load method
	_load = jQuery.fn.load,
	/* Prefilters
	* 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	* 2) These are called:
	*    - BEFORE asking for a transport
	*    - AFTER param serialization (s.data is a string if s.processData is true)
	* 3) key is the dataType
	* 4) the catchall symbol "*" can be used
	* 5) execution will start with transport dataType and THEN continue down to "*" if needed
	*/
	prefilters = {},
	/* Transports bindings
	* 1) key is the dataType
	* 2) the catchall symbol "*" can be used
	* 3) selection will start with transport dataType and THEN go to "*" if needed
	*/
	transports = {},
	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];
	// #8138, IE may throw an exception when accessing
	// a field from window.location if document.domain has been set
	try {
	ajaxLocation = location.href;
	} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
	}
	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {
		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}
		var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
			i = 0,
			length = dataTypes.length;
		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
	}
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {
	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};
	inspected[ dataType ] = true;
	var selection,
		list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters );
	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
	}
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
	}
	jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}
	// Don't do a request if no elements are being requested
	if ( !this.length ) {
		return this;
	}
	var selector, type, response,
		self = this,
		off = url.indexOf(" ");
	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}
	// If it's a function
	if ( jQuery.isFunction( params ) ) {
		// We assume that it's the callback
		callback = params;
		params = undefined;
	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}
	// Request the remote document
	jQuery.ajax({
		url: url,
		// if "type" variable is undefined, then "GET" method will be used
		type: type,
		dataType: "html",
		data: params,
		complete: function( jqXHR, status ) {
			if ( callback ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			}
		}
	}).done(function( responseText ) {
		// Save response for use in complete callback
		response = arguments;
		// See if a selector was specified
		self.html( selector ?
			// Create a dummy div to hold the results
			jQuery("<div>")
													// inject the contents of the document in, removing the scripts
													// to avoid any 'Permission Denied' errors in IE
													.append( responseText.replace( rscript, "" ) )
													// Locate the specified elements
													.find( selector ) :
												// If not, just inject the full result
												responseText );
										});
										return this;
										};
										// Attach a bunch of functions for handling common AJAX events
										jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
										jQuery.fn[ o ] = function( f ){
											return this.on( o, f );
										};
										});
										jQuery.each( [ "get", "post" ], function( i, method ) {
										jQuery[ method ] = function( url, data, callback, type ) {
											// shift arguments if data argument was omitted
											if ( jQuery.isFunction( data ) ) {
												type = type || callback;
												callback = data;
												data = undefined;
											}
											return jQuery.ajax({
												type: method,
												url: url,
												data: data,
												success: callback,
												dataType: type
											});
										};
										});
										jQuery.extend({
										getScript: function( url, callback ) {
											return jQuery.get( url, undefined, callback, "script" );
										},
										getJSON: function( url, data, callback ) {
											return jQuery.get( url, data, callback, "json" );
										},
										// Creates a full fledged settings object into target
										// with both ajaxSettings and settings fields.
										// If target is omitted, writes into ajaxSettings.
										ajaxSetup: function( target, settings ) {
											if ( settings ) {
												// Building a settings object
												ajaxExtend( target, jQuery.ajaxSettings );
											} else {
												// Extending ajaxSettings
												settings = target;
												target = jQuery.ajaxSettings;
											}
											ajaxExtend( target, settings );
											return target;
										},
										ajaxSettings: {
											url: ajaxLocation,
											isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
											global: true,
											type: "GET",
											contentType: "application/x-www-form-urlencoded; charset=UTF-8",
											processData: true,
											async: true,
											/*
											timeout: 0,
											data: null,
											dataType: null,
											username: null,
											password: null,
											cache: null,
											throws: false,
											traditional: false,
											headers: {},
											*/
											accepts: {
												xml: "application/xml, text/xml",
												html: "text/html",
												text: "text/plain",
												json: "application/json, text/javascript",
												"*": allTypes
											},
											contents: {
												xml: /xml/,
												html: /html/,
												json: /json/
											},
											responseFields: {
												xml: "responseXML",
												text: "responseText"
											},
											// List of data converters
											// 1) key format is "source_type destination_type" (a single space in-between)
											// 2) the catchall symbol "*" can be used for source_type
											converters: {
												// Convert anything to text
												"* text": window.String,
												// Text to html (true = no transformation)
												"text html": true,
												// Evaluate text as a json expression
												"text json": jQuery.parseJSON,
												// Parse text as xml
												"text xml": jQuery.parseXML
											},
											// For options that shouldn't be deep extended:
											// you can add your own custom options here if
											// and when you create one that shouldn't be
											// deep extended (see ajaxExtend)
											flatOptions: {
												context: true,
												url: true
											}
										},
										ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
										ajaxTransport: addToPrefiltersOrTransports( transports ),
										// Main method
										ajax: function( url, options ) {
											// If url is an object, simulate pre-1.5 signature
											if ( typeof url === "object" ) {
												options = url;
												url = undefined;
											}
											// Force options to be an object
											options = options || {};
											var // ifModified key
												ifModifiedKey,
												// Response headers
												responseHeadersString,
												responseHeaders,
												// transport
												transport,
												// timeout handle
												timeoutTimer,
												// Cross-domain detection vars
												parts,
												// To know if global events are to be dispatched
												fireGlobals,
												// Loop variable
												i,
												// Create the final options object
												s = jQuery.ajaxSetup( {}, options ),
												// Callbacks context
												callbackContext = s.context || s,
												// Context for global events
												// It's the callbackContext if one was provided in the options
												// and if it's a DOM node or a jQuery collection
												globalEventContext = callbackContext !== s &&
													( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
															jQuery( callbackContext ) : jQuery.event,
												// Deferreds
												deferred = jQuery.Deferred(),
												completeDeferred = jQuery.Callbacks( "once memory" ),
												// Status-dependent callbacks
												statusCode = s.statusCode || {},
												// Headers (they are sent all at once)
												requestHeaders = {},
												requestHeadersNames = {},
												// The jqXHR state
												state = 0,
												// Default abort message
												strAbort = "canceled",
												// Fake xhr
												jqXHR = {
													readyState: 0,
													// Caches the header
													setRequestHeader: function( name, value ) {
														if ( !state ) {
															var lname = name.toLowerCase();
															name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
															requestHeaders[ name ] = value;
														}
														return this;
													},
													// Raw string
													getAllResponseHeaders: function() {
														return state === 2 ? responseHeadersString : null;
													},
													// Builds headers hashtable if needed
													getResponseHeader: function( key ) {
														var match;
														if ( state === 2 ) {
															if ( !responseHeaders ) {
																responseHeaders = {};
																while( ( match = rheaders.exec( responseHeadersString ) ) ) {
																	responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
																}
															}
															match = responseHeaders[ key.toLowerCase() ];
														}
														return match === undefined ? null : match;
													},
													// Overrides response content-type header
													overrideMimeType: function( type ) {
														if ( !state ) {
															s.mimeType = type;
														}
														return this;
													},
													// Cancel the request
													abort: function( statusText ) {
														statusText = statusText || strAbort;
														if ( transport ) {
															transport.abort( statusText );
														}
														done( 0, statusText );
														return this;
													}
												};
											// Callback for when everything is done
											// It is defined here because jslint complains if it is declared
											// at the end of the function (which would be more logical and readable)
											function done( status, nativeStatusText, responses, headers ) {
												var isSuccess, success, error, response, modified,
													statusText = nativeStatusText;
												// Called once
												if ( state === 2 ) {
													return;
												}
												// State is "done" now
												state = 2;
												// Clear timeout if it exists
												if ( timeoutTimer ) {
													clearTimeout( timeoutTimer );
												}
												// Dereference transport for early garbage collection
												// (no matter how long the jqXHR object will be used)
												transport = undefined;
												// Cache response headers
												responseHeadersString = headers || "";
												// Set readyState
												jqXHR.readyState = status > 0 ? 4 : 0;
												// Get response data
												if ( responses ) {
													response = ajaxHandleResponses( s, jqXHR, responses );
												}
												// If successful, handle type chaining
												if ( status >= 200 && status < 300 || status === 304 ) {
													// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
													if ( s.ifModified ) {
														modified = jqXHR.getResponseHeader("Last-Modified");
														if ( modified ) {
															jQuery.lastModified[ ifModifiedKey ] = modified;
														}
														modified = jqXHR.getResponseHeader("Etag");
														if ( modified ) {
															jQuery.etag[ ifModifiedKey ] = modified;
														}
													}
													// If not modified
													if ( status === 304 ) {
														statusText = "notmodified";
														isSuccess = true;
													// If we have data
													} else {
														isSuccess = ajaxConvert( s, response );
														statusText = isSuccess.state;
														success = isSuccess.data;
														error = isSuccess.error;
														isSuccess = !error;
													}
												} else {
													// We extract error from statusText
													// then normalize statusText and status for non-aborts
													error = statusText;
													if ( !statusText || status ) {
														statusText = "error";
														if ( status < 0 ) {
															status = 0;
														}
													}
												}
												// Set data for the fake xhr object
												jqXHR.status = status;
												jqXHR.statusText = ( nativeStatusText || statusText ) + "";
												// Success/Error
												if ( isSuccess ) {
													deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
												} else {
													deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
												}
												// Status-dependent callbacks
												jqXHR.statusCode( statusCode );
												statusCode = undefined;
												if ( fireGlobals ) {
													globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
															[ jqXHR, s, isSuccess ? success : error ] );
												}
												// Complete
												completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
												if ( fireGlobals ) {
													globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
													// Handle the global AJAX counter
													if ( !( --jQuery.active ) ) {
														jQuery.event.trigger( "ajaxStop" );
													}
												}
											}
											// Attach deferreds
											deferred.promise( jqXHR );
											jqXHR.success = jqXHR.done;
											jqXHR.error = jqXHR.fail;
											jqXHR.complete = completeDeferred.add;
											// Status-dependent callbacks
											jqXHR.statusCode = function( map ) {
												if ( map ) {
													var tmp;
													if ( state < 2 ) {
														for ( tmp in map ) {
															statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
														}
													} else {
														tmp = map[ jqXHR.status ];
														jqXHR.always( tmp );
													}
												}
												return this;
											};
											// Remove hash character (#7531: and string promotion)
											// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
											// We also use the url parameter if available
											s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
											// Extract dataTypes list
											s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );
											// A cross-domain request is in order when we have a protocol:host:port mismatch
											if ( s.crossDomain == null ) {
												parts = rurl.exec( s.url.toLowerCase() );
												s.crossDomain = !!( parts &&
													( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
														( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
															( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
												);
											}
											// Convert data if not already a string
											if ( s.data && s.processData && typeof s.data !== "string" ) {
												s.data = jQuery.param( s.data, s.traditional );
											}
											// Apply prefilters
											inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
											// If request was aborted inside a prefilter, stop there
											if ( state === 2 ) {
												return jqXHR;
											}
											// We can fire global events as of now if asked to
											fireGlobals = s.global;
											// Uppercase the type
											s.type = s.type.toUpperCase();
											// Determine if request has content
											s.hasContent = !rnoContent.test( s.type );
											// Watch for a new set of requests
											if ( fireGlobals && jQuery.active++ === 0 ) {
												jQuery.event.trigger( "ajaxStart" );
											}
											// More options handling for requests with no content
											if ( !s.hasContent ) {
												// If data is available, append data to url
												if ( s.data ) {
													s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
													// #9682: remove data so that it's not used in an eventual retry
													delete s.data;
												}
												// Get ifModifiedKey before adding the anti-cache parameter
												ifModifiedKey = s.url;
												// Add anti-cache in url if needed
												if ( s.cache === false ) {
													var ts = jQuery.now(),
														// try replacing _= if it is there
														ret = s.url.replace( rts, "$1_=" + ts );
													// if nothing was replaced, add timestamp to the end
													s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
												}
											}
											// Set the correct header, if data is being sent
											if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
												jqXHR.setRequestHeader( "Content-Type", s.contentType );
											}
											// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
											if ( s.ifModified ) {
												ifModifiedKey = ifModifiedKey || s.url;
												if ( jQuery.lastModified[ ifModifiedKey ] ) {
													jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
												}
												if ( jQuery.etag[ ifModifiedKey ] ) {
													jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
												}
											}
											// Set the Accepts header for the server, depending on the dataType
											jqXHR.setRequestHeader(
												"Accept",
												s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
													s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
													s.accepts[ "*" ]
											);
											// Check for headers option
											for ( i in s.headers ) {
												jqXHR.setRequestHeader( i, s.headers[ i ] );
											}
											// Allow custom headers/mimetypes and early abort
											if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
													// Abort if not done already and return
													return jqXHR.abort();
											}
											// aborting is no longer a cancellation
											strAbort = "abort";
											// Install callbacks on deferreds
											for ( i in { success: 1, error: 1, complete: 1 } ) {
												jqXHR[ i ]( s[ i ] );
											}
											// Get transport
											transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
											// If no transport, we auto-abort
											if ( !transport ) {
												done( -1, "No Transport" );
											} else {
												jqXHR.readyState = 1;
												// Send global event
												if ( fireGlobals ) {
													globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
												}
												// Timeout
												if ( s.async && s.timeout > 0 ) {
													timeoutTimer = setTimeout( function(){
														jqXHR.abort( "timeout" );
													}, s.timeout );
												}
												try {
													state = 1;
													transport.send( requestHeaders, done );
												} catch (e) {
													// Propagate exception as error if not done
													if ( state < 2 ) {
														done( -1, e );
													// Simply rethrow otherwise
													} else {
														throw e;
													}
												}
											}
											return jqXHR;
										},
										// Counter for holding the number of active queries
										active: 0,
										// Last-Modified header cache for next request
										lastModified: {},
										etag: {}
										});
										/* Handles responses to an ajax request:
										* - sets all responseXXX fields accordingly
										* - finds the right dataType (mediates between content-type and expected dataType)
										* - returns the corresponding response
										*/
										function ajaxHandleResponses( s, jqXHR, responses ) {
										var ct, type, finalDataType, firstDataType,
											contents = s.contents,
											dataTypes = s.dataTypes,
											responseFields = s.responseFields;
										// Fill responseXXX fields
										for ( type in responseFields ) {
											if ( type in responses ) {
												jqXHR[ responseFields[type] ] = responses[ type ];
											}
										}
										// Remove auto dataType and get content-type in the process
										while( dataTypes[ 0 ] === "*" ) {
											dataTypes.shift();
											if ( ct === undefined ) {
												ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
											}
										}
										// Check if we're dealing with a known content-type
										if ( ct ) {
											for ( type in contents ) {
												if ( contents[ type ] && contents[ type ].test( ct ) ) {
													dataTypes.unshift( type );
													break;
												}
											}
										}
										// Check to see if we have a response for the expected dataType
										if ( dataTypes[ 0 ] in responses ) {
											finalDataType = dataTypes[ 0 ];
										} else {
											// Try convertible dataTypes
											for ( type in responses ) {
												if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
													finalDataType = type;
													break;
												}
												if ( !firstDataType ) {
													firstDataType = type;
												}
											}
											// Or just use first one
											finalDataType = finalDataType || firstDataType;
										}
										// If we found a dataType
										// We add the dataType to the list if needed
										// and return the corresponding response
										if ( finalDataType ) {
											if ( finalDataType !== dataTypes[ 0 ] ) {
												dataTypes.unshift( finalDataType );
											}
											return responses[ finalDataType ];
										}
										}
										// Chain conversions given the request and the original response
										function ajaxConvert( s, response ) {
										var conv, conv2, current, tmp,
											// Work with a copy of dataTypes in case we need to modify it for conversion
											dataTypes = s.dataTypes.slice(),
											prev = dataTypes[ 0 ],
											converters = {},
											i = 0;
										// Apply the dataFilter if provided
										if ( s.dataFilter ) {
											response = s.dataFilter( response, s.dataType );
										}
										// Create converters map with lowercased keys
										if ( dataTypes[ 1 ] ) {
											for ( conv in s.converters ) {
												converters[ conv.toLowerCase() ] = s.converters[ conv ];
											}
										}
										// Convert to each sequential dataType, tolerating list modification
										for ( ; (current = dataTypes[++i]); ) {
											// There's only work to do if current dataType is non-auto
											if ( current !== "*" ) {
												// Convert response if prev dataType is non-auto and differs from current
												if ( prev !== "*" && prev !== current ) {
													// Seek a direct converter
													conv = converters[ prev + " " + current ] || converters[ "* " + current ];
													// If none found, seek a pair
													if ( !conv ) {
														for ( conv2 in converters ) {
															// If conv2 outputs current
															tmp = conv2.split(" ");
															if ( tmp[ 1 ] === current ) {
																// If prev can be converted to accepted input
																conv = converters[ prev + " " + tmp[ 0 ] ] ||
																	converters[ "* " + tmp[ 0 ] ];
																if ( conv ) {
																	// Condense equivalence converters
																	if ( conv === true ) {
																		conv = converters[ conv2 ];
																	// Otherwise, insert the intermediate dataType
																	} else if ( converters[ conv2 ] !== true ) {
																		current = tmp[ 0 ];
																		dataTypes.splice( i--, 0, current );
																	}
																	break;
																}
															}
														}
													}
													// Apply converter (if not an equivalence)
													if ( conv !== true ) {
														// Unless errors are allowed to bubble, catch and return them
														if ( conv && s["throws"] ) {
															response = conv( response );
														} else {
															try {
																response = conv( response );
															} catch ( e ) {
																return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
															}
														}
													}
												}
												// Update prev for next iteration
												prev = current;
											}
										}
										return { state: "success", data: response };
										}
										var oldCallbacks = [],
										rquestion = /\?/,
										rjsonp = /(=)\?(?=&|$)|\?\?/,
										nonce = jQuery.now();
										// Default jsonp settings
										jQuery.ajaxSetup({
										jsonp: "callback",
										jsonpCallback: function() {
											var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
											this[ callback ] = true;
											return callback;
										}
										});
										// Detect, normalize options and install callbacks for jsonp requests
										jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
										var callbackName, overwritten, responseContainer,
											data = s.data,
											url = s.url,
											hasCallback = s.jsonp !== false,
											replaceInUrl = hasCallback && rjsonp.test( url ),
											replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
												!( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
												rjsonp.test( data );
										// Handle iff the expected data type is "jsonp" or we have a parameter to set
										if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {
											// Get callback name, remembering preexisting value associated with it
											callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
												s.jsonpCallback() :
												s.jsonpCallback;
											overwritten = window[ callbackName ];
											// Insert callback into url or form data
											if ( replaceInUrl ) {
												s.url = url.replace( rjsonp, "$1" + callbackName );
											} else if ( replaceInData ) {
												s.data = data.replace( rjsonp, "$1" + callbackName );
											} else if ( hasCallback ) {
												s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
											}
											// Use data converter to retrieve json after script execution
											s.converters["script json"] = function() {
												if ( !responseContainer ) {
													jQuery.error( callbackName + " was not called" );
												}
												return responseContainer[ 0 ];
											};
											// force json dataType
											s.dataTypes[ 0 ] = "json";
											// Install callback
											window[ callbackName ] = function() {
												responseContainer = arguments;
											};
											// Clean-up function (fires after converters)
											jqXHR.always(function() {
												// Restore preexisting value
												window[ callbackName ] = overwritten;
												// Save back as free
												if ( s[ callbackName ] ) {
													// make sure that re-using the options doesn't screw things around
													s.jsonpCallback = originalSettings.jsonpCallback;
													// save the callback name for future use
													oldCallbacks.push( callbackName );
												}
												// Call if it was a function and we have a response
												if ( responseContainer && jQuery.isFunction( overwritten ) ) {
													overwritten( responseContainer[ 0 ] );
												}
												responseContainer = overwritten = undefined;
											});
											// Delegate to script
											return "script";
										}
										});
										// Install script dataType
										jQuery.ajaxSetup({
										accepts: {
											script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
										},
										contents: {
											script: /javascript|ecmascript/
										},
										converters: {
											"text script": function( text ) {
												jQuery.globalEval( text );
												return text;
											}
										}
										});
										// Handle cache's special case and global
										jQuery.ajaxPrefilter( "script", function( s ) {
										if ( s.cache === undefined ) {
											s.cache = false;
										}
										if ( s.crossDomain ) {
											s.type = "GET";
											s.global = false;
										}
										});
										// Bind script tag hack transport
										jQuery.ajaxTransport( "script", function(s) {
										// This transport only deals with cross domain requests
										if ( s.crossDomain ) {
											var script,
												head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
											return {
												send: function( _, callback ) {
													script = document.createElement( "script" );
													script.async = "async";
													if ( s.scriptCharset ) {
														script.charset = s.scriptCharset;
													}
													script.src = s.url;
													// Attach handlers for all browsers
													script.onload = script.onreadystatechange = function( _, isAbort ) {
														if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
															// Handle memory leak in IE
															script.onload = script.onreadystatechange = null;
															// Remove the script
															if ( head && script.parentNode ) {
																head.removeChild( script );
															}
															// Dereference the script
															script = undefined;
															// Callback if not abort
															if ( !isAbort ) {
																callback( 200, "success" );
															}
														}
													};
													// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
													// This arises when a base node is used (#2709 and #4378).
													head.insertBefore( script, head.firstChild );
												},
												abort: function() {
													if ( script ) {
														script.onload( 0, 1 );
													}
												}
											};
										}
										});
										var xhrCallbacks,
										// #5280: Internet Explorer will keep connections alive if we don't abort on unload
										xhrOnUnloadAbort = window.ActiveXObject ? function() {
											// Abort all pending requests
											for ( var key in xhrCallbacks ) {
												xhrCallbacks[ key ]( 0, 1 );
											}
										} : false,
										xhrId = 0;
										// Functions to create xhrs
										function createStandardXHR() {
										try {
											return new window.XMLHttpRequest();
										} catch( e ) {}
										}
										function createActiveXHR() {
										try {
											return new window.ActiveXObject( "Microsoft.XMLHTTP" );
										} catch( e ) {}
										}
										// Create the request object
										// (This is still attached to ajaxSettings for backward compatibility)
										jQuery.ajaxSettings.xhr = window.ActiveXObject ?
										/* Microsoft failed to properly
										* implement the XMLHttpRequest in IE7 (can't request local files),
										* so we use the ActiveXObject when it is available
										* Additionally XMLHttpRequest can be disabled in IE7/IE8 so
										* we need a fallback.
										*/
										function() {
											return !this.isLocal && createStandardXHR() || createActiveXHR();
										} :
										// For all other browsers, use the standard XMLHttpRequest object
										createStandardXHR;
										// Determine support properties
										(function( xhr ) {
										jQuery.extend( jQuery.support, {
											ajax: !!xhr,
											cors: !!xhr && ( "withCredentials" in xhr )
										});
										})( jQuery.ajaxSettings.xhr() );
										// Create transport if the browser can provide an xhr
										if ( jQuery.support.ajax ) {
										jQuery.ajaxTransport(function( s ) {
											// Cross domain only allowed if supported through XMLHttpRequest
											if ( !s.crossDomain || jQuery.support.cors ) {
												var callback;
												return {
													send: function( headers, complete ) {
														// Get a new xhr
														var handle, i,
															xhr = s.xhr();
														// Open the socket
														// Passing null username, generates a login popup on Opera (#2865)
														if ( s.username ) {
															xhr.open( s.type, s.url, s.async, s.username, s.password );
														} else {
															xhr.open( s.type, s.url, s.async );
														}
														// Apply custom fields if provided
														if ( s.xhrFields ) {
															for ( i in s.xhrFields ) {
																xhr[ i ] = s.xhrFields[ i ];
															}
														}
														// Override mime type if needed
														if ( s.mimeType && xhr.overrideMimeType ) {
															xhr.overrideMimeType( s.mimeType );
														}
														// X-Requested-With header
														// For cross-domain requests, seeing as conditions for a preflight are
														// akin to a jigsaw puzzle, we simply never set it to be sure.
														// (it can always be set on a per-request basis or even using ajaxSetup)
														// For same-domain requests, won't change header if already provided.
														if ( !s.crossDomain && !headers["X-Requested-With"] ) {
															headers[ "X-Requested-With" ] = "XMLHttpRequest";
														}
														// Need an extra try/catch for cross domain requests in Firefox 3
														try {
															for ( i in headers ) {
																xhr.setRequestHeader( i, headers[ i ] );
															}
														} catch( _ ) {}
														// Do send the request
														// This may raise an exception which is actually
														// handled in jQuery.ajax (so no try/catch here)
														xhr.send( ( s.hasContent && s.data ) || null );
														// Listener
														callback = function( _, isAbort ) {
															var status,
																statusText,
																responseHeaders,
																responses,
																xml;
															// Firefox throws exceptions when accessing properties
															// of an xhr when a network error occurred
															// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
															try {
																// Was never called and is aborted or complete
																if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
																	// Only called once
																	callback = undefined;
																	// Do not keep as active anymore
																	if ( handle ) {
																		xhr.onreadystatechange = jQuery.noop;
																		if ( xhrOnUnloadAbort ) {
																			delete xhrCallbacks[ handle ];
																		}
																	}
																	// If it's an abort
																	if ( isAbort ) {
																		// Abort it manually if needed
																		if ( xhr.readyState !== 4 ) {
																			xhr.abort();
																		}
																	} else {
																		status = xhr.status;
																		responseHeaders = xhr.getAllResponseHeaders();
																		responses = {};
																		xml = xhr.responseXML;
																		// Construct response list
																		if ( xml && xml.documentElement /* #4958 */ ) {
																			responses.xml = xml;
																		}
																		// When requesting binary data, IE6-9 will throw an exception
																		// on any attempt to access responseText (#11426)
																		try {
																			responses.text = xhr.responseText;
																		} catch( e ) {
																		}
																		// Firefox throws an exception when accessing
																		// statusText for faulty cross-domain requests
																		try {
																			statusText = xhr.statusText;
																		} catch( e ) {
																			// We normalize with Webkit giving an empty statusText
																			statusText = "";
																		}
																		// Filter status for non standard behaviors
																		// If the request is local and we have data: assume a success
																		// (success with no data won't get notified, that's the best we
																		// can do given current implementations)
																		if ( !status && s.isLocal && !s.crossDomain ) {
																			status = responses.text ? 200 : 404;
																		// IE - #1450: sometimes returns 1223 when it should be 204
																		} else if ( status === 1223 ) {
																			status = 204;
																		}
																	}
																}
															} catch( firefoxAccessException ) {
																if ( !isAbort ) {
																	complete( -1, firefoxAccessException );
																}
															}
															// Call complete if needed
															if ( responses ) {
																complete( status, statusText, responses, responseHeaders );
															}
														};
														if ( !s.async ) {
															// if we're in sync mode we fire the callback
															callback();
														} else if ( xhr.readyState === 4 ) {
															// (IE6 & IE7) if it's in cache and has been
															// retrieved directly we need to fire the callback
															setTimeout( callback, 0 );
														} else {
															handle = ++xhrId;
															if ( xhrOnUnloadAbort ) {
																// Create the active xhrs callbacks list if needed
																// and attach the unload handler
																if ( !xhrCallbacks ) {
																	xhrCallbacks = {};
																	jQuery( window ).unload( xhrOnUnloadAbort );
																}
																// Add to list of active xhrs callbacks
																xhrCallbacks[ handle ] = callback;
															}
															xhr.onreadystatechange = callback;
														}
													},
													abort: function() {
														if ( callback ) {
															callback(0,1);
														}
													}
												};
											}
										});
										}
										var fxNow, timerId,
										rfxtypes = /^(?:toggle|show|hide)$/,
										rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
										rrun = /queueHooks$/,
										animationPrefilters = [ defaultPrefilter ],
										tweeners = {
											"*": [function( prop, value ) {
												var end, unit,
													tween = this.createTween( prop, value ),
													parts = rfxnum.exec( value ),
													target = tween.cur(),
													start = +target || 0,
													scale = 1,
													maxIterations = 20;
												if ( parts ) {
													end = +parts[2];
													unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );
													// We need to compute starting value
													if ( unit !== "px" && start ) {
														// Iteratively approximate from a nonzero starting point
														// Prefer the current property, because this process will be trivial if it uses the same units
														// Fallback to end or a simple constant
														start = jQuery.css( tween.elem, prop, true ) || end || 1;
														do {
															// If previous iteration zeroed out, double until we get *something*
															// Use a string for doubling factor so we don't accidentally see scale as unchanged below
															scale = scale || ".5";
															// Adjust and apply
															start = start / scale;
															jQuery.style( tween.elem, prop, start + unit );
														// Update scale, tolerating zero or NaN from tween.cur()
														// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
														} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
													}
													tween.unit = unit;
													tween.start = start;
													// If a +=/-= token was provided, we're doing a relative animation
													tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
												}
												return tween;
											}]
										};
										// Animations created synchronously will run synchronously
										function createFxNow() {
										setTimeout(function() {
											fxNow = undefined;
										}, 0 );
										return ( fxNow = jQuery.now() );
										}
										function createTweens( animation, props ) {
										jQuery.each( props, function( prop, value ) {
											var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
												index = 0,
												length = collection.length;
											for ( ; index < length; index++ ) {
												if ( collection[ index ].call( animation, prop, value ) ) {
													// we're done with this property
													return;
												}
											}
										});
										}
										function Animation( elem, properties, options ) {
										var result,
											index = 0,
											tweenerIndex = 0,
											length = animationPrefilters.length,
											deferred = jQuery.Deferred().always( function() {
												// don't match elem in the :animated selector
												delete tick.elem;
											}),
											tick = function() {
												var currentTime = fxNow || createFxNow(),
													remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
													// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
													temp = remaining / animation.duration || 0,
													percent = 1 - temp,
													index = 0,
													length = animation.tweens.length;
												for ( ; index < length ; index++ ) {
													animation.tweens[ index ].run( percent );
												}
												deferred.notifyWith( elem, [ animation, percent, remaining ]);
												if ( percent < 1 && length ) {
													return remaining;
												} else {
													deferred.resolveWith( elem, [ animation ] );
													return false;
												}
											},
											animation = deferred.promise({
												elem: elem,
												props: jQuery.extend( {}, properties ),
												opts: jQuery.extend( true, { specialEasing: {} }, options ),
												originalProperties: properties,
												originalOptions: options,
												startTime: fxNow || createFxNow(),
												duration: options.duration,
												tweens: [],
												createTween: function( prop, end, easing ) {
													var tween = jQuery.Tween( elem, animation.opts, prop, end,
															animation.opts.specialEasing[ prop ] || animation.opts.easing );
													animation.tweens.push( tween );
													return tween;
												},
												stop: function( gotoEnd ) {
													var index = 0,
														// if we are going to the end, we want to run all the tweens
														// otherwise we skip this part
														length = gotoEnd ? animation.tweens.length : 0;
													for ( ; index < length ; index++ ) {
														animation.tweens[ index ].run( 1 );
													}
													// resolve when we played the last frame
													// otherwise, reject
													if ( gotoEnd ) {
														deferred.resolveWith( elem, [ animation, gotoEnd ] );
													} else {
														deferred.rejectWith( elem, [ animation, gotoEnd ] );
													}
													return this;
												}
											}),
											props = animation.props;
										propFilter( props, animation.opts.specialEasing );
										for ( ; index < length ; index++ ) {
											result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
											if ( result ) {
												return result;
											}
										}
										createTweens( animation, props );
										if ( jQuery.isFunction( animation.opts.start ) ) {
											animation.opts.start.call( elem, animation );
										}
										jQuery.fx.timer(
											jQuery.extend( tick, {
												anim: animation,
												queue: animation.opts.queue,
												elem: elem
											})
										);
										// attach callbacks from options
										return animation.progress( animation.opts.progress )
											.done( animation.opts.done, animation.opts.complete )
											.fail( animation.opts.fail )
											.always( animation.opts.always );
										}
										function propFilter( props, specialEasing ) {
										var index, name, easing, value, hooks;
										// camelCase, specialEasing and expand cssHook pass
										for ( index in props ) {
											name = jQuery.camelCase( index );
											easing = specialEasing[ name ];
											value = props[ index ];
											if ( jQuery.isArray( value ) ) {
												easing = value[ 1 ];
												value = props[ index ] = value[ 0 ];
											}
											if ( index !== name ) {
												props[ name ] = value;
												delete props[ index ];
											}
											hooks = jQuery.cssHooks[ name ];
											if ( hooks && "expand" in hooks ) {
												value = hooks.expand( value );
												delete props[ name ];
												// not quite $.extend, this wont overwrite keys already present.
												// also - reusing 'index' from above because we have the correct "name"
												for ( index in value ) {
													if ( !( index in props ) ) {
														props[ index ] = value[ index ];
														specialEasing[ index ] = easing;
													}
												}
											} else {
												specialEasing[ name ] = easing;
											}
										}
										}
										jQuery.Animation = jQuery.extend( Animation, {
										tweener: function( props, callback ) {
											if ( jQuery.isFunction( props ) ) {
												callback = props;
												props = [ "*" ];
											} else {
												props = props.split(" ");
											}
											var prop,
												index = 0,
												length = props.length;
											for ( ; index < length ; index++ ) {
												prop = props[ index ];
												tweeners[ prop ] = tweeners[ prop ] || [];
												tweeners[ prop ].unshift( callback );
											}
										},
										prefilter: function( callback, prepend ) {
											if ( prepend ) {
												animationPrefilters.unshift( callback );
											} else {
												animationPrefilters.push( callback );
											}
										}
										});
										function defaultPrefilter( elem, props, opts ) {
										var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
											anim = this,
											style = elem.style,
											orig = {},
											handled = [],
											hidden = elem.nodeType && isHidden( elem );
										// handle queue: false promises
										if ( !opts.queue ) {
											hooks = jQuery._queueHooks( elem, "fx" );
											if ( hooks.unqueued == null ) {
												hooks.unqueued = 0;
												oldfire = hooks.empty.fire;
												hooks.empty.fire = function() {
													if ( !hooks.unqueued ) {
														oldfire();
													}
												};
											}
											hooks.unqueued++;
											anim.always(function() {
												// doing this makes sure that the complete handler will be called
												// before this completes
												anim.always(function() {
													hooks.unqueued--;
													if ( !jQuery.queue( elem, "fx" ).length ) {
														hooks.empty.fire();
													}
												});
											});
										}
										// height/width overflow pass
										if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
											// Make sure that nothing sneaks out
											// Record all 3 overflow attributes because IE does not
											// change the overflow attribute when overflowX and
											// overflowY are set to the same value
											opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
											// Set display property to inline-block for height/width
											// animations on inline elements that are having width/height animated
											if ( jQuery.css( elem, "display" ) === "inline" &&
													jQuery.css( elem, "float" ) === "none" ) {
												// inline-level elements accept inline-block;
												// block-level elements need to be inline with layout
												if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
													style.display = "inline-block";
												} else {
													style.zoom = 1;
												}
											}
										}
										if ( opts.overflow ) {
											style.overflow = "hidden";
											if ( !jQuery.support.shrinkWrapBlocks ) {
												anim.done(function() {
													style.overflow = opts.overflow[ 0 ];
													style.overflowX = opts.overflow[ 1 ];
													style.overflowY = opts.overflow[ 2 ];
												});
											}
										}
										// show/hide pass
										for ( index in props ) {
											value = props[ index ];
											if ( rfxtypes.exec( value ) ) {
												delete props[ index ];
												toggle = toggle || value === "toggle";
												if ( value === ( hidden ? "hide" : "show" ) ) {
													continue;
												}
												handled.push( index );
											}
										}
										length = handled.length;
										if ( length ) {
											dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
											if ( "hidden" in dataShow ) {
												hidden = dataShow.hidden;
											}
											// store state if its toggle - enables .stop().toggle() to "reverse"
											if ( toggle ) {
												dataShow.hidden = !hidden;
											}
											if ( hidden ) {
												jQuery( elem ).show();
											} else {
												anim.done(function() {
													jQuery( elem ).hide();
												});
											}
											anim.done(function() {
												var prop;
												jQuery.removeData( elem, "fxshow", true );
												for ( prop in orig ) {
													jQuery.style( elem, prop, orig[ prop ] );
												}
											});
											for ( index = 0 ; index < length ; index++ ) {
												prop = handled[ index ];
												tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
												orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );
												if ( !( prop in dataShow ) ) {
													dataShow[ prop ] = tween.start;
													if ( hidden ) {
														tween.end = tween.start;
														tween.start = prop === "width" || prop === "height" ? 1 : 0;
													}
												}
											}
										}
										}
										function Tween( elem, options, prop, end, easing ) {
										return new Tween.prototype.init( elem, options, prop, end, easing );
										}
										jQuery.Tween = Tween;
										Tween.prototype = {
										constructor: Tween,
										init: function( elem, options, prop, end, easing, unit ) {
											this.elem = elem;
											this.prop = prop;
											this.easing = easing || "swing";
											this.options = options;
											this.start = this.now = this.cur();
											this.end = end;
											this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
										},
										cur: function() {
											var hooks = Tween.propHooks[ this.prop ];
											return hooks && hooks.get ?
												hooks.get( this ) :
												Tween.propHooks._default.get( this );
										},
										run: function( percent ) {
											var eased,
												hooks = Tween.propHooks[ this.prop ];
											if ( this.options.duration ) {
												this.pos = eased = jQuery.easing[ this.easing ](
													percent, this.options.duration * percent, 0, 1, this.options.duration
												);
											} else {
												this.pos = eased = percent;
											}
											this.now = ( this.end - this.start ) * eased + this.start;
											if ( this.options.step ) {
												this.options.step.call( this.elem, this.now, this );
											}
											if ( hooks && hooks.set ) {
												hooks.set( this );
											} else {
												Tween.propHooks._default.set( this );
											}
											return this;
										}
										};
										Tween.prototype.init.prototype = Tween.prototype;
										Tween.propHooks = {
										_default: {
											get: function( tween ) {
												var result;
												if ( tween.elem[ tween.prop ] != null &&
													(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
													return tween.elem[ tween.prop ];
												}
												// passing any value as a 4th parameter to .css will automatically
												// attempt a parseFloat and fallback to a string if the parse fails
												// so, simple values such as "10px" are parsed to Float.
												// complex values such as "rotate(1rad)" are returned as is.
												result = jQuery.css( tween.elem, tween.prop, false, "" );
												// Empty strings, null, undefined and "auto" are converted to 0.
												return !result || result === "auto" ? 0 : result;
											},
											set: function( tween ) {
												// use step hook for back compat - use cssHook if its there - use .style if its
												// available and use plain properties where available
												if ( jQuery.fx.step[ tween.prop ] ) {
													jQuery.fx.step[ tween.prop ]( tween );
												} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
													jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
												} else {
													tween.elem[ tween.prop ] = tween.now;
												}
											}
										}
										};
										// Remove in 2.0 - this supports IE8's panic based approach
										// to setting things on disconnected nodes
										Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
										set: function( tween ) {
											if ( tween.elem.nodeType && tween.elem.parentNode ) {
												tween.elem[ tween.prop ] = tween.now;
											}
										}
										};
										jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
										var cssFn = jQuery.fn[ name ];
										jQuery.fn[ name ] = function( speed, easing, callback ) {
											return speed == null || typeof speed === "boolean" ||
												// special check for .toggle( handler, handler, ... )
												( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
												cssFn.apply( this, arguments ) :
												this.animate( genFx( name, true ), speed, easing, callback );
										};
										});
										jQuery.fn.extend({
										fadeTo: function( speed, to, easing, callback ) {
											// show any hidden elements after setting opacity to 0
											return this.filter( isHidden ).css( "opacity", 0 ).show()
												// animate to the value specified
												.end().animate({ opacity: to }, speed, easing, callback );
										},
										animate: function( prop, speed, easing, callback ) {
											var empty = jQuery.isEmptyObject( prop ),
												optall = jQuery.speed( speed, easing, callback ),
												doAnimation = function() {
													// Operate on a copy of prop so per-property easing won't be lost
													var anim = Animation( this, jQuery.extend( {}, prop ), optall );
													// Empty animations resolve immediately
													if ( empty ) {
														anim.stop( true );
													}
												};
											return empty || optall.queue === false ?
												this.each( doAnimation ) :
												this.queue( optall.queue, doAnimation );
										},
										stop: function( type, clearQueue, gotoEnd ) {
											var stopQueue = function( hooks ) {
												var stop = hooks.stop;
												delete hooks.stop;
												stop( gotoEnd );
											};
											if ( typeof type !== "string" ) {
												gotoEnd = clearQueue;
												clearQueue = type;
												type = undefined;
											}
											if ( clearQueue && type !== false ) {
												this.queue( type || "fx", [] );
											}
											return this.each(function() {
												var dequeue = true,
													index = type != null && type + "queueHooks",
													timers = jQuery.timers,
													data = jQuery._data( this );
												if ( index ) {
													if ( data[ index ] && data[ index ].stop ) {
														stopQueue( data[ index ] );
													}
												} else {
													for ( index in data ) {
														if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
															stopQueue( data[ index ] );
														}
													}
												}
												for ( index = timers.length; index--; ) {
													if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
														timers[ index ].anim.stop( gotoEnd );
														dequeue = false;
														timers.splice( index, 1 );
													}
												}
												// start the next in the queue if the last step wasn't forced
												// timers currently will call their complete callbacks, which will dequeue
												// but only if they were gotoEnd
												if ( dequeue || !gotoEnd ) {
													jQuery.dequeue( this, type );
												}
											});
										}
										});
										// Generate parameters to create a standard animation
										function genFx( type, includeWidth ) {
										var which,
											attrs = { height: type },
											i = 0;
										// if we include width, step value is 1 to do all cssExpand values,
										// if we don't include width, step value is 2 to skip over Left and Right
										includeWidth = includeWidth? 1 : 0;
										for( ; i < 4 ; i += 2 - includeWidth ) {
											which = cssExpand[ i ];
											attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
										}
										if ( includeWidth ) {
											attrs.opacity = attrs.width = type;
										}
										return attrs;
										}
										// Generate shortcuts for custom animations
										jQuery.each({
										slideDown: genFx("show"),
										slideUp: genFx("hide"),
										slideToggle: genFx("toggle"),
										fadeIn: { opacity: "show" },
										fadeOut: { opacity: "hide" },
										fadeToggle: { opacity: "toggle" }
										}, function( name, props ) {
										jQuery.fn[ name ] = function( speed, easing, callback ) {
											return this.animate( props, speed, easing, callback );
										};
										});
										jQuery.speed = function( speed, easing, fn ) {
										var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
											complete: fn || !fn && easing ||
												jQuery.isFunction( speed ) && speed,
											duration: speed,
											easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
										};
										opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
											opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
										// normalize opt.queue - true/undefined/null -> "fx"
										if ( opt.queue == null || opt.queue === true ) {
											opt.queue = "fx";
										}
										// Queueing
										opt.old = opt.complete;
										opt.complete = function() {
											if ( jQuery.isFunction( opt.old ) ) {
												opt.old.call( this );
											}
											if ( opt.queue ) {
												jQuery.dequeue( this, opt.queue );
											}
										};
										return opt;
										};
										jQuery.easing = {
										linear: function( p ) {
											return p;
										},
										swing: function( p ) {
											return 0.5 - Math.cos( p*Math.PI ) / 2;
										}
										};
										jQuery.timers = [];
										jQuery.fx = Tween.prototype.init;
										jQuery.fx.tick = function() {
										var timer,
											timers = jQuery.timers,
											i = 0;
										fxNow = jQuery.now();
										for ( ; i < timers.length; i++ ) {
											timer = timers[ i ];
											// Checks the timer has not already been removed
											if ( !timer() && timers[ i ] === timer ) {
												timers.splice( i--, 1 );
											}
										}
										if ( !timers.length ) {
											jQuery.fx.stop();
										}
										fxNow = undefined;
										};
										jQuery.fx.timer = function( timer ) {
										if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
											timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
										}
										};
										jQuery.fx.interval = 13;
										jQuery.fx.stop = function() {
										clearInterval( timerId );
										timerId = null;
										};
										jQuery.fx.speeds = {
										slow: 600,
										fast: 200,
										// Default speed
										_default: 400
										};
										// Back Compat <1.8 extension point
										jQuery.fx.step = {};
										if ( jQuery.expr && jQuery.expr.filters ) {
										jQuery.expr.filters.animated = function( elem ) {
											return jQuery.grep(jQuery.timers, function( fn ) {
												return elem === fn.elem;
											}).length;
										};
										}
										var rroot = /^(?:body|html)$/i;
										jQuery.fn.offset = function( options ) {
										if ( arguments.length ) {
											return options === undefined ?
												this :
												this.each(function( i ) {
													jQuery.offset.setOffset( this, options, i );
												});
										}
										var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
											box = { top: 0, left: 0 },
											elem = this[ 0 ],
											doc = elem && elem.ownerDocument;
										if ( !doc ) {
											return;
										}
										if ( (body = doc.body) === elem ) {
											return jQuery.offset.bodyOffset( elem );
										}
										docElem = doc.documentElement;
										// Make sure it's not a disconnected DOM node
										if ( !jQuery.contains( docElem, elem ) ) {
											return box;
										}
										// If we don't have gBCR, just use 0,0 rather than error
										// BlackBerry 5, iOS 3 (original iPhone)
										if ( typeof elem.getBoundingClientRect !== "undefined" ) {
											box = elem.getBoundingClientRect();
										}
										win = getWindow( doc );
										clientTop  = docElem.clientTop  || body.clientTop  || 0;
										clientLeft = docElem.clientLeft || body.clientLeft || 0;
										scrollTop  = win.pageYOffset || docElem.scrollTop;
										scrollLeft = win.pageXOffset || docElem.scrollLeft;
										return {
											top: box.top  + scrollTop  - clientTop,
											left: box.left + scrollLeft - clientLeft
										};
										};
										jQuery.offset = {
										bodyOffset: function( body ) {
											var top = body.offsetTop,
												left = body.offsetLeft;
											if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
												top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
												left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
											}
											return { top: top, left: left };
										},
										setOffset: function( elem, options, i ) {
											var position = jQuery.css( elem, "position" );
											// set position first, in-case top/left are set even on static elem
											if ( position === "static" ) {
												elem.style.position = "relative";
											}
											var curElem = jQuery( elem ),
												curOffset = curElem.offset(),
												curCSSTop = jQuery.css( elem, "top" ),
												curCSSLeft = jQuery.css( elem, "left" ),
												calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
												props = {}, curPosition = {}, curTop, curLeft;
											// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
											if ( calculatePosition ) {
												curPosition = curElem.position();
												curTop = curPosition.top;
												curLeft = curPosition.left;
											} else {
												curTop = parseFloat( curCSSTop ) || 0;
												curLeft = parseFloat( curCSSLeft ) || 0;
											}
											if ( jQuery.isFunction( options ) ) {
												options = options.call( elem, i, curOffset );
											}
											if ( options.top != null ) {
												props.top = ( options.top - curOffset.top ) + curTop;
											}
											if ( options.left != null ) {
												props.left = ( options.left - curOffset.left ) + curLeft;
											}
											if ( "using" in options ) {
												options.using.call( elem, props );
											} else {
												curElem.css( props );
											}
										}
										};
										jQuery.fn.extend({
										position: function() {
											if ( !this[0] ) {
												return;
											}
											var elem = this[0],
											// Get *real* offsetParent
											offsetParent = this.offsetParent(),
											// Get correct offsets
											offset       = this.offset(),
											parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
											// Subtract element margins
											// note: when an element has margin: auto the offsetLeft and marginLeft
											// are the same in Safari causing offset.left to incorrectly be 0
											offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
											offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;
											// Add offsetParent borders
											parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
											parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;
											// Subtract the two offsets
											return {
												top:  offset.top  - parentOffset.top,
												left: offset.left - parentOffset.left
											};
										},
										offsetParent: function() {
											return this.map(function() {
												var offsetParent = this.offsetParent || document.body;
												while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
													offsetParent = offsetParent.offsetParent;
												}
												return offsetParent || document.body;
											});
										}
										});
										// Create scrollLeft and scrollTop methods
										jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
										var top = /Y/.test( prop );
										jQuery.fn[ method ] = function( val ) {
											return jQuery.access( this, function( elem, method, val ) {
												var win = getWindow( elem );
												if ( val === undefined ) {
													return win ? (prop in win) ? win[ prop ] :
														win.document.documentElement[ method ] :
														elem[ method ];
												}
												if ( win ) {
													win.scrollTo(
														!top ? val : jQuery( win ).scrollLeft(),
														top ? val : jQuery( win ).scrollTop()
													);
												} else {
													elem[ method ] = val;
												}
											}, method, val, arguments.length, null );
										};
										});
										function getWindow( elem ) {
										return jQuery.isWindow( elem ) ?
											elem :
											elem.nodeType === 9 ?
												elem.defaultView || elem.parentWindow :
												false;
										}
										// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
										jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
										jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
											// margin is only for outerHeight, outerWidth
											jQuery.fn[ funcName ] = function( margin, value ) {
												var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
													extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
												return jQuery.access( this, function( elem, type, value ) {
													var doc;
													if ( jQuery.isWindow( elem ) ) {
														// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
														// isn't a whole lot we can do. See pull request at this URL for discussion:
														// https://github.com/jquery/jquery/pull/764
														return elem.document.documentElement[ "client" + name ];
													}
													// Get document width or height
													if ( elem.nodeType === 9 ) {
														doc = elem.documentElement;
														// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
														// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
														return Math.max(
															elem.body[ "scroll" + name ], doc[ "scroll" + name ],
															elem.body[ "offset" + name ], doc[ "offset" + name ],
															doc[ "client" + name ]
														);
													}
													return value === undefined ?
														// Get width or height on the element, requesting but not forcing parseFloat
														jQuery.css( elem, type, value, extra ) :
														// Set width or height on the element
														jQuery.style( elem, type, value, extra );
												}, type, chainable ? margin : undefined, chainable, null );
											};
										});
										});
										// Expose jQuery to the global object
										window.jQuery = window.$ = jQuery;
										// Expose jQuery as an AMD module, but only for AMD loaders that
										// understand the issues with loading multiple versions of jQuery
										// in a page that all might call define(). The loader will indicate
										// they have special allowances for multiple jQuery versions by
										// specifying define.amd.jQuery = true. Register as a named module,
										// since jQuery can be concatenated with other files that may use define,
										// but not use a proper concatenation script that understands anonymous
										// AMD modules. A named AMD is safest and most robust way to register.
										// Lowercase jquery is used because AMD module names are derived from
										// file names, and jQuery is normally delivered in a lowercase file name.
										// Do this after creating the global so that if an AMD module wants to call
										// noConflict to hide this version of jQuery, it will work.
										if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
										define( "jquery", [], function () { return jQuery; } );
										}
										})( window );
		</script>
		<script type="text/javascript">
			$(document).ready(function(){
		$('#reset').click(function(){
		window.location = window.location.href;
		})
		$wordcnt=0;
		$spcnt=0;
		$charcnt=0;
			$chk=0;
		$('#res').hide();
		$tcount = 60;
		$shocnt=0;
		$('#ans').attr('placeholder','Click here to start');
		$('#ans').click(function(){
		if($shocnt<1){
			$('#ans').attr('placeholder','Type here');
		$shocnt++;
		$('#counter').show();
		setInterval(function t(){
		$tcount--;
		if($tcount==00)
		{
		$('#words').hide();
		$('#inp').hide();
		$('#res').show();
		$wpm=$('#wcnt').html();
		$waccr=$('#waccr').html();
		$wkeystroke=$('#wccnt').html();
		$getres="Wow! I can type "+$wpm+" words per minute! My accuracy rate is "+$waccr+". Can you beat me? Click on Type Speed link to test yourself.";

		clearTimeout(t);
		$('#count').hide();

		}
		$('#counter').html($tcount);
		},1000);
		}
		})

		$('#ans').keyup(function(){$vari=$(this).val();
		if($vari==" ")
			$(this).val("");
		})
		$main=["the","be","and","of","a","in","to","have","to","it","I","that","for","you","he","with","on","do","say","this","they","at","but","we","his","from","that","not","by","she","or","as","what","go","their","can","who","get","if","would","her","all","my","make","about","know","will","as","up","one","time","there","year","so","think","when","which","them","some","me","people","take","out","into","just","see","him","your","come","could","now","than","like","other","how","then","its","our","two","more","these","want","way","look","first","also","new","because","day","more","use","no","man","find","here","thing","give","many","well","only","those","tell","one","very","her","even","back","any","good","woman","through","us","life","child","there","work","down","may","after","should","call","world","over","school","still","try","in","as","last","ask","need","too","feel","three","when","state","never","become","between","high","really","something","most","another","much","family","own","out","leave","put","old","while","mean","on","keep","student","why","let","great","same","big","group","begin","seem","country","help","talk","where","turn","problem","every","start","hand","might","American","show","part","about","against","place","over","such","again","few","case","most","week","company","where","system","each","right","program","hear","so","question","during","work","play","government","run","small","number","off","always","move","like","night","live","Mr","point","believe","hold","today","bring","happen","next","without","before","large","all","million","must","home","under","water","room","write","mother","area","national","money","story","young","fact","month","different","lot","right","study","book","eye","job","word","though","business","issue","side","kind","four","head","far","black","long","both","little","house","yes","after","since","long","provide","service","around","friend","important","father","sit","away","until","power","hour","game","often","yet","line","political","end","among","ever","stand","bad","lose","however","member","pay","law","meet","car","city","almost","include","continue","set","later","community","much","name","five","once","white","least","president","learn","real","change","team","minute","best","several","idea","kid","body","information","nothing","ago","right","lead","social","understand","whether","back","watch","together","follow","around","parent","only","stop","face","anything","create","public","already","speak","others","read","level","allow","add","office","spend","door","health","person","art","sure","such","war","history","party","within","grow","result","open","change","morning","walk","reason","low","win","research","girl","guy","early","food","before","moment","himself","air","teacher","force","offer","enough","both","education","across","although","remember","foot","second","boy","maybe","toward","able","age","off","policy","everything","love","process","music","including","consider","appear","actually","buy","probably","human","wait","serve","market","die","send","expect","home","sense","build","stay","fall","oh","nation","plan","cut","college","interest","death","course","someone","experience","behind","reach","local","kill","six","remain","effect","use","yeah","suggest","class","control","raise","care","perhaps","little","late","hard","field","else","pass","former","sell","major","sometimes","require","along","development","themselves","report","role","better","economic","effort","up","decide","rate","strong","possible","heart","drug","show","leader","light","voice","wife","whole","police","mind","finally","pull","return","free","military","price","report","less","according","decision","explain","son","hope","even","develop","view","relationship","carry","town","road","drive","arm","true","federal","break","better","difference","thank","receive","value","international","building","action","full","model","join","season","society","because","tax","director","early","position","player","agree","especially","record","pick","wear","paper","special","space","ground","form","support","event","official","whose","matter","everyone","center","couple","site","end","project","hit","base","activity","star","table","need","court","produce","eat","American","teach","oil","half","situation","easy","cost","industry","figure","face","street","image","itself","phone","either","data","cover","quite","picture","clear","practice","piece","land","recent","describe","product","doctor","wall","patient","worker","news","test","movie","certain","north","love","personal","open","support","simply","third","technology","catch","step","baby","computer","type","attention","draw","film","Republican","tree","source","red","nearly","organization","choose","cause","hair","look","point","century","evidence","window","difficult","listen","soon","culture","billion","chance","brother","energy","period","course","summer","less","realize","hundred","available","plant","likely","opportunity","term","short","letter","condition","choice","place","single","rule","daughter","administration","south","husband","Congress","floor","campaign","material","population","well","call","economy","medical","hospital","church","close","thousand","risk","current","fire","future","wrong","involve","defense","anyone","increase","security","bank","myself","certainly","west","sport","board","seek","per","subject","officer","private","rest","behavior","deal","performance","fight","throw","top","quickly","past","goal","second","bed","order","author","fill","represent","focus","foreign","drop","plan","blood","upon","agency","push","nature","color","no","recently","store","reduce","sound","note","fine","before","near","movement","page","enter","share","than","common","poor","other","natural","race","concern","series","significant","similar","hot","language","each","usually","response","dead","rise","animal","factor","decade","article","shoot","east","save","seven","artist","away","scene","stock","career","despite","central","eight","thus","treatment","beyond","happy","exactly","protect","approach","lie","size","dog","fund","serious","occur","media","ready","sign","thought","list","individual","simple","quality","pressure","accept","answer","hard","resource","identify","left","meeting","determine","prepare","disease","whatever","success","argue","cup","particularly","amount","ability","staff","recognize","indicate","character","growth","loss","degree","wonder","attack","herself","region","television","box","TV","training","pretty","trade","deal","election","everybody","physical","lay","general","feeling","standard","bill","message","fail","outside","arrive","analysis","benefit","name","sex","forward","lawyer","present","section","environmental","glass","answer","skill","sister","PM","professor","operation","financial","crime","stage","ok","compare","authority","miss","design","sort","one","act","ten","knowledge","gun","station","blue","state","strategy","little","clearly","discuss","indeed","force","truth","song","example","democratic","check","environment","leg","dark","public","various","rather","laugh","guess","executive","set","study","prove","hang","entire","rock","design","enough","forget","since","claim","note","remove","manager","help","close","sound","enjoy","network","legal","religious","cold","form","final","main","science","green","memory","card","above","seat","cell","establish","nice","trial","expert","that","spring","firm","Democrat","radio","visit","management","care","avoid","imagine","tonight","huge","ball","no","close","finish","yourself","talk","theory","impact","respond","statement","maintain","charge","popular","traditional","onto","reveal","direction","weapon","employee","cultural","contain","peace","head","control","base","pain","apply","play","measure","wide","shake","fly","interview","manage","chair","fish","particular","camera","structure","politics","perform","bit","weight","suddenly","discover","candidate","top","production","treat","trip","evening","affect","inside","conference","unit","best","style","adult","worry","range","mention","rather","far","deep","past","edge","individual","specific","writer","trouble","necessary","throughout","challenge","fear","shoulder","institution","middle","sea","dream","bar","beautiful","property","instead","improve","stuff","detail","method","sign","somebody","magazine","hotel","soldier","reflect","heavy","sexual","cause","bag","heat","fall","marriage","tough","sing","surface","purpose","exist","pattern","whom","skin","agent","owner","machine","gas","down","ahead","generation","commercial","address","cancer","test","item","reality","coach","step","Mrs","yard","beat","violence","total","tend","investment","discussion","finger","garden","notice","collection","modern","task","partner","positive","civil","kitchen","consumer","shot","budget","wish","painting","scientist","safe","agreement","capital","mouth","nor","victim","newspaper","instead","threat","responsibility","smile","attorney","score","account","interesting","break","audience","rich","dinner","figure","vote","western","relate","travel","debate","prevent","citizen","majority","none","front","born","admit","senior","assume","wind","key","professional","mission","fast","alone","customer","suffer","speech","successful","option","participant","southern","fresh","eventually","no","forest","video","global","Senate","reform","access","restaurant","judge","publish","cost","relation","like","release","own","bird","opinion","credit","critical","corner","concerned","recall","version","stare","safety","effective","neighborhood","original","act","troop","income","directly","hurt","species","immediately","track","basic","strike","hope","sky","freedom","absolutely","plane","nobody","achieve","object","attitude","labor","refer","concept","client","powerful","perfect","nine","therefore","conduct","announce","conversation","examine","touch","please","attend","completely","vote","variety","sleep","turn","involved","investigation","nuclear","researcher","press","conflict","spirit","experience","replace","British","encourage","lot","lot","lot","lot","argument","by","once","camp","brain","feature","afternoon","AM","weekend","dozen","possibility","along","insurance","department","battle","beginning","date","generally","African","very","sorry","crisis","complete","fan","stick","define","easily","through","hole","element","vision","status","normal","Chinese","ship","solution","stone","slowly","scale","bit","university","introduce","driver","attempt","park","spot","lack","ice","boat","drink","sun","front","distance","wood","handle","truck","return","mountain","survey","supposed","tradition","winter","village","Soviet","refuse","sales","roll","communication","run","screen","gain","resident","hide","gold","club","future","farm","potential","increase","middle","European","presence","independent","district","shape","reader","Ms","contract","crowd","Christian","express","apartment","willing","strength","previous","band","obviously","horse","interested","target","prison","ride","guard","terms","demand","reporter","deliver","text","share","tool","wild","vehicle","observe","flight","inside","facility","understanding","average","emerge","advantage","quick","light","leadership","earn","pound","basis","bright","operate","guest","sample","contribute","tiny","block","protection","settle","feed","collect","additional","while","highly","identity","title","mostly","lesson","faith","river","promote","living","present","count","unless","marry","tomorrow","technique","path","ear","shop","folk","order","principle","survive","lift","border","competition","jump","gather","limit","fit","claim","cry","equipment","worth","associate","critic","warm","aspect","result","insist","failure","annual","French","Christmas","comment","responsible","affair","approach","until","procedure","regular","spread","chairman","baseball","soft","ignore","egg","measure","belief","demonstrate","anybody","murder","gift","religion","review","editor","past","engage","coffee","document","speed","cross","influence","anyway","threaten","commit","female","youth","wave","move","afraid","quarter","background","native","broad","wonderful","deny","apparently","slightly","reaction","twice","suit","perspective","growing","blow","construction","kind","intelligence","destroy","cook","connection","charge","burn","shoe","view","grade","context","committee","hey","mistake","focus","smile","location","clothes","Indian","quiet","dress","promise","aware","neighbor","complete","drive","function","bone","active","extend","chief","average","combine","wine","below","cool","voter","mean","demand","learning","bus","hell","dangerous","remind","moral","United","category","relatively","victory","key","academic","visit","Internet","healthy","fire","negative","following","historical","medicine","tour","depend","photo","finding","grab","direct","classroom","contact","justice","participate","daily","fair","pair","famous","exercise","knee","flower","tape","hire","familiar","appropriate","supply","fully","cut","will","actor","birth","search","tie","democracy","eastern","primary","yesterday","circle","device","progress","next","front","bottom","island","exchange","clean","studio","train","lady","colleague","application","neck","lean","damage","plastic","tall","plate","hate","otherwise","writing","press","male","start","alive","expression","football","intend","attack","chicken","army","abuse","theater","shut","map","extra","session","danger","welcome","domestic","lots","literature","rain","desire","assessment","injury","respect","northern","nod","paint","fuel","leaf","direct","dry","Russian","instruction","fight","pool","climb","sweet","lead","engine","fourth","salt","expand","importance","metal","fat","ticket","software","disappear","corporate","strange","lip","reading","urban","mental","increasingly","lunch","educational","somewhere","farmer","above","sugar","planet","favorite","explore","obtain","enemy","greatest","complex","surround","athlete","invite","repeat","carefully","soul","scientific","impossible","panel","meaning","mom","married","alone","instrument","predict","weather","presidential","emotional","commitment","Supreme","bear","pocket","thin","temperature","surprise","poll","proposal","consequence","half","breath","sight","cover","balance","adopt","minority","straight","attempt","connect","works","teaching","belong","aid","advice","okay","photograph","empty","regional","trail","novel","code","somehow","organize","jury","breast","Iraqi","human","acknowledge","theme","storm","union","record","desk","fear","thanks","fruit","under","expensive","yellow","conclusion","prime","shadow","struggle","conclude","analyst","dance","limit","like","regulation","being","last","ring","largely","shift","revenue","mark","locate","county","appearance","package","difficulty","bridge","recommend","obvious","train","basically","e-mail","generate","anymore","propose","thinking","possibly","trend","visitor","loan","currently","comfortable","investor","but","profit","angry","crew","deep","accident","male","meal","hearing","traffic","muscle","notion","capture","prefer","truly","earth","Japanese","chest","search","thick","cash","museum","beauty","emergency","unique","feature","internal","ethnic","link","stress","content","select","root","nose","declare","outside","appreciate","actual","bottle","hardly","setting","launch","dress","file","sick","outcome","ad","defend","matter","judge","duty","sheet","ought","ensure","Catholic","extremely","extent","component","mix","long-term","slow","contrast","zone","wake","challenge","airport","chief","brown","standard","shirt","pilot","warn","ultimately","cat","contribution","capacity","ourselves","estate","guide","circumstance","snow","English","politician","steal","pursue","slip","percentage","meat","funny","neither","soil","influence","surgery","correct","Jewish","blame","estimate","due","basketball","late","golf","investigate","crazy","significantly","chain","address","branch","combination","just","frequently","governor","relief","user","dad","kick","part","manner","ancient","silence","rating","golden","motion","German","gender","solve","fee","landscape","used","bowl","equal","long","official","forth","frame","typical","except","conservative","eliminate","host","hall","trust","ocean","score","row","producer","afford","meanwhile","regime","division","confirm","fix","appeal","mirror","tooth","smart","length","entirely","rely","topic","complain","issue","variable","back","range","telephone","perception","attract","confidence","bedroom","secret","debt","rare","his","tank","nurse","coverage","opposition","aside","anywhere","bond","file","pleasure","master","era","requirement","check","stand","fun","expectation","wing","separate","now","clear","struggle","mean","somewhat","pour","stir","judgment","clean","except","beer","English","reference","tear","doubt","grant","seriously","account","minister","totally","hero","industrial","cloud","stretch","winner","volume","travel","seed","surprised","rest","fashion","pepper","separate","busy","intervention","copy","tip","below","cheap","aim","cite","welfare","vegetable","gray","dish","beach","improvement","everywhere","opening","overall","divide","initial","terrible","oppose","contemporary","route","multiple","essential","question","league","criminal","careful","core","upper","rush","necessarily","specifically","tired","rise","tie","employ","holiday","dance","vast","resolution","household","fewer","abortion","apart","witness","match","barely","sector","representative","lack","beneath","beside","black","incident","limited","proud","flow","faculty","increased","waste","merely","mass","emphasize","experiment","definitely","bomb","enormous","tone","liberal","massive","engineer","wheel","female","decline","invest","promise","cable","towards","expose","rural","AIDS","Jew","narrow","cream","secretary","gate","solid","hill","typically","noise","grass","unfortunately","hat","legislation","succeed","either","celebrate","achievement","fishing","drink","accuse","hand","useful","land","secret","reject","talent","taste","characteristic","milk","escape","cast","sentence","unusual","closely","convince","height","physician","assess","sleep","plenty","ride","virtually","first","addition","sharp","creative","lower","behind","approve","explanation","outside","gay","campus","proper","live","guilty","living","acquire","compete","technical","plus","mind","potential","immigrant","weak","illegal","hi","alternative","interaction","column","personality","signal","curriculum","list","honor","passenger","assistance","forever","fun","regard","Israeli","association","twenty","knock","review","wrap","lab","offer","display","criticism","asset","depression","spiritual","musical","journalist","prayer","suspect","scholar","warning","climate","cheese","observation","childhood","payment","sir","permit","cigarette","definition","priority","bread","creation","graduate","request","emotion","scream","dramatic","universe","gap","excellent","deeply","prosecutor","mark","green","lucky","drag","airline","library","agenda","recover","factory","selection","primarily","roof","unable","expense","initiative","diet","arrest","funding","therapy","wash","schedule","sad","brief","housing","post","purchase","existing","dark","steel","regarding","shout","remaining","visual","fairly","chip","violent","silent","suppose","self","bike","tea","perceive","comparison","settlement","layer","planning","far","description","later","slow","slide","widely","wedding","inform","portion","territory","immediate","opponent","abandon","link","mass","lake","transform","tension","display","leading","bother","consist","alcohol","enable","bend","saving","gain","desert","shall","error","release","cop","Arab","double","walk","sand","Spanish","rule","hit","print","preserve","passage","formal","transition","existence","album","participation","arrange","atmosphere","joint","reply","cycle","opposite","lock","whole","deserve","consistent","resistance","discovery","tear","exposure","pose","stream","sale","trust","benefit","pot","grand","mine","hello","coalition","tale","knife","resolve","racial","phase","present","joke","coat","Mexican","symptom","contact","manufacturer","philosophy","potato","interview","foundation","quote","online","pass","negotiation","good","urge","occasion","dust","breathe","elect","investigator","jacket","glad","ordinary","reduction","rarely","shift","pack","suicide","numerous","touch","substance","discipline","elsewhere","iron","practical","moreover","passion","volunteer","implement","essentially","gene","enforcement","vs","sauce","independence","marketing","priest","amazing","intense","advance","employer","shock","inspire","adjust","retire","sure","visible","kiss","illness","cap","habit","competitive","juice","congressional","involvement","dominate","previously","whenever","transfer","analyze","another","attach","for","Indian","disaster","parking","prospect","boss","complaint","championship","coach","exercise","fundamental","severe","enhance","mystery","impose","poverty","other","entry","fat","spending","king","evaluate","symbol","still","trade","maker","mood","accomplish","emphasis","illustrate","boot","monitor","Asian","entertainment","bean","evaluation","creature","commander","digital","arrangement","concentrate","total","usual","anger","psychological","heavily","peak","approximately","increasing","disorder","missile","equally","vary","wire","round","distribution","transportation","holy","ring","twin","command","commission","interpretation","breakfast","stop","strongly","engineering","luck","so-called","constant","race","clinic","veteran","smell","tablespoon","capable","nervous","tourist","light","toss","crucial","bury","pray","tomato","exception","butter","deficit","bathroom","objective","block","electronic","ally","journey","reputation","mixture","surely","tower","smoke","confront","pure","glance","dimension","toy","prisoner","fellow","smooth","nearby","peer","designer","personnel","shape","educator","relative","immigration","belt","teaspoon","birthday","implication","perfectly","coast","supporter","accompany","silver","teenager","recognition","retirement","flag","recovery","whisper","watch","gentleman","corn","moon","inner","junior","rather","throat","salary","swing","observer","due","straight","publication","pretty","crop","dig","strike","permanent","plant","phenomenon","anxiety","unlike","wet","literally","resist","convention","embrace","supply","assist","exhibition","construct","viewer","pan","consultant","soon","line","administrator","date","occasionally","mayor","consideration","CEO","secure","pink","smoke","estimate","buck","historic","poem","grandmother","bind","fifth","constantly","enterprise","favor","testing","stomach","apparent","weigh","install","sensitive","suggestion","mail","recipe","reasonable","preparation","wooden","elementary","concert","aggressive","false","intention","channel","extreme","tube","drawing","protein","quit","absence","roll","Latin","rapidly","jail","comment","diversity","honest","Palestinian","pace","employment","speaker","impression","essay","respondent","giant","cake","historian","negotiate","restore","substantial","pop","particular","specialist","origin","approval","mine","quietly","advise","conventional","drop","count","depth","wealth","disability","shell","general","criticize","fast","professional","effectively","biological","pack","onion","deputy","flat","brand","assure","mad","award","criteria","dealer","via","alternative","utility","precisely","arise","armed","nevertheless","highway","clinical","routine","schedule","wage","normally","phrase","ingredient","stake","Muslim","dream","fiber","activist","Islamic","snap","terrorism","refugee","incorporate","hip","ultimate","switch","corporation","valuable","assumption","gear","graduate","barrier","minor","provision","killer","assign","gang","developing","classic","chemical","wave","label","teen","index","vacation","advocate","draft","extraordinary","heaven","rough","yell","pregnant","distant","drama","satellite","personally","wonder","clock","chocolate","Italian","Canadian","ceiling","sweep","advertising","universal","spin","house","button","bell","rank","darkness","ahead","clothing","super","yield","fence","portrait","paint","survival","roughly","lawsuit","bottom","testimony","bunch","beat","wind","found","burden","react","chamber","furniture","cooperation","string","ceremony","communicate","taste","cheek","lost","profile","mechanism","disagree","like","penalty","match","ie","advance","resort","destruction","bear","unlikely","tissue","constitutional","pant","stranger","infection","cabinet","broken","apple","electric","proceed","track","bet","literary","virus","stupid","dispute","fortune","strategic","assistant","overcome","remarkable","occupy","statistics","shopping","cousin","encounter","wipe","initially","blind","white","port","honor","electricity","genetic","adviser","pay","spokesman","retain","latter","incentive","slave","chemical","translate","accurate","whereas","terror","though","expansion","elite","Olympic","dirt","odd","rice","bullet","tight","Bible","chart","solar","decline","conservative","process","square","stick","concentration","complicated","gently","champion","scenario","telescope","reflection","revolution","strip","interpret","friendly","tournament","fiction","detect","balance","likely","tremendous","lifetime","recommendation","flow","senator","market","hunting","salad","guarantee","innocent","boundary","pause","remote","satisfaction","journal","bench","lover","raw","awareness","surprising","withdraw","general","deck","similarly","newly","pole","testify","mode","dialogue","imply","naturally","mutual","founder","top","advanced","pride","dismiss","aircraft","delivery","mainly","bake","freeze","platform","finance","sink","attractive","respect","diverse","relevant","ideal","joy","worth","regularly","working","singer","evolve","shooting","partly","unknown","assistant","offense","counter","DNA","smell","potentially","transfer","thirty","justify","protest","crash","craft","treaty","terrorist","insight","possess","politically","tap","lie","extensive","episode","double","swim","tire","fault","loose","free","shortly","originally","considerable","prior","intellectual","mix","assault","relax","stair","adventure","external","proof","confident","headquarters","sudden","dirty","violation","tongue","license","hold","shelter","rub","controversy","entrance","favorite","practice","properly","fade","defensive","tragedy","net","characterize","funeral","profession","alter","spot","constitute","establishment","squeeze","imagination","target","mask","convert","comprehensive","prominent","presentation","regardless","easy","load","stable","introduction","appeal","pretend","not","elderly","representation","deer","split","violate","partnership","pollution","emission","steady","vital","neither","fate","earnings","oven","distinction","segment","nowhere","poet","mere","exciting","variation","comfort","radical","stress","adapt","Irish","honey","correspondent","pale","musician","significance","load","round","vessel","storage","flee","mm-hmm","leather","distribute","evolution","ill","tribe","shelf","can","grandfather","lawn","buyer","dining","wisdom","council","vulnerable","instance","garlic","capability","poetry","celebrity","gradually","stability","doubt","fantasy","scared","guide","plot","framework","gesture","depending","ongoing","psychology","since","counselor","witness","chapter","fellow","divorce","owe","pipe","athletic","slight","math","shade","tail","sustain","mount","obligation","angle","palm","differ","custom","store","economist","fifteen","soup","celebration","efficient","damage","composition","satisfy","pile","briefly","carbon","closer","consume","scheme","crack","frequency","tobacco","survivor","besides","in","psychologist","wealthy","galaxy","given","fund","ski","limitation","OK","trace","appointment","preference","meter","explosion","arrest","publicly","incredible","fighter","rapid","admission","hunter","educate","painful","friendship","aide","infant","calculate","fifty","rid","porch","tendency","uniform","formation","scholarship","reservation","efficiency","waste","qualify","mall","derive","scandal","PC","helpful","impress","heel","resemble","privacy","fabric","surprise","contest","proportion","guideline","rifle","maintenance","conviction","trick","organic","tent","examination","publisher","strengthen","French","proposed","myth","sophisticated","cow","etc","standing","asleep","tennis","nerve","barrel","bombing","membership","ratio","menu","purchase","controversial","desperate","rate","lifestyle","humor","loud","glove","suspect","sufficient","narrative","photographer","helicopter","Catholic","modest","provider","delay","agricultural","explode","stroke","scope","punishment","handful","badly","horizon","curious","downtown","girlfriend","prompt","request","cholesterol","absorb","adjustment","taxpayer","eager","principal","detailed","motivation","assignment","restriction","across","Palestinian","laboratory","workshop","differently","auto","romantic","cotton","motor","sue","flavor","overlook","float","undergo","sequence","demonstration","jet","orange","consumption","assert","blade","temporary","medication","print","cabin","bite","relative","edition","valley","yours","pitch","pine","brilliant","versus","manufacturing","risk","Christian","complex","absolute","chef","discrimination","offensive","German","suit","boom","register","appoint","heritage","God","terrorist","dominant","successfully","shit","lemon","hungry","sense","dry","wander","submit","economics","naked","anticipate","nut","legacy","extension","shrug","fly","battery","arrival","legitimate","orientation","inflation","cope","flame","cluster","host","wound","dependent","shower","institutional","depict","operating","flesh","garage","operator","instructor","collapse","borrow","furthermore","comedy","mortgage","sanction","civilian","twelve","weekly","habitat","grain","brush","consciousness","devote","crack","measurement","province","ease","seize","ethics","nomination","permission","wise","actress","summit","acid","odds","gifted","frustration","medium","function","physically","grant","distinguish","shore","repeatedly","lung","firm","running","correct","distinct","artistic","discourse","basket","ah","fighting","impressive","competitor","ugly","worried","portray","powder","ghost","persuade","moderate","subsequent","continued","cookie","carrier","cooking","frequent","ban","swing","orange","awful","admire","pet","miracle","exceed","rhythm","widespread","killing","lovely","sin","charity","script","tactic","identification","transformation","everyday","headline","crash","venture","invasion","military","nonetheless","adequate","piano","grocery","intensity","exhibit","high","blanket","margin","principal","quarterback","mouse","rope","concrete","prescription","African-American","chase","document","brick","recruit","patch","consensus","horror","recording","changing","painter","colonial","pie","sake","gaze","courage","pregnancy","swear","defeat","clue","reinforce","win","confusion","slice","occupation","dear","coal","sacred","criminal","formula","cognitive","collective","exact","uncle","square","captain","sigh","attribute","dare","okay","homeless","cool","gallery","soccer","defendant","tunnel","fitness","lap","grave","toe","container","virtue","abroad","architect","dramatically","makeup","inquiry","rose","surprisingly","highlight","decrease","indication","rail","anniversary","couch","alliance","hypothesis","boyfriend","compose","peer","mess","rank","legend","regulate","adolescent","shine","norm","upset","remark","resign","reward","gentle","related","organ","lightly","concerning","invent","laughter","fit","northwest","counseling","tight","receiver","ritual","insect","interrupt","salmon","favor","trading","concern","magic","superior","combat","stem","surgeon","acceptable","physics","rape","counsel","brush","jeans","hunt","continuous","log","echo","pill","excited","sculpture","compound","integrate","flour","bitter","bare","slope","rent","presidency","serving","subtle","greatly","bishop","drinking","delay","cry","acceptance","collapse","shop","pump","candy","evil","final","finance","pleased","medal","beg","sponsor","ethical","secondary","slam","export","experimental","melt","midnight","net","curve","integrity","entitle","evident","logic","essence","park","exclude","harsh","closet","suburban","greet","favor","interior","corridor","murder","retail","pitcher","march","snake","pitch","excuse","cross","weakness","pig","cold","classical","estimated","T-shirt","online","unemployment","civilization","fold","patient","pop","daily","reverse","missing","correlation","humanity","flash","developer","reliable","excitement","beef","Islam","Roman","stretch","architecture","occasional","administrative","elbow","deadly","Muslim","Hispanic","allegation","tip","confuse","airplane","monthly","duck","dose","Korean","plead","initiate","lecture","van","sixth","bay","mainstream","suburb","sandwich","unlike","trunk","rumor","implementation","swallow","motivate","render","longtime","trap","restrict","cloth","seemingly","legislative","effectiveness","enforce","lens","reach","inspector","lend","plain","fraud","companion","contend","nail","array","strict","assemble","frankly","rat","burst","hallway","cave","inevitable","southwest","monster","speed","protest","unexpected","obstacle","facilitate","encounter","rip","herb","overwhelming","integration","crystal","recession","wish","top","written","motive","label","flood","pen","ownership","nightmare","notice","inspection","supervisor","consult","arena","laugh","diagnosis","possession","forgive","warm","consistently","basement","project","drift","drain","last","prosecution","maximum","announcement","warrior","prediction","bacteria","questionnaire","mud","infrastructure","hurry","privilege","temple","medium","outdoor","suck","and/or","broadcast","re","leap","random","past","wrist","curtain","monitor","pond","domain","guilt","cattle","subject","walking","playoff","minimum","fiscal","skirt","dump","hence","database","uncomfortable","aim","execute","limb","ideology","average","welcome","tune","continuing","harm","railroad","endure","radiation","horn","chronic","peaceful","innovation","strain","guitar","replacement","behave","administer","simultaneously","dancer","amendment","guard","pad","transmission","await","retired","trigger","spill","grateful","grace","virtual","response","colony","adoption","slide","indigenous","closed","convict","civilian","towel","modify","particle","award","glance","prize","landing","conduct","blue","boost","bat","alarm","festival","grip","weird","undermine","freshman","sweat","outer","European","drunk","survey","research","separation","traditionally","stuff","govern","southeast","intelligent","wherever","ballot","rhetoric","convinced","driving","vitamin","enthusiasm","accommodate","praise","injure","wilderness","nearby","endless","mandate","pause","excuse","respectively","uncertainty","chaos","short","mechanical","canvas","forty","matter","lobby","profound","format","trait","currency","turkey","reserve","beam","abuse","astronomer","corruption","contractor","apologize","doctrine","genuine","thumb","unity","compromise","horrible","behavioral","exclusive","scatter","commonly","convey","rush","twist","complexity","fork","disk","relieve","suspicion","lock","finish","health-care","health-care","health-care","health-care","residence","shame","meaningful","sidewalk","Olympics","technological","signature","pleasant","wow","suspend","rebel","frozen","desire","spouse","fluid","pension","resume","theoretical","sodium","blow","promotion","delicate","forehead","rebuild","bounce","electrical","hook","detective","traveler","click","compensation","signal","exit","attraction","dedicate","altogether","pickup","carve","needle","belly","ship","scare","portfolio","shuttle","invisible","timing","engagement","ankle","transaction","rescue","counterpart","historically","firmly","mild","rider","doll","noon","exhibit","amid","identical","precise","anxious","structural","residential","loud","diagnose","carbohydrate","liberty","poster","theology","nonprofit","crawl","oxygen","handsome","magic","sum","provided","businessman","promising","conscious","determination","donor","hers","pastor","jazz","opera","Japanese","bite","frame","evil","acquisition","pit","hug","wildlife","punish","giant","primary","equity","wrong","doorway","departure","elevator","teenage","guidance","happiness","statue","pursuit","repair","decent","gym","oral","clerk","Israeli","envelope","reporting","destination","fist","endorse","exploration","generous","bath","rescue","thereby","overall","indicator","sunlight","feedback","spectrum","purple","laser","bold","reluctant","starting","expertise","practically","program","picture","tune","eating","age","volunteer","hint","sharply","parade","advocate","realm","ban","strip","cancel","blend","therapist","slice","peel","pizza","recipient","hesitate","flip","accounting","debate","bias","huh","metaphor","candle","handle","worry","judicial","entity","suffering","full-time","feel","lamp","garbage","servant","addition","regulatory","diplomatic","elegant","inside","reception","vanish","automatically","chin","trail","necessity","confess","racism","starter","interior","banking","casual","gravity","enroll","diminish","prevention","Arab","value","minimize","chop","performer","intent","isolate","pump","inventory","productive","assembly","civic","silk","magnitude","steep","hostage","collector","popularity","kiss","alien","dynamic","scary","equation","angel","switch","offering","rage","photography","repair","toilet","disappointed","precious","prohibit","representative","content","realistic","Russian","hidden","command","tender","wake","gathering","outstanding","stumble","lonely","automobile","artificial","dawn","abstract","descend","silly","hook","tide","shared","hopefully","readily","cooperate","revolutionary","romance","hardware","pillow","kit","cook","spread","continent","seal","circuit","sink","ruling","shortage","annually","lately","trap","scan","fool","deadline","rear","processing","ranch","coastal","undertake","softly","reserve","burning","verbal","tribal","ridiculous","automatic","diamond","credibility","import","sexually","spring","way","divine","sentiment","cart","oversee","stem","o'clock","elder","o'clock","o'clock","o'clock","pro","inspiration","Dutch","quantity","trailer","mate","o'clock","Greek","genius","monument","bid","quest","sacrifice","invitation","accuracy","juror","officially","broker","treasure","loyalty","credit","shock","talented","gasoline","stiff","output","nominee","extended","please","diabetes","slap","toxic","alleged","jaw","grief","mysterious","rocket","donate","inmate","tackle","dynamics","bow","ours","senior","dignity","carpet","parental","bubble","heat","buddy","barn","sword","flash","seventh","glory","tightly","protective","tuck","drum","faint","post","queen","dilemma","input","specialize","northeast","shallow","liability","sail","merchant","stadium","improved","bloody","defeat","associated","withdrawal","refrigerator","nest","near","thoroughly","lane","ancestor","condemn","steam","accent","escape","optimistic","unite","cage","equip","shrimp","homeland","exchange","rack","costume","wolf","courtroom","statute","cartoon","besides","productivity","grin","symbolic","seal","bug","bless","aunt","agriculture","rock","hostile","root","conceive","combined","instantly","hay","vaccine","bonus","collaboration","mixed","opposed","orbit","grasp","patience","spite","tropical","voting","patrol","willingness","position","revelation","rent","calm","jewelry","Cuban","haul","concede","trace","wagon","afterward","spectacular","ruin","sheer","prior","immune","reliability","ass","alongside","bush","exotic","fascinating","secure","clip","thigh","bull","drawer","regard","sheep","discourage","coordinator","ideological","runner","secular","intimate","empire","cab","divorce","exam","documentary","neutral","biology","flexible","progressive","web","conspiracy","catch","casualty","republic","execution","terrific","whale","functional","star","draft","instinct","teammate","aluminum","whoever","ministry","verdict","instruct","skull","self-esteem","ease","cooperative","manipulate","bee","practitioner","loop","edit","whip","puzzle","mushroom","subsidy","boil","tragic","mathematics","mechanic","jar","respect","earthquake","pork","creativity","safely","underlying","dessert","sympathy","fisherman","incredibly","isolation","sock","near","jump","eleven","sexy","entrepreneur","syndrome","bureau","seat","workplace","ambition","touchdown","utilize","breeze","costly","ambitious","Christianity","presumably","influential","translation","uncertain","dissolve","object","statistical","gut","metropolitan","rolling","aesthetic","spell","insert","booth","helmet","waist","expected","lion","accomplishment","royal","panic","cast","crush","actively","cliff","minimal","cord","fortunately","cocaine","illusion","anonymous","tolerate","appreciation","commissioner","harm","flexibility","instructional","scramble","casino","tumor","decorate","sort","charge","pulse","equivalent","fixed","experienced","donation","diary","sibling","irony","spoon","midst","alley","upset","interact","soap","cute","rival","short-term","punch","pin","hockey","passing","persist","supplier","known","momentum","purse","shed","liquid","icon","elephant","consequently","legislature","associate","franchise","correctly","mentally","foster","bicycle","encouraging","cheat","access","heal","fever","filter","rabbit","coin","exploit","accessible","organism","sensation","partially","stay","upstairs","dried","minimum","pro","conservation","shove","backyard","charter","stove","consent","comprise","reminder","alike","placement","dough","grandchild","dam","reportedly","well-known","surrounding","ecological","outfit","unprecedented","columnist","workout","preliminary","patent","shy","quote","trash","disabled","gross","damn","hormone","texture","counter","pencil","associate","frontier","spray","bet","disclose","custody","banker","beast","interfere","oak","case","eighth","notebook","outline","gaze","attendance","speculation","uncover","behalf","innovative","shark","reward","mill","installation","stimulate","tag","vertical","swimming","fleet","catalog","outsider","sacrifice","desperately","stance","compel","sensitivity","someday","instant","debut","proclaim","worldwide","hike","required","confrontation","colorful","ideal","constitution","trainer","Thanksgiving","scent","stack","eyebrow","sack","cease","inherit","tray","pioneer","organizational","textbook","uh","nasty","shrink","model","emerging","dot","wheat","fierce","envision","rational","kingdom","aisle","weaken","protocol","exclusively","vocal","marketplace","openly","unfair","terrain","deploy","risky","pasta","genre","distract","merit","planner","depressed","chunk","closest","discount","no","ladder","jungle","migration","breathing","invade","hurricane","retailer","classify","wound","coup","aid","ambassador","density","supportive","curiosity","skip","aggression","stimulus","journalism","robot","flood","dip","likewise","informal","Persian","feather","sphere","tighten","boast","pat","perceived","sole","publicity","major","unfold","joke","well-being","validity","ecosystem","strictly","partial","collar","weed","compliance","streak","supposedly","added","builder","glimpse","premise","specialty","deem","artifact","sneak","monkey","mentor","two-thirds","listener","lightning","legally","sleeve","disappointment","disturb","rib","excessive","high-tech","debris","pile","rod","logical","liberal","ash","socially","parish","slavery","blank","commodity","cure","mineral","hunger","dying","developmental","faster","spare","halfway","cure","equality","cemetery","harassment","deliberately","fame","regret","striking","likelihood","carrot","atop","toll","rim","embarrassed","fucking","cling","isolated","blink","suspicious","wheelchair","squad","eligible","processor","plunge","this","sponsor","grin","color","demographic","rain","chill","refuge","steer","legislator","rally","programming","cheer","outlet","intact","vendor","thrive","peanut","chew","elaborate","intellectual","conception","auction","steak","comply","triumph","shareholder","comparable","transport","conscience","calculation","considerably","interval","scratch","awake","jurisdiction","inevitably","feminist","constraint","emotionally","expedition","allegedly","compromise","strain","similarity","butt","lid","dumb","bulk","sprinkle","mortality","philosophical","conversion","patron","municipal","any","liver","harmony","solely","tolerance","instant","goat","arm","blessing","banana","running","palace","formerly","peasant","neat","grandparent","lawmaker","supermarket","cruise","mobile","plain","part","calendar","widow","deposit","beard","brake","downtown","screening","impulse","forbid","fur","brutal","predator","poke","opt","voluntary","trouble","valid","forum","dancing","happily","soar","removal","autonomy","enact","round","thread","light","landmark","unhappy","offender","coming","privately","fraction","distinctive","tourism","threshold","calm","routinely","suite","remark","regulator","straw","theological","apart","exhaust","globe","fragile","objection","chemistry","old-fashioned","crowded","circle","blast","prevail","overnight","denial","rental","fantastic","fragment","level","screw","warmth","undergraduate","liquid","headache","policeman","yield","projection","battle","suitable","mention","graduation","drill","cruel","mansion","regard","grape","authorize","cottage","driveway","charm","sexuality","loyal","clay","pound","balloon","invention","ego","fare","homework","disc","sofa","guarantee","availability","radar","frown","regain","leave","permit","sweater","rehabilitation","rubber","retreat","molecule","freely","favorable","steadily","veteran","integrated","ha","youngster","broadcast","premium","accountability","overwhelm","one-third","contemplate","update","spark","ironically","fatigue","beyond","speculate","marker","low","preach","bucket","bomb","blond","confession","provoke","marble","substantially","twist","defender","fish","explicit","transport","disturbing","surveillance","magnetic","technician","mutter","devastating","depart","arrow","trauma","neighboring","soak","ribbon","meantime","transmit","screen","harvest","consecutive","republican","coordinate","worldwide","within","spy","slot","riot","nutrient","citizenship","severely","sovereignty","ridge","brave","lighting","specify","contributor","frustrate","crowd","articulate","importantly","transit","dense","seminar","electronics","sunny","shorts","swell","accusation","soften","photograph","straighten","terribly","cue","sudden","bride","biography","hazard","compelling","seldom","tile","economically","honestly","troubled","bow","twentieth","balanced","foreigner","launch","convenience","delight","weave","timber","till","accurately","plea","bulb","copy","flying","sustainable","devil","bolt","cargo","spine","seller","skilled","managing","public","marine","dock","organized","fog","diplomat","boring","sometime","summary","missionary","epidemic","fatal","trim","warehouse","accelerate","butterfly","bronze","drown","inherent","praise","nationwide","spit","harvest","kneel","vacuum"];
		$s="";
		$rand=Math.random()*100.0;
		$ran=Math.floor($rand);
		$tmp=[];
		$cnt=0;
		for($i=$ran;$i<1000;$i+=3)
		{
		$tmp[$cnt]=$main[$i];
		$cnt++;
		}
		for($i=0;$i<$tmp.length;$i++)
		{
		if($i==0)
				$s+="<div class=\"highlight\"id=\""+$i+"\">"+$tmp[$i]+"</div> ";
				else
		$s+="<div id=\""+$i+"\">"+$tmp[$i]+"</div> ";
		}
		$('#words').html($s);

		$('#ans').bind('keypress', function(e) {
		if((e.which==32 || e.keyCode==32) && $tcount>=0){
		$chk=1;
		$vari=$(this).val();
		$chartmp=$vari.length;
		$charcnt+=$chartmp;
		//alert($vari);
		$(this).val("");
			$q="#"+($spcnt);
				$($q).removeClass("highlight");
			if($tmp[$spcnt]==$vari)
			{
				$($q).addClass("ac");
				$wordcnt++;
			}

			else if($tmp[$spcnt]!=$vari)
				$($q).addClass("wa");
		$spcnt++;
		$qw="#"+($spcnt);
		$($qw).addClass("highlight");
		$('#ans').val("");

		}
		$accr=(Math.round(($wordcnt/$spcnt)*100.0));
		if($wordcnt==0)
		$accr=0;
		$strg="<p><h3>Words per minute: </h3><span id=\"wcnt\">"+$wordcnt+"</span></p><p><h3>Accuracy: </h3><span id=\"waccr\">"+$accr+"%</span></p> <h3>Keystrokes: </h3><span id=\"wccnt\">"+$charcnt+"</span></p>";
		$('#res').html($strg);
		});
								if(	$chk==0)
		{
		$strg="<p><h3>Words per minute: </h3>0</p><p><h3>Accuracy: </h3>0%</p> <h3>Keystrokes: </h3>0</p>";
		$('#res').html($strg);
		}

		})
		</script>
				<script type="text/javascript">
$(document).bind("contextmenu", function(event) {
    event.preventDefault();
    $("<div class='custom-menu'>Developed by Shovon</div>")
        .appendTo("body")
        .css({top: event.pageY + "px", left: event.pageX + "px"});
}).bind("click", function(event) {
    $("div.custom-menu").hide();
});

		</script>

<iframe frameborder="0" scrolling="no" style="background-color: transparent; border: 0px; display: none;" src="./typespeed_files/saved_resource.html"></iframe><div id="GOOGLE_INPUT_CHEXT_FLAG" input="" input_stat="{&quot;tlang&quot;:true,&quot;tsbc&quot;:true,&quot;pun&quot;:true,&quot;mk&quot;:true,&quot;ss&quot;:true}" style="display: none;"></div><div class="custom-menu" style="top: 815px; left: 1485px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 714px; left: 1513px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 652px; left: 1451px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 798px; left: 1348px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 796px; left: 1130px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 820px; left: 683px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 692px; left: 320px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 638px; left: 119px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 562px; left: 84px; display: none;">Developed by Shovon</div><div class="custom-menu" style="top: 458px; left: 95px; display: none;">Developed by Shovon</div></body></html>

