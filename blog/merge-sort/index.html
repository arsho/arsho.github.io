<!DOCTYPE html>



<html lang="en"> 

<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="index,follow">

<meta name="keywords" content="algorithm, sorting, divide-and-conquer">
<meta name="description" content="Divide and conquer strategy, merge sort characteristics, algorithm, implementation, comparison between merge sort and insertion sort, and practice challenges">
<meta name="author" content="Ahmedur Rahman Shovon">

<meta property="og:url" content="https://arshovon.com/blog/merge-sort/">
<meta property="og:type" content="website">
<meta property="og:title" content="Merge Sort - Ahmedur Rahman Shovon">
<meta name="og:description" content="Divide and conquer strategy, merge sort characteristics, algorithm, implementation, comparison between merge sort and insertion sort, and practice challenges">
<meta property="og:image" content="https://arshovon.com/blog/images/merge_sort.png">
<meta property="og:image:secure_url" content="https://arshovon.com/blog/images/merge_sort.png">
<meta property="og:image:type" content="image/png">
<meta property="og:image:alt" content="Merge Sort - Ahmedur Rahman Shovon" />
<meta property="og:site_name" content="Ahmedur Rahman Shovon"/>
<meta property="og:locale" content="en-us">

<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://arshovon.com/blog/images/merge_sort.png" />
<meta name="twitter:url" content="https://arshovon.com/blog/merge-sort/" />
<meta property="twitter:title" content="Merge Sort - Ahmedur Rahman Shovon">
<meta name="twitter:description" content="Divide and conquer strategy, merge sort characteristics, algorithm, implementation, comparison between merge sort and insertion sort, and practice challenges">
<title>Merge Sort - Ahmedur Rahman Shovon</title>

<link rel="canonical" href="https://arshovon.com/blog/merge-sort/">

<link rel="icon" href="https://arshovon.com/assets/images/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="https://arshovon.com/assets/images/favicon.ico"
type="image/x-icon"/>
<link href="https://fonts.googleapis.com/css?family=Exo+2:400,400i,600,600i,700,700i" rel="stylesheet">

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github-gist.min.css">

<link rel="stylesheet" href="https://arshovon.com/assets/css/arsho.css">
<link rel="stylesheet" href="https://arshovon.com/assets/css/custom.css">



<script async
src="https://www.googletagmanager.com/gtag/js?id=UA-119139307-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'UA-119139307-1');
</script>

</head>
<body>
    <header class="header mb-md-4 mb-lg-4 mb-xl-4">
    
    <nav class="navbar navbar-expand-md navbar-blog">
        <div class="container navbar-container">
            <a class="navbar-brand" href="/">
                AR Shovon
            </a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
                <i class="fas fa-bars navbar-toggler-icon-fa"></i>
            </button>
            <div class="collapse navbar-collapse" id="navbarCollapse">
                
                <ul class="navbar-nav mr-auto">
    
    <li class="nav-item">
        <a class="nav-link" title="Blog posts" href="/blog">
            <i class="fa fa-laptop-code fa-lg"></i>
            Blog
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" title="Snippets" href="/snippets">
            <i class="fa fa-code fa-lg"></i>
            Snippets
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" title="Apps" href="/apps">
            <i class="fa fa-globe fa-lg"></i>
            Apps
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" title="All categories" href="/categories">
            <i class="fa fa-folder-open fa-lg"></i>
            Categories
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" title="All tags" href="/tags">
            <i class="fa fa-tags fa-lg"></i>
            Tags
        </a>
    </li>
    
</ul>

                
                
                <ul class="navbar-nav ml-auto navbar-blog-right">
    
    <li class="nav-item">
        <a class="nav-link" title="Linkedin profile" href="https://www.linkedin.com/in/arshovon/">
            <i class="fab fa-linkedin fa-lg"></i>
            arshovon
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" title="Stackoverflow profile" href="https://stackoverflow.com/users/3129414/arsho">
            <i class="fab fa-stack-overflow fa-lg"></i>
            arsho
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" title="Github profile" href="https://github.com/arsho/">
            <i class="fab fa-github fa-lg"></i>
            arsho
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" title="View CV" href="/cv/CV_Shovon.pdf">
            <i class="fas fa-file-pdf fa-lg"></i>
            CV
        </a>
    </li>
    
</ul>

                
            </div>
        </div>
    </nav>
</header>

    <div class="container wrapper">
        <div class="row">
            
            
            


<main class="col-12 blog p-3 p-md-5" role="main">
  <article>
    <header class="mb-4">
      <h3>Merge Sort</h3>
      <div class="mb-3">
        <span class="float-right badge">
          Published on
          <time datetime="2021-04-29T01:00:15&#43;06:00">
            <i class="fa fa-calendar pr-1"></i>April 29, 2021</time>
          
            , Updated on
            <time datetime="2021-12-14T19:21:39-06:00">
              <i class="fa fa-calendar pr-1"></i>December 14, 2021</time>
          
        </span>
        
        <a href="https://arshovon.com/categories/" class="badge badge-secondary" title="All categories"><i class="fa fa-folder-open"></i></a>

<a href="https://arshovon.com/categories/algorithm"
class="badge badge-secondary" title="algorithm" >algorithm</a>


        
        
        <a href="https://arshovon.com/tags/" class="badge badge-secondary" title="All tags"><i class="fa fa-tags"></i></a>

<a href="https://arshovon.com/tags/algorithm" class="badge badge-secondary" title="algorithm">algorithm</a>

<a href="https://arshovon.com/tags/sorting" class="badge badge-secondary" title="sorting">sorting</a>

<a href="https://arshovon.com/tags/divide-and-conquer" class="badge badge-secondary" title="divide-and-conquer">divide-and-conquer</a>


        
      </div>
    </header>
    <hr class="my-6">
    <h2 id="divide-and-conquer-strategy-and-merge-sort">Divide and conquer strategy and merge sort</h2>

<p>In a divide and conquer strategy, a problem is divided into multiple subproblems.
These subproblems are similar to the original problem but smaller in size.
The divide and conquer strategy solves these subproblems recursively.
Then it combines the solutions of the subproblems to develop a final solution for the original problem.
Thus, the divide and conquer strategy has two parts: divide and conquer.</p>

<h3 id="divide">Divide</h3>

<p>In the divide phase, the original problem is divided into smaller subproblems.
Each subproblem has the same characteristics as the original problem.</p>

<h3 id="conquer">Conquer</h3>

<p>In this phase, the subproblems are solved recursively.
Finally, the smaller results are combined to form the final solution of the original problem.</p>

<p>Merge sort is based on the divide and conquer strategy. To sort an array of <code>n</code> elements, it follows the below steps:</p>

<ul>
<li>It divides the unsorted array into <code>n/2</code> parts recursively until there is only one element in each part.</li>
<li>It sorts the smaller parts and combines the smaller solutions to create the final result.</li>
</ul>

<p>The following figure illustrates how merge sort follows the divide and conquer strategy.</p>





<figure class="figure py-2 mx-auto d-block">
    
        <img class="mx-auto d-block figure-img img-thumbnail border border-light" src="/blog/images/merge_sort_split_and_merge.svg"  />
    
    
    <figcaption class="figure-caption text-center">
        
            Merge sort splitting and merging step
        
        
    </figcaption>
    
</figure>



<h2 id="merge-sort-characteristics">Merge sort characteristics</h2>

<h3 id="practical">Practical</h3>

<p>Merge sort is an efficient comparison-based sorting algorithm. As of Perl 5.8, merge sort is the default sorting algorithm. The Linux kernel also uses merge sort for linked lists.</p>

<h3 id="not-adaptive">Not Adaptive</h3>

<p>Merge sort is not adaptive. It performs the same on sorted, almost sorted, and unsorted lists. Its performance is not dependent on whether the input data is sorted or not.</p>

<h3 id="offline">Offline</h3>

<p>Merge sort works after receiving all the data. It does not sort the element when it receives them.</p>

<h3 id="stable">Stable</h3>

<p>Merge sort is stable. Numbers with the same value appear in the output array as they appear in the input array. Let's take an input array <code>A = [3, 0, 3]</code>. In the input array, the value <code>3</code> occurs two times; at index 0 and 2. Insertion sort ensures that in the output array, the occurrences of <code>3</code> are placed in the same order as the input array.</p>

<h3 id="not-in-place">Not In place:</h3>

<p>Merge sort does not sort the input list in place. It requires an additional list of <code>n</code> size to sort unsorted list of <code>n</code> elements. So, its space complexity is <code>O(n)</code>.</p>

<h3 id="loglinear-time-complexity">Loglinear time complexity</h3>

<p>It has loglinear time complexity.<br></p>

<ul>
<li>Worst Time complexity (Big-O): <code>O(nlogn)</code>, where <code>n</code>: total number of elements in the list.<br></li>
<li>Average Time complexity (Big-Theta): <code>Θ(nlogn)</code>, where <code>n</code>: total number of elements in the list.<br></li>
<li>Best Time complexity (Big-Omega): <code>Ω(nlogn)</code>, where <code>n</code>: total number of elements in the list.<br></li>
<li>Space complexity: <code>O(n)</code></li>
</ul>

<h2 id="merge-sort-algorithm-pseudocode">Merge Sort algorithm pseudocode</h2>

<pre><code class="language-bash">procedure Merge(A: list of items, TEMP: temporary array, LEFT, MID, RIGHT)
    LEFT_POS := 0
    RIGHT_POS := MID + 1
    CURRENT_POS := LEFT
    while LEFT_POS &lt;= MID and RIGHT_POS &lt;= RIGHT do
        if A[LEFT_POS] &lt;= A[RIGHT_POS] then
            TEMP[CURRENT_POS] := A[LEFT_POS]
            LEFT_POS := LEFT_POS + 1
        else then
            TEMP[CURRENT_POS] := A[RIGHT_POS]
            RIGHT_POS := RIGHT_POS + 1
        end if
        CURRENT_POS := CURRENT_POS + 1
    end while
    while LEFT_POS &lt;= MID do
        TEMP[CURRENT_POS] := A[LEFT_POS]
        LEFT_POS := LEFT_POS + 1
        CURRENT_POS := CURRENT_POS + 1
    end while
    while RIGHT_POS &lt;= RIGHT do
        TEMP[CURRENT_POS] := A[RIGHT_POS]
        RIGHT_POS := RIGHT_POS + 1
        CURRENT_POS := CURRENT_POS + 1
    end while
    for i in LEFT to RIGHT inclusive do
        A[i] = TEMP[i]
    end for
end procedure

procedure Split_And_Merge(A: list of items, TEMP: temporary array, LEFT, RIGHT)
    if LEFT &lt; RIGHT then
        MID := ⌊(LEFT + RIGHT)⌋ / 2
        Split_And_Merge(A, TEMP, LEFT, MID)
        Split_And_Merge(A, TEMP, MID+1, RIGHT)
        Merge(A, TEMP, LEFT, MID, RIGHT)
    end if
end procedure

procedure Merge_Sort(A: list of items, N: total items)
    TEMP[0..A.LENGTH] a new array
    Split_And_Merge(A, TEMP, 0, N - 1)
end procedure
</code></pre>

<h2 id="merge-sort-implementation-using-python-3">Merge Sort implementation using Python 3</h2>

<pre><code class="language-py">&quot;&quot;&quot;
Implementation of merge sort algorithm

Main File: merge_sort.py
Test File: test_merge_sort.py
&quot;&quot;&quot;


def get_merge_sorted_numbers(numbers):
    &quot;&quot;&quot; Returns sorted list for a given list

    Arguments:
    numbers -- list of numbers
    &quot;&quot;&quot;
    temp = numbers.copy()
    perform_split_and_merge(numbers, temp, 0, len(numbers) - 1)
    return numbers


def perform_split_and_merge(ar, temp, left, right):
    if left &lt; right:
        mid = (right + left) // 2
        perform_split_and_merge(ar, temp, left, mid)
        perform_split_and_merge(ar, temp, mid + 1, right)
        perform_merge(ar, temp, left, mid, right)


def perform_merge(ar, temp, left, mid, right):
    left_pos = left
    right_pos = mid + 1
    current_pos = left
    while left_pos &lt;= mid and right_pos &lt;= right:
        if ar[left_pos] &lt;= ar[right_pos]:
            temp[current_pos] = ar[left_pos]
            left_pos += 1
        else:
            temp[current_pos] = ar[right_pos]
            right_pos += 1
        current_pos += 1
    while left_pos &lt;= mid:
        temp[current_pos] = ar[left_pos]
        left_pos += 1
        current_pos += 1
    while right_pos &lt;= right:
        temp[current_pos] = ar[right_pos]
        right_pos += 1
        current_pos += 1
    for i in range(left, right + 1):
        ar[i] = temp[i]
</code></pre>

<h2 id="unit-testing-merge-sort-implementation-using-python-3">Unit testing merge sort implementation using Python 3</h2>

<pre><code class="language-py">&quot;&quot;&quot;
Unittest of merge sort implementation

Main File: merge_sort.py
Test File: test_merge_sort.py
&quot;&quot;&quot;
import unittest
from merge_sort import get_merge_sorted_numbers


class TestMergeSort(unittest.TestCase):
    def test_get_merge_sorted_numbers_positive_unsorted(self):
        test_case = [2, 3, 1, 4, 2, 4]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_positive_negative_unsorted(self):
        test_case = [2, -3, 1, -4, 2, 4]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_same_values_positive(self):
        test_case = [1, 1, 1, 1]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_same_values_negative(self):
        test_case = [-1, -1, -1]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_single_item(self):
        test_case = [1]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_empty_list(self):
        test_case = []
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_positive_reverse(self):
        test_case = [123, 56, 8]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_positive_negative_reverse(self):
        test_case = [1, 0, -1]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_negative_reverse(self):
        test_case = [-1, -3, -56]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)

    def test_get_merge_sorted_numbers_positive_negative_floating(self):
        test_case = [-1.5, 3.336, -66.3, 5]
        expected_result = sorted(test_case)
        test_result = get_merge_sorted_numbers(test_case.copy())
        self.assertEqual(expected_result, test_result,
                         f&quot;Failed on {test_case}, &quot;
                         f&quot;Expected {expected_result}, &quot;
                         f&quot;Found {test_result}&quot;)


if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre>





<figure class="figure py-2 mx-auto d-block">
    
        <img class="mx-auto d-block figure-img img-thumbnail border border-light" src="/blog/images/test_merge_sort.png" alt="Unittest run" />
    
    
    <figcaption class="figure-caption text-center">
        
            Figure: Unittest of merge sort implementation
        
        
    </figcaption>
    
</figure>



<h2 id="merge-sort-implementation-using-c">Merge Sort implementation using C++</h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;


void perform_merge(int ar[], int temp[], int left, int mid, int right)
{
    int left_pos = left;
    int right_pos = mid + 1;
    int current_pos = left;
    while (left_pos &lt;= mid &amp;&amp; right_pos &lt;= right)
    {
        if (ar[left_pos] &lt;= ar[right_pos])
        {
            temp[current_pos++] = ar[left_pos++];
        }
        else
        {
            temp[current_pos++] = ar[right_pos++];
        }
    }
    while (left_pos &lt;= mid)
    {
        temp[current_pos++] = ar[left_pos++];
    }
    while (right_pos &lt;= right)
    {
        temp[current_pos++] = ar[right_pos++];
    }
    for(int i=left; i &lt;= right; i++)
    {
        ar[i] = temp[i];
    }
}


void perform_split_and_merge(int ar[], int temp[], int left, int right)
{
    if(left &lt; right)
    {
        int mid = (left + right) / 2;
        perform_split_and_merge(ar, temp, left, mid);
        perform_split_and_merge(ar, temp, mid+1, right);
        perform_merge(ar, temp, left, mid, right);
    }
}

void get_merge_sorted_numbers(int ar[], int n)
{
    int temp[n];
    perform_split_and_merge(ar, temp, 0, n-1);
}

void print_array(int ar[], int n)
{
    for(int i=0; i&lt;n; i++)
    {
        cout &lt;&lt; ar[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; &quot;&quot; &lt;&lt;endl;
}

int main()
{
    int n = 6;
    int ar[] = {2, -3, 1, -4, 2, 4};
    cout &lt;&lt; &quot;Before sorting: &quot;;
    print_array(ar, n);
    get_merge_sorted_numbers(ar, n);
    cout &lt;&lt; &quot;After sorting: &quot;;
    print_array(ar, n);
    return 0;
}
</code></pre>

<h2 id="comparison-between-bubble-sort-and-insertion-sort">Comparison between bubble sort and insertion sort</h2>

<ul>
<li>Insertion sort is more efficient than bubble sort as it requires fewer swaps to sort the elements.</li>
<li>Insertion sort is online, but bubble sort is offline. That means insertion sort sorts the elements when receiving each element but bubble sort sorts the elements only after receiving all the elements.</li>
</ul>

<p>The following table shows the execution time in seconds for merge sort, bubble sort, and insertion sort for different numbers of input elements.</p>

<table class="table table-bordered table-hover table-striped">
<thead>
<tr>
<th>Set Size</th>
<th>Maximum Value</th>
<th>Merge sort</th>
<th>Bubble sort</th>
<th>Insertion sort</th>
<th>Counting sort</th>
</tr>
</thead>

<tbody>
<tr>
<td>1000</td>
<td>1000</td>
<td>0.02285 seconds</td>
<td>0.51674 seconds</td>
<td>0.24463 seconds</td>
<td>0.00209 seconds</td>
</tr>

<tr>
<td>2000</td>
<td>2000</td>
<td>0.04808 seconds</td>
<td>2.14491 seconds</td>
<td>0.97831 seconds</td>
<td>0.00433 seconds</td>
</tr>

<tr>
<td>3000</td>
<td>3000</td>
<td>0.07648 seconds</td>
<td>5.05203 seconds</td>
<td>2.2953 seconds</td>
<td>0.00654 seconds</td>
</tr>

<tr>
<td>4000</td>
<td>4000</td>
<td>0.10607 seconds</td>
<td>9.82914 seconds</td>
<td>4.19266 seconds</td>
<td>0.0091 seconds</td>
</tr>

<tr>
<td>5000</td>
<td>5000</td>
<td>0.14967 seconds</td>
<td>15.07934 seconds</td>
<td>6.75124 seconds</td>
<td>0.01975 seconds</td>
</tr>

<tr>
<td>6000</td>
<td>6000</td>
<td>0.31401 seconds</td>
<td>21.08818 seconds</td>
<td>9.4236 seconds</td>
<td>0.01431 seconds</td>
</tr>

<tr>
<td>7000</td>
<td>7000</td>
<td>0.20681 seconds</td>
<td>29.10378 seconds</td>
<td>13.71728 seconds</td>
<td>0.01677 seconds</td>
</tr>

<tr>
<td>8000</td>
<td>8000</td>
<td>0.24075 seconds</td>
<td>39.52925 seconds</td>
<td>17.08021 seconds</td>
<td>0.0192 seconds</td>
</tr>

<tr>
<td>9000</td>
<td>9000</td>
<td>0.25785 seconds</td>
<td>48.37365 seconds</td>
<td>21.51451 seconds</td>
<td>0.0225 seconds</td>
</tr>

<tr>
<td>10000</td>
<td>10000</td>
<td>0.30643 seconds</td>
<td>59.90875 seconds</td>
<td>25.93183 seconds</td>
<td>0.02465 seconds</td>
</tr>
</tbody>
</table>




<div style="margin: 0 auto;" class="my-4 border border-light">
    <canvas id="126"></canvas>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.2.0/dist/chart.min.js" integrity="sha256-ovnFmAOngtHmlhZzPyGrofexz4Kdik4kEobc8B9r1Yk=" crossorigin="anonymous"></script>
<script type="text/javascript">
    var ctx = document.getElementById('126').getContext('2d');
    var options = 
{
    type: 'line',
    data: {
      "labels": [
        "1000",
        "2000",
        "3000",
        "4000",
        "5000",
        "6000",
        "7000",
        "8000",
        "9000",
        "10000"
      ],
      "datasets": [
        {
          "label": "Merge sort",
          "data": [
            {
              "x": 1000,
              "y": 0.02285
            },
            {
              "x": 2000,
              "y": 0.04808
            },
            {
              "x": 3000,
              "y": 0.07648
            },
            {
              "x": 4000,
              "y": 0.10607
            },
            {
              "x": 5000,
              "y": 0.14967
            },
            {
              "x": 6000,
              "y": 0.31401
            },
            {
              "x": 7000,
              "y": 0.20681
            },
            {
              "x": 8000,
              "y": 0.24075
            },
            {
              "x": 9000,
              "y": 0.25785
            },
            {
              "x": 10000,
              "y": 0.30643
            }
          ],
          "fill": false,
          "borderColor": "red",
          "backgroundColor": "red",
          "tension": 0.1
        },
        {
          "label": "Bubble sort",
          "data": [
            {
              "x": 1000,
              "y": 0.51674
            },
            {
              "x": 2000,
              "y": 2.14491
            },
            {
              "x": 3000,
              "y": 5.05203
            },
            {
              "x": 4000,
              "y": 9.82914
            },
            {
              "x": 5000,
              "y": 15.07934
            },
            {
              "x": 6000,
              "y": 21.08818
            },
            {
              "x": 7000,
              "y": 29.10378
            },
            {
              "x": 8000,
              "y": 39.52925
            },
            {
              "x": 9000,
              "y": 48.37365
            },
            {
              "x": 10000,
              "y": 59.90875
            }
          ],
          "fill": false,
          "borderColor": "green",
          "backgroundColor": "green",
          "tension": 0.1
        },
        {
          "label": "Insertion sort",
          "data": [
            {
              "x": 1000,
              "y": 0.24463
            },
            {
              "x": 2000,
              "y": 0.97831
            },
            {
              "x": 3000,
              "y": 2.2953
            },
            {
              "x": 4000,
              "y": 4.19266
            },
            {
              "x": 5000,
              "y": 6.75124
            },
            {
              "x": 6000,
              "y": 9.4236
            },
            {
              "x": 7000,
              "y": 13.71728
            },
            {
              "x": 8000,
              "y": 17.08021
            },
            {
              "x": 9000,
              "y": 21.51451
            },
            {
              "x": 10000,
              "y": 25.93183
            }
          ],
          "fill": false,
          "borderColor": "blue",
          "backgroundColor": "blue",
          "tension": 0.1
        },
        {
          "label": "Counting sort",
          "data": [
            {
              "x": 1000,
              "y": 0.00209
            },
            {
              "x": 2000,
              "y": 0.00433
            },
            {
              "x": 3000,
              "y": 0.00654
            },
            {
              "x": 4000,
              "y": 0.0091
            },
            {
              "x": 5000,
              "y": 0.01975
            },
            {
              "x": 6000,
              "y": 0.01431
            },
            {
              "x": 7000,
              "y": 0.01677
            },
            {
              "x": 8000,
              "y": 0.0192
            },
            {
              "x": 9000,
              "y": 0.0225
            },
            {
              "x": 10000,
              "y": 0.02465
            }
          ],
          "fill": false,
          "borderColor": "yellow",
          "backgroundColor": "yellow",
          "tension": 0.1
        }
      ]
    },
    options: {
        maintainAspectRatio: true,
        borderWidth: 3,
        responsive: true,
        interaction: {
            mode: 'x',
            intersect: false
        },
        plugins: {
            title: {
                display: true,
                position: 'bottom',
                text: 'Execution time comparison between bubble sort and insertion sort',
                padding: {
                    top: 10,
                    bottom: 30
                }
            },
            legend: {
                display: true,                
            },            
            tooltip: {
                mode: 'nearest',
                callbacks: {
                    title: function(context){
                        context = context[0];
                        var label = context.label || '';

                        if (label) {
                            label = 'Input size: '+label+' elements';
                        }
                        return label;
                    },
                    label: function(context) {
                        var label = context.dataset.label || '';

                        if (label) {
                            label += ' : ';
                        }
                        if (context.parsed.y !== null) {
                            label += context.parsed.y +" ms";
                        }
                        return label;
                    }
                }
            }            
        },        
        scales: {
            y: {
                beginAtZero: false,
                title: {
                    display: true,
                    text: 'Execution time in seconds'
                },           
                ticks: {
                    callback: function(value, index, values) {
                        return value+ " s";
                    }
                }
            },
            x: {
                beginAtZero: false,
                type: 'linear',
                title: {
                    display: true,
                    text: 'Number of input elements'
                }
            },
        },
    }
};
    new Chart(ctx, options);
</script>


<p>This result is generated using <code>timeit</code> module of Python with the following code.</p>

<pre><code class="language-py">&quot;&quot;&quot;
Compare execution time between merge sort, bubble sort, insertion sort, and counting sort
&quot;&quot;&quot;
from timeit import timeit
import random
import json

data = {
    &quot;input_sizes&quot;: [],
    &quot;max_values&quot;: [],
    &quot;data&quot;: {
        &quot;labels&quot;: [],
        &quot;datasets&quot;: [{
            &quot;label&quot;: 'Merge sort',
            &quot;data&quot;: [],
            &quot;fill&quot;: False,
            &quot;borderColor&quot;: 'red',
            &quot;backgroundColor&quot;: 'red',
            &quot;tension&quot;: 0.1
        }, {
            &quot;label&quot;: 'Bubble sort',
            &quot;data&quot;: [],
            &quot;fill&quot;: False,
            &quot;borderColor&quot;: 'green',
            &quot;backgroundColor&quot;: 'green',
            &quot;tension&quot;: 0.1
        }, {
            &quot;label&quot;: 'Insertion sort',
            &quot;data&quot;: [],
            &quot;fill&quot;: False,
            &quot;borderColor&quot;: 'blue',
            &quot;backgroundColor&quot;: 'blue',
            &quot;tension&quot;: 0.1
        }, {
            &quot;label&quot;: 'Counting sort',
            &quot;data&quot;: [],
            &quot;fill&quot;: False,
            &quot;borderColor&quot;: 'yellow',
            &quot;backgroundColor&quot;: 'yellow',
            &quot;tension&quot;: 0.1
        }]
    }
}


&quot;&quot;&quot;
Implementation of merge sort algorithm

Main File: merge_sort.py
Test File: test_merge_sort.py
&quot;&quot;&quot;


def get_merge_sorted_numbers(numbers):
    &quot;&quot;&quot; Returns sorted list for a given list

    Arguments:
    numbers -- list of numbers
    &quot;&quot;&quot;
    temp = numbers.copy()
    perform_split_and_merge(numbers, temp, 0, len(numbers) - 1)
    return numbers


def perform_split_and_merge(ar, temp, left, right):
    if left &lt; right:
        mid = (right + left) // 2
        perform_split_and_merge(ar, temp, left, mid)
        perform_split_and_merge(ar, temp, mid + 1, right)
        perform_merge(ar, temp, left, mid, right)


def perform_merge(ar, temp, left, mid, right):
    left_pos = left
    right_pos = mid + 1
    current_pos = left
    while left_pos &lt;= mid and right_pos &lt;= right:
        if ar[left_pos] &lt;= ar[right_pos]:
            temp[current_pos] = ar[left_pos]
            left_pos += 1
        else:
            temp[current_pos] = ar[right_pos]
            right_pos += 1
        current_pos += 1
    while left_pos &lt;= mid:
        temp[current_pos] = ar[left_pos]
        left_pos += 1
        current_pos += 1
    while right_pos &lt;= right:
        temp[current_pos] = ar[right_pos]
        right_pos += 1
        current_pos += 1
    for i in range(left, right + 1):
        ar[i] = temp[i]



def get_bubble_sorted_numbers(numbers):
    &quot;&quot;&quot; Returns a sorted list of numbers using bubble sort

    Arguments:
    numbers -- list of numbers
    &quot;&quot;&quot;
    for i in range(len(numbers)):
        swapped = False
        for j in range(len(numbers) - i - 1):
            if numbers[j] &gt; numbers[j + 1]:
                numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]
                swapped = True
        if not swapped:
            break
    return numbers


def get_insertion_sorted_numbers(numbers):
    &quot;&quot;&quot; Returns a sorted list of numbers using insertion sort

    Arguments:
    numbers -- list of numbers
    &quot;&quot;&quot;
    for i in range(1, len(numbers)):
        value = numbers[i]
        j = i - 1
        while j &gt;= 0 and numbers[j] &gt; value:
            numbers[j + 1] = numbers[j]
            j -= 1
        numbers[j + 1] = value
    return numbers


def get_counting_sorted_numbers(numbers, max_value):
    &quot;&quot;&quot; Returns a sorted list of non negative using counting sort

    Arguments:
    numbers -- list of non negative integers within max_value
    max_value -- non negative integer
    &quot;&quot;&quot;
    sorted_numbers = [None] * len(numbers)
    counts = [0] * (max_value + 1)
    for i in numbers:
        counts[i] += 1
    counts[0] -= 1
    for i in range(1, max_value + 1):
        counts[i] += counts[i - 1]
    for i in numbers[::-1]:
        sorted_numbers[counts[i]] = i
        counts[i] -= 1
    return sorted_numbers


def update_execution_time():
    global data
    merge_execution_time = round(
        timeit('result=get_merge_sorted_numbers(unsorted.copy())',
               globals=globals(), number=MAX_ITERATION), 5)
    bubble_execution_time = round(
        timeit('result=get_bubble_sorted_numbers(unsorted.copy())',
               globals=globals(), number=MAX_ITERATION), 5)
    insertion_execution_time = round(
        timeit('result=get_insertion_sorted_numbers(unsorted.copy())',
               globals=globals(), number=MAX_ITERATION), 5)
    counting_execution_time = round(timeit(
        'result=get_counting_sorted_numbers(unsorted.copy(), MAX_NUMBER)',
        globals=globals(), number=MAX_ITERATION), 5)
    execution_times = [merge_execution_time, bubble_execution_time,
                       insertion_execution_time, counting_execution_time]
    for i in range(len(data[&quot;data&quot;][&quot;datasets&quot;])):
        current_execution_time = {
            &quot;x&quot;: MAX_NUMBER,
            &quot;y&quot;: execution_times[i]
        }
        data[&quot;data&quot;][&quot;datasets&quot;][i][&quot;data&quot;].append(current_execution_time)
    data[&quot;data&quot;][&quot;labels&quot;].append(str(MAX_NUMBER))
    data[&quot;input_sizes&quot;].append(MAX_NUMBER)
    data[&quot;max_values&quot;].append(MAX_NUMBER)


def print_output(data):
    print(&quot;| Set Size | Maximum Value | &quot;, end=&quot;&quot;)
    for algorithm in data[&quot;data&quot;][&quot;datasets&quot;]:
        print(algorithm[&quot;label&quot;] + &quot; | &quot;, end=&quot;&quot;)
    print(&quot;&quot;)
    for i in range(len(data[&quot;data&quot;][&quot;datasets&quot;]) + 2):
        if i == 0:
            print(&quot;| &quot;, end=&quot;&quot;)
        print(&quot;--- | &quot;, end=&quot;&quot;)
    print(&quot;&quot;)
    for i in range(len(data[&quot;input_sizes&quot;])):
        print(f'| {data[&quot;input_sizes&quot;][i]} | {data[&quot;max_values&quot;][i]} | ',
              end=&quot;&quot;)
        for j in range(len(data[&quot;data&quot;][&quot;datasets&quot;])):
            print(f'{data[&quot;data&quot;][&quot;datasets&quot;][j][&quot;data&quot;][i][&quot;y&quot;]} seconds | ',
                end=&quot;&quot;)
        print(&quot;&quot;)
    print(json.dumps(data[&quot;data&quot;], indent=2))


if __name__ == &quot;__main__&quot;:
    MAX_ITERATION = 10
    for i in range(1000, 10001, 1000):
        MAX_NUMBER = i
        unsorted = [random.randint(0, MAX_NUMBER) for i in range(MAX_NUMBER)]
        update_execution_time()
    print_output(data)
</code></pre>

<h2 id="practice-challenges">Practice challenges</h2>

<h3 id="easy-difficulty-challenges">Easy difficulty challenges:</h3>

<ul>
<li><a href="https://practice.geeksforgeeks.org/problems/merge-sort/1">Merge sort - Geeksforgeeks</a></li>
</ul>

<h3 id="hard-difficulty-challenges">Hard difficulty challenges:</h3>

<ul>
<li><a href="https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/practice-problems/algorithm/mergesort/">Merge sort - Hackerearth</a> : Solution can be viewed from <a href="https://gist.github.com/arsho/c7e7af845698101cef175bcb27fdb4bc">this gist</a>, I got time limit exceed using Python 3.</li>
<li><a href="https://www.hackerrank.com/challenges/ctci-merge-sort/problem">Merge Sort: Counting Inversions - Hackerrank</a> : Solution can be viewed from <a href="https://gist.github.com/arsho/c7e7af845698101cef175bcb27fdb4bc">this gist</a>, I got time limit exceed using Python 3.</li>
</ul>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="/blog/bubble-sort/">Bubble sort</a></li>
<li><a href="/blog/insertion-sort/">Insertion sort</a></li>
<li><a href="/blog/counting-sort/">Counting sort</a></li>
<li><a href="/blog/sorting-algorithm-comparisons/">Sorting Algorithm Comparisons</a></li>
<li><a href="/blog/understanding-time-complexity/">Understanding Time Complexity</a></li>
<li><a href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to algorithms by Cormen, Thomas H and Leiserson, Charles E and Rivest, Ronald L and Stein, Clifford</a></li>
<li><a href="https://github.com/pllk/cphb/">Competitive Programmer's Handbook</a></li>
<li><a href="https://www.oreilly.com/library/view/40-algorithms-every/9781789801217/">Ahmad, I. (2020). 40 Algorithms Every Programmer Should Know. [S.l.]: Packt Publishing.</a></li>
<li><a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort - Wikipedia article</a></li>
<li><a href="https://docs.python.org/3.6/library/timeit.html#examples">timeit module documentation</a></li>
</ul>

  </article>
  


<h5 class="mb-2 mt-4">Related Contents</h5>
<div class="card-group">
    
    <div class="card">
        <div class="card-body">
            <a href="https://arshovon.com/blog/bubble-sort/" class="card-title">
                Bubble Sort
            </a>
        </div>
        <div class="card-footer">
            <span class="text_muted small">
                
                <a href="https://arshovon.com/categories/algorithm" class="badge badge-secondary" title="algorithm" >
                    <i class="fa fa-folder-open"></i> algorithm</a>
                
            </span>
        </div>
    </div>
    
    <div class="card">
        <div class="card-body">
            <a href="https://arshovon.com/blog/understanding-time-complexity/" class="card-title">
                Understanding Time Complexity
            </a>
        </div>
        <div class="card-footer">
            <span class="text_muted small">
                
                <a href="https://arshovon.com/categories/algorithm" class="badge badge-secondary" title="algorithm" >
                    <i class="fa fa-folder-open"></i> algorithm</a>
                
            </span>
        </div>
    </div>
    
    <div class="card">
        <div class="card-body">
            <a href="https://arshovon.com/blog/sorting-algorithm-comparisons/" class="card-title">
                Sorting Algorithm Comparisons
            </a>
        </div>
        <div class="card-footer">
            <span class="text_muted small">
                
                <a href="https://arshovon.com/categories/algorithm" class="badge badge-secondary" title="algorithm" >
                    <i class="fa fa-folder-open"></i> algorithm</a>
                
            </span>
        </div>
    </div>
    
</div>



  

<div class="card-deck mt-5">
    
    <div class="card mb-3 bg-light border-light">
        <div class="card-body">
            <h5 class="card-title">
                <i class="fa fa-chevron-left"></i> Previous Post
            </h5>
            <p class="card-text">
                <a href="https://arshovon.com/blog/bubble-sort/" class="pt-2 pb-2">
                    Bubble Sort
                </a>
            </p>
        </div>
        <div class="card-footer">
            <span class="text_muted small">
                <time datetime="2021-04-28T03:03:14&#43;06:00">
                    <i class="fa fa-calendar pr-1"></i>April 28, 2021</time>
            </span>
        </div>
    </div>
    
    
</div>



</main>


        </div> 
    </div> 
    <footer class="footer">
    <div class="text-center">
        <small>
            Developed with <i class='fas fa-heart datamate_red'></i> by <a href="https://arshovon.com/" title="Ahmedur Rahman Shovon">Ahmedur Rahman Shovon</a>
        </small>
    </div>
</footer>

    
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js"
  crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
  integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
  crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>

<script src="https://arshovon.com/assets/js/arsho.js"></script>

</body>
</html>
